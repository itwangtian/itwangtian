{
  "docs": [
    {
      "id": 142261036,
      "doc_id": "dczr2vfhgu4n2cft",
      "title": "dczr2vfhgu4n2cft",
      "updated": 1697190024000,
      "body_original": "> **git常用的六个命令**：1、第一次初始化；2、初始化仓库；3、加到缓存区；4、提交至本地仓库；5、推送本地仓库信息至远程仓库；6、拉取远程仓库最新文件。其中，第一次初始化有两种方式，一种语句较多，另一种语句较少。\n\n## 精简版操作git\n### 初始化\n\n1. git init  【初始化init】\n2. git add . 【提交到缓存区】\n3. git commit -m ‘代码描述’【提交到本地仓库】\n4. git remote add origin `git 仓库地址，https开头的，码云粘贴` 【本地仓库与云端关联】\n5. git pull origin master 【提交到云端仓库，如未成功，执行下面强制推送】\n6. git push origin master # -f 【强推】\n### 后续操作仓库\n初始化成功后，后面操作仓库，常用4个命令\n\n1. git pull 从云端仓库拉取最新代码\n2. git add . 提交缓冲区\n3. git commit -m \"修改代码\" 提交本地仓库\n4. git push 提交到云端仓库\n## 1、第一次初始化\n\n- git init  【初始化init】\ngit add . 【提交到缓存区】\ngit commit -m ‘代码描述’【提交到本地仓库】\ngit remote add origin `git 仓库地址，https开头的，码云粘贴` 【本地仓库与云端关联】\ngit pull origin master 【提交到云端仓库，如未成功，执行下面强制推送】\ngit push origin master # -f 【强推】\n## 2、初始化仓库\ngit init\n## 3、加到缓存区\n\n- git add .：添加所有项目至缓存区\n- git add 目录名：添加指定目录到缓存区\n- git add 文件名：添加指定文件到缓存区\n## 4、提交至本地仓库\ngit commit -m “注释信息”\n## 5、推送本地仓库信息至远程仓库\n\n- git push origin master：将本地分支的更新内容，全部推送至远程仓库 master 分支\n- git push origin dev：将本地 dev 分支推送到远程，再由一个人统一加到 master 分支上\n## 6、拉取远程仓库最新文件\n\n- git pull：拉取远程仓库所有分支合并到本地\n- git pull origin master：拉取远程master分支，合并到当前本地master分支\n- git fetch：仅做拉取操作，不做合并，合并需要自己再找其他方法\n\n注意：一般都用 git pull\n### 拓展阅读\n## Git 命令个别专用名词译名\nWorkspace：工作区\nIndex / Stage：暂存区\nRepository：仓库区（或本地仓库）\nRemote：远程仓库\n\n",
      "properties": {
        "title": "git常用的六个命令",
        "urlname": "dczr2vfhgu4n2cft",
        "date": "2023-10-13 17:24:33",
        "updated": "2023-10-13 17:40:24"
      },
      "catalog": [
        {
          "title": "环境搭建",
          "doc_id": "dczr2vfhgu4n2cft"
        }
      ],
      "body": "",
      "realName": "dczr2vfhgu4n2cft",
      "relativePath": "\\dczr2vfhgu4n2cft.md"
    },
    {
      "id": 137091307,
      "doc_id": "clggvok4l4xn2ftt",
      "title": "clggvok4l4xn2ftt",
      "updated": 1697184150000,
      "body_original": "# ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1694414687096-0b0bcdcf-041b-40af-b0d5-474c422f3545.png#averageHue=%23242322&clientId=u4ac63ddd-24aa-4&from=paste&height=291&id=ub1f45290&originHeight=859&originWidth=762&originalType=binary&ratio=2&rotation=0&showTitle=false&size=138946&status=done&style=none&taskId=u43fa0268-2b04-48e8-b97c-4b572c65c3c&title=&width=258)\n# ES7+ React/Redux/React-Native snippets\n提供了一组代码片段和快捷方式，用于快速开发 React、Redux 和 React Native 应用。可以快速导入 React、Redux 相关的模块，自动生成组件的 PropTypes 类型检查等等。这些功能可以节省你在编辑器中的时间和精力，帮助你更专注于实际的开发任务。\n# ESlint \n校验代码语法，自动修复\n# **React Redux Toolkit RTK Query Snippets**\nredux-toolkit 代码片段合集\n## 无法安装怎么办？\n:::warning\n注意！如vscode版本太低，会导致无法安装，需要自定义新建代码片段\n:::\n\n- 【推荐】升级vscode版本 \n- 【无法升级版本】自定义vscode代码片段\n\n1、打开vscode 快捷键 `ctrl+shift+p`\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1697160068788-6bec6941-bb4a-4343-8bb0-db6d53c785b3.png#averageHue=%23272525&clientId=u55517325-6eca-4&from=paste&height=420&id=uedcf077a&originHeight=839&originWidth=1279&originalType=binary&ratio=2&rotation=0&showTitle=false&size=151470&status=done&style=none&taskId=u687a7d62-7038-429d-8b11-6c1d92b3f4a&title=&width=639.5)\n2、新建代码片段\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1697160381466-cf3eb48f-9197-4dff-ab35-9f33754146b4.png#averageHue=%23262525&clientId=u55517325-6eca-4&from=paste&height=367&id=u44c27cde&originHeight=733&originWidth=1198&originalType=binary&ratio=2&rotation=0&showTitle=false&size=91566&status=done&style=none&taskId=u33590f70-0d12-415f-a7c1-ad1acfdb22c&title=&width=599)\n3、输入代码片段的文件名，名称自定义\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1697160410300-1b35bb52-fada-46d9-b28f-3cc9f19a9937.png#averageHue=%232b2b2b&clientId=u55517325-6eca-4&from=paste&height=69&id=u4ef8c30a&originHeight=137&originWidth=1208&originalType=binary&ratio=2&rotation=0&showTitle=false&size=18502&status=done&style=none&taskId=uc9c6991e-6b95-48e6-9fed-d47c274a945&title=&width=604)\n4、输入名称后回车，自动生成一个`.code-sinppets`后缀名的文件，我们在此文件定义代码片段\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1697160613477-f9c93ad1-b3ae-4dbd-98ea-4982611f12d4.png#averageHue=%23201f1f&clientId=u55517325-6eca-4&from=paste&height=407&id=u2841399d&originHeight=814&originWidth=1508&originalType=binary&ratio=2&rotation=0&showTitle=false&size=149185&status=done&style=none&taskId=uecb468b9-b701-49c4-b828-60618bde67c&title=&width=754)\n如下是redux-slice代码片段，复制，粘贴替换到`.code-sinppets`后缀名的文件\n```json\n{\n  \"Redux Toolkit Slice\": {\n    \"prefix\": \"srtslice\",\n    \"body\": [\n      \"import { createSlice } from \\\"@reduxjs/toolkit\\\";\",\n      \"\",\n      \"const ${1:sliceName} = createSlice({\",\n      \"    name: \\\"${1:sliceName}\\\",\",\n      \"    initialState: {},\",\n      \"    reducers: {\",\n      \"        invalidate: (state, { payload }) => {\",\n      \"            payload.forEach(item => {\",\n      \"                state[item] = false;\",\n      \"            });\",\n      \"        },\",\n      \"    },\",\n      \"    extraReducers: builder => builder\",\n      \"        .addCase(${2:actionName.pending}, (state, { payload }) => {\",\n      \"            state.loading = true;\",\n      \"        })\",\n      \"        .addCase(${2:actionName.fulfilled}, (state, { payload }) => {\",\n      \"            state.loading = false;\",\n      \"        })\",\n      \"        .addCase(${2:actionName.rejected}, (state, { payload }) => {\",\n      \"            state.loading = false;\",\n      \"            state.error = payload;\",\n      \"        })\",\n      \"});\",\n      \"\",\n      \"export const { invalidate } = ${1:sliceName}.actions;\",\n      \"export default ${1:sliceName}.reducer;\"\n    ],\n    \"description\": \"Redux Toolkit slice template\"\n  }\n}\n\n```\n# ESLint Chinese Rules\neslint中文规则提示插件\n",
      "properties": {
        "title": "vscode 插件合集",
        "urlname": "clggvok4l4xn2ftt",
        "date": "2023-08-23 08:45:05",
        "updated": "2023-10-13 16:02:30"
      },
      "catalog": [
        {
          "title": "环境搭建",
          "doc_id": "clggvok4l4xn2ftt"
        }
      ],
      "body": "",
      "realName": "clggvok4l4xn2ftt",
      "relativePath": "\\clggvok4l4xn2ftt.md"
    },
    {
      "id": 141225759,
      "doc_id": "od0ahbmsfgdw3kpm",
      "title": "od0ahbmsfgdw3kpm",
      "updated": 1697337839000,
      "body_original": "# 前言\n这两天在尝试用语雀＋vuepress＋github 搭建个人博客。\n小破站地址 ：[王天的web进阶之路](https://itwangtian.com) \n语雀作为编辑器，发布文档推送github，再自动打包部署，大概流程如下。\n![](https://cdn.nlark.com/yuque/0/2023/jpeg/1450835/1696073050382-a07647ea-e2b6-4e21-8388-178bc55d31de.jpeg)\n## 问题\n我使用的`elog`插件批量导出语雀文档。`elog`采用的配置是所有文章平铺导出，没有按照语雀知识库目录生成`markdown`，这导致vuepress侧边栏无法和语雀一致，如下图。\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1696066190179-22cba74c-4fef-4675-9359-a861d41624ae.png#averageHue=%23e1b47c&clientId=uffafbd66-8de2-4&from=paste&height=737&id=ucccf07a3&originHeight=1473&originWidth=2813&originalType=binary&ratio=2&rotation=0&showTitle=false&size=495734&status=done&style=none&taskId=uc2c08229-3e7a-4abb-8f59-be8fb319203&title=&width=1406.5)\n上图，左侧是语雀知识库，右侧是导出到vuepress展示的效果，很明显没有目录这很影响阅读体验呀\n## 解决\n在查阅vuepress文档后，发现配置`silderbar.ts`可以自定义侧边栏目录，配置参数如下：\n```tsx\nexport default {\n  theme: defaultTheme({\n    // 可折叠的侧边栏\n    sidebar: {\n      '/web/': [\n        {\n          text: '王天的web进阶手册',\n          collapsible: true,// 目录是否折叠\n          children: ['/reference/cli.md', '/reference/config.md'],// 文档目录\n        },\n        {\n          text: '王天的魔法工具箱',\n          collapsible: true,\n          children: ['/reference/bundler/vite.md', '/reference/bundler/webpack.md'],\n        },\n      ],\n    },\n  }),\n}\n```\n## 递归生成菜单\n配置`sidebar.ts` 可以修改左侧菜单，但是一个个手动修改这忒麻烦了啊啊啊啊。那如何批量生产菜单配置项呢？\n\n**递归函数呀呀呀呀呀呀  🔥🔥🔥🔥**\n\n> elog 在同步语雀文档时，会自动创建`elog.cache.json`缓存文件，在vueprss项目根目录中查看。\n\n\n打开`elog.cache.json`文件，我们能看到语雀文档知识库的数据结构\n```json\n\"catalog\": [\n    {\n      \"type\": \"DOC\",\n      \"title\": \"前言\",\n      \"uuid\": \"17Os-_V_hcS37KOD\",\n      \"url\": \"wqbpyf5083qc7ho8\",\n      \"prev_uuid\": \"\",\n      \"sibling_uuid\": \"dmQSRn6AXUBSg96x\",\n      \"child_uuid\": \"\",\n      \"parent_uuid\": \"\",\n      \"doc_id\": 141216125,\n      \"level\": 0,\n      \"id\": 141216125,\n      \"open_window\": 1,\n      \"visible\": 1\n    }\n  ]\n```\ncatlog属性是文档缓存数据，关键字段：\n\n- type：值为'DOC' 是文章、值为TITLE 则为目录\n- uuid：文章id\n- prent_uuid:父节点的uuid\n\n咱们根据以上参数，编写递归函数， 将`elog.cache.json`的一维数组，递归生成vuepress 侧边栏配置数据\n代码如下：\n```typescript\nfunction genYuqueRoute() {\n  // 参数1:遍历数组\n  // 参数2:父菜单id\n  const deep = (arrlist,parantId) => {\n    let forList:any[] = []\n    arrlist.forEach(element => {\n      // 菜单id不一致，跳出循环调用\n      if(element.parent_uuid !== parantId) return\n      // 如果是TITLE类型新增配置项\n      if(element.type === 'TITLE'){\n          forList.push({\n            text:element.title,\n            collapsible:true,\n            children:deep(arrlist,element.uuid)\n          })\n        // 如果是DOC 类型追加文件地址 \n      }else{\n          forList.push(element.url+'.md')    \n        }\n      \n    }); \n    return forList \n  }\n   return deep(catalog,'')\n}\n```\n## 效果\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1697337079476-f6d6fc34-9f9c-4ff4-a45e-d04d70434bef.png#averageHue=%23fcfbfb&clientId=ub0e41927-ad24-4&from=paste&height=587&id=ucd769c03&originHeight=1173&originWidth=1948&originalType=binary&ratio=2&rotation=0&showTitle=false&size=264005&status=done&style=none&taskId=u8955ce1c-ab99-40a8-87a9-fab70f24c27&title=&width=974)\n\n## 敲重点啦！\n递归函数本质上是一个在回调自身的函数，用于改造数据结构，重点在于跳出循环的机制，否则陷入死循环啦\n# DFS vs BFS ？\n什么是DFS 、BFS ?\n\n- DFS 深度优先搜索：可以用于找到一条路径、判断图中是否存在循环、拓扑排序、生成连通分量等。\n- BFS 广度优先搜索：可以用于找到最短路径、生成最小生成树、进行网络分析等。\n\n:::danger\n🧚🏻‍♀️简单理解为，横向 、竖向 遍历据状结构\n\n- 深度优先搜索，对数据结构的横向执行，从第一行遍历子节点、叶子节点，依次直到最后一行。\n- 广度优先搜索，对数据结构的竖向执行，把树结构平面铺开、以层级数为列数，从第一列依次执行。\n:::\n\n将深度搜索、广度搜索代入到生活场景更容易理解。\n\n咱们先看一个家庭关系树状图，爷爷奶奶是一级属性、父母叔伯二级、孙子孙女三级属性、重孙们是四级属性，以此类推。形成一个家庭关系树状图。\n假如奶奶过八十大寿，按辈分来，首先是父母叔伯这一辈祝寿，其次是孙子孙女辈分，最后重孙们，以此类推，这个竖向执行的祝寿过程就是广度优先搜索\n那过年走亲戚的话，咱们没有俺辈分，去分批的吧？至少我们老家不是的，都是一去一家子呢。那这个横线执行的过程，就是深度优先搜索。\n\n#### 深度优先搜索（DFS）示例代码：\n从A节点依次取出数据\n```javascript\n// 图的邻接表表示\nconst graph = {\n    A: ['B', 'C'],\n    B: ['D', 'E'],\n    C: ['F', 'G'],\n    D: [],\n    E: [],\n    F: [],\n    G: []\n  };\n  \n  // 使用深度优先搜索遍历图\n  function dfs(graph, start) {\n    const visited = new Set(); // 存储已访问节点的集合\n  \n    function traverse(node) {\n      visited.add(node); // 将当前节点标记为已访问\n      console.log(node); // 打印遍历的节点\n  \n      const neighbors = graph[node]; // 获取当前节点的邻居节点\n      for (const neighbor of neighbors) { // 遍历当前节点的邻居节点\n        if (!visited.has(neighbor)) { // 如果邻居节点未被访问过\n          traverse(neighbor); // 递归遍历邻居节点\n        }\n      }\n    }\n  \n    traverse(start); // 从起始节点开始进行深度优先搜索\n    return visited; // 返回所有已访问的节点\n  }\n\n\n  \n```\n输出结果：\n```javascript\n dfs(graph, 'A'); // 对图进行深度优先搜索，从起始节点 'A' 开始，并打印遍历结果\n// A\n// B\n// D\n// E\n// C\n// F\n// G\n```\n\n在上述代码中，图使用邻接表表示，`dfs` 函数使用递归方式实现了深度优先搜索。从起始节点 `'A'` 开始，递归访问其邻居节点，并在访问时输出节点的值。\n\n#### 广度优先搜索（BFS）示例代码：\n\n```javascript\n// 广度搜索 BFS\nlet graph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'C', 'D'],\n    'C': ['A', 'D', 'E'],\n    'D': ['B', 'C', 'E'],\n    'E': ['C', 'D', 'F'],\n    'F': ['E','W'],\n    'W':['C']\n  };\n  \n  function bfs(graph, startPoint) {\n    let queue = []; // 用于存储待访问节点的队列\n    let result = []; // 存储遍历结果的数组\n  \n    queue.push(startPoint); // 将起始节点添加到队列\n    result.push(startPoint); // 将起始节点添加到遍历结果\n  \n    while (queue.length > 0) { // 当队列不为空时进行循环\n      let point = queue.shift(); // 取出队列中的第一个节点作为当前节点\n      let nodes = graph[point]; // 获取当前节点的所有邻居节点\n      for (let node of nodes) { // 遍历当前节点的邻居节点\n        if (result.includes(node)) continue; // 如果邻居节点已经在遍历结果中，则跳过\n        result.push(node); // 将邻居节点添加到遍历结果中\n        queue.push(node); // 将邻居节点添加到队列中，以便后续访问其邻居节点\n      }\n    }\n  \n    return result; // 返回遍历结果\n  }\n  \n  console.log(bfs(graph, 'B')); // 执行广度优先搜索，从起始节点 'B' 开始，并输出遍历结果\n    \n```\n\n在上述代码中，图使用邻接表表示，`bfs` 函数使用队列实现了广度优先搜索。从起始节点 `'A'` 开始，将其加入队列并标记为已访问，然后依次从队列中取出节点，并访问其邻居节点，同时将邻居节点加入队列中，直到队列为空。\n\n## 案例\n深度优先搜索（DFS）和广度优先搜索（BFS）在前端项目中有许多实际的应用场景。下面有两个常见的前端开发项目案例\n\n## 1、组件树遍历\n\n在前端开发中，经常会有需要对组件树进行遍历的场景，例如渲染组件、查找组件等。下面是一个使用DFS进行组件树遍历的示例：\n\n```javascript\nfunction dfs_component_traversal(component) {\n  console.log(component); // 处理当前组件\n\n  if (component.children) {\n    for (const child of component.children) {\n      dfs_component_traversal(child); // 递归遍历子组件\n    }\n  }\n}\n```\n\n以上的代码展示了一个使用深度优先搜索进行组件树遍历的函数。我们可以根据组件的层级关系，从根组件开始递归地遍历每个组件及其子组件，以实现对整个组件树的遍历和操作。\n\n这个算法可以帮助我们在前端项目中处理组件之间的关系，例如渲染组件、查找相关组件等。通过对组件树的深度遍历，我们可以有序地处理组件及其子组件，并执行相应的操作。\n\n## 2、页面导航\n\n在前端开发中，页面导航是一个常见的需求。我们可以使用广度优先搜索来实现页面导航功能，以确保按照层级关系有序地展示页面。\n\n```javascript\nfunction bfs_page_navigation(page) {\n  const queue = [page];  // 使用队列作为辅助数据结构来进行广度优先搜索\n\n  while (queue.length > 0) {\n    const current = queue.shift();  // 移除队列头部元素作为当前页面\n    console.log(current);  // 处理当前页面\n\n    for (const child of current.children) {\n      queue.push(child);  // 将子页面加入队列\n    }\n  }\n}\n```\n\n以上代码展示了一个使用广度优先搜索进行页面导航的函数。在这个函数中，我们使用队列作为辅助数据结构来进行广度优先搜索。通过不断将子页面加入队列，并按照队列中的顺序处理每个页面，可以实现按照层级关系有序地导航页面。\n\n## 3、DFS + BFS 综合案例\n```javascript\nconst root = {\n    value: 1,\n    children: [\n      {\n        value: 2,\n        children: [],\n      },\n      {\n        value: 3,\n        children: [\n          {\n            value: 7,\n            children: [\n              {\n                value: 8,\n                children: [],\n              },\n            ],\n          },\n        ],\n      },\n      {\n        value: 4,\n        children: [\n          {\n            value: 6,\n            children: [],\n          },\n        ],\n      },\n    ],\n    \n  };\n\n// 在深度优先搜索 - 堆\n// 我们首先处理当前节点，然后递归地处理每个子节点、直到叶子节点（没有子节点的节点），最后依次遍历完成\n  const digui = (node)=>{ \n    console.log(node.value) \n    if(node.children){\n        for(const children of node.children){\n            digui(children) \n        }\n    } \n  }\n// 广度优先搜索-栈，把多维树结构，取出来平铺，依次访问。\n// 在广度优先搜索中，我们使用队列来保存待访问的节点，确保按照层级顺序进行遍历。\n// 每次从队列中取出队头节点，处理该节点后，将其邻居节点（子节点）入队，以便后续遍历。这样，就可以依次访问所有节点，并保持层级顺序。\n\n  function breadthFirstSearch(root) {\n    if (!root) {\n      return;\n    }\n  \n    const queue = []; // 创建一个空队列，用于存放待访问的节点\n    queue.push(root); // 将根节点入队\n  \n    while (queue.length !== 0) { // 当队列不为空时循环执行以下步骤\n      const current = queue.shift(); // 出队队头节点作为当前节点\n      console.log(current.value); // 进行二次加工或其他操作，这里简单地输出节点的值\n  \n      for (const child of current.children) { // 遍历当前节点的邻居节点（子节点）\n        queue.push(child); // 将未访问过的邻居节点入队\n      }\n    }\n}\n  console.log(digui(root))\n\n  console.log(breadthFirstSearch(root))\n```\n# 总结\n深度优先搜索（DFS）的原理很简单：我们从起始节点开始，沿着一条路径不断向下探索，直到达到终点或者无法继续为止。如果遇到终点，就找到了一条路径；如果无法继续，则回溯到上一个节点，然后尝试探索其他路径。这个过程会递归地进行，或者使用栈来存储节点的顺序。\n\n相比之下，广度优先搜索（BFS）的原理稍微有些不同：我们从起始节点开始，逐层地访问其邻居节点。也就是说，我们首先访问起始节点的邻居节点，然后是邻居节点的邻居节点，依此类推，直到遍历完所有节点或者找到目标节点为止。为了遍历节点的顺序，我们使用队列数据结构。\n",
      "properties": {
        "title": "一个vuepress配置问题，引发的js递归算法思考",
        "urlname": "od0ahbmsfgdw3kpm",
        "date": "2023-09-29 17:29:23",
        "updated": "2023-10-15 10:43:59"
      },
      "catalog": [
        {
          "title": "案例开发",
          "doc_id": "od0ahbmsfgdw3kpm"
        }
      ],
      "body": "",
      "realName": "od0ahbmsfgdw3kpm",
      "relativePath": "\\od0ahbmsfgdw3kpm.md"
    },
    {
      "id": 133257249,
      "doc_id": "gkpaocb8zzni39bg",
      "title": "gkpaocb8zzni39bg",
      "updated": 1697167274000,
      "body_original": "# Js VS Ts\n分享一个学习编程的小诀窍，我屡试不爽，效果很赞呢！\n是什么呢？ 就是**对比，**用积累的知识和经验，与新的概念和知识对比联系，能帮助加深理解和记忆，并促进应用和内化。\n为了更好的学习效果，咱们以对比的形式、了解和认识typeScript。下面从定义、优势、应用场景这三个角度，逐个介绍。\n> 所以，在读这篇文章时，建议你有一定的JavaScript基础。\n\n## 定义\n`JavaScript`是一种动态类型的编程语言[为什么说js是动态类型语言呢？](https://www.yuque.com/nh0s08/ycsiao/nfknzexbccraar99?singleDoc=&view=doc_embed)\n它是一种解释性的脚本语言，常用于前端网页开发和服务器端开发。JavaScript的特点是灵活，允许在运行时动态修改对象的结构和属性，进行隐式转换修改数据类型，适合用于快速原型设计和开发。\n\n`TypeScript`[typeScript是js的超集](https://www.yuque.com/nh0s08/ycsiao/bf2pmua2hv1623o9?singleDoc=&view=doc_embed) 是一种静态类型的编程语言，需要在编译阶段进行类型检查，并将TypeScript代码转换为JavaScript代码。TypeScript的目标是增强JavaScript的可维护性和可扩展性，特别适用于大型项目和团队开发。\n## 优势：\n`JavaScript`的优势：\n\n1. 广泛的支持和使用：JavaScript是Web开发的标准语言，在浏览器中直接执行，无需编译。\n2. 灵活性：JavaScript的动态类型使得在开发过程中更加灵活，可以快速迭代和修改代码。\n3. 生态系统：JavaScript有庞大的开发社区和丰富的第三方库和框架，提供了丰富的工具和资源。\n\n`TypeScript`的优势：\n\n1. 静态类型检查：TypeScript可以在编译阶段捕获错误，提供更好的代码质量和可维护性。类型检查可以在开发过程中发现潜在的问题，并提供更好的开发工具支持，例如代码智能提示和重构功能。\n2. 类和模块系统：TypeScript支持类和模块的概念，使得代码组织和重用更加清晰和易于理解。\n3. 渐进式采用：由于TypeScript是JavaScript的超集，可以逐步将现有的JavaScript代码转换为TypeScript代码，无需一次性迁移。这使得团队可以渐进地采用TypeScript，而不需要从头开始重写代码。\n4. 强大的工具支持：TypeScript提供了丰富的开发工具支持，如编辑器插件、调试器、测试框架等，提高了开发效率和代码质量。\n\n## 何时选择：JS 和 TS的区别\n### typeScript\n类型安全和错误检测  | 使用一些 JavaScript 校验工具 会增加运行时开销，可以通过typeScript 编译时验证\n学习成本 |   熟悉静态类型语言，或者需要在大型项目中进行团队协作，那么选择 TypeScript 可能更为理想\n 迁移升级 |  TypeScript 还提供了工具和指南，以帮助你将 JavaScript 代码迁移到 TypeScript。\n### JavaScript\n小项目   |  代码量较少的项目中使用typeScript有点校正过头了，选择 JavaScript 可能更合适\n生态丰富 | JavaScript 有着广泛的生态系统和丰富的第三方库支持，适用于各种领域和平台\n## 总结\njavaScript 支持隐式转换，是一种灵活的编程语言，但这是一把双刃剑，常常伴随语法错误、编程不规范等问题\ntypeScript的出现，弥补JavaScript缺陷，拓展许多功能和特性，更适合开发大型项目，提高维护性，减少bug。\n\nTypeScript 的优势所在，总结下来有三点： \n1. 规避⼤量低级错误，避免时间浪费，省时 \n2. 减少多⼈协作项⽬的成本，⼤型项⽬友好，省⼒ \n3. 良好代码提示，不⽤反复⽂件跳转或者翻⽂档，省⼼\n\n# 从0到1上手typescript\n## 01 安装typeScript\n推荐使用国内镜像\n```javascript\ntsc\n```\n命令行安装\n```bash\nnpm install -g typescript  // 全局安装\n```\n安装完使用 tsc 命令查看版本号\n```javascript\ntsc -v\n// 输出版本号 Version 5.1.6\n```\n## 02 配置开发工具  \n主流开发工具均支持typeScript语法，我个人推荐 vs Code，集成丰富插件，语法提示、代码补全等功能。\n下载安装：[Visual Studio Code - Code Editing. Redefined](https://code.visualstudio.com/)\n**中文语言包  **vsCode 默认下载是英文配置，如需中文，需下载 chines  语言包\n![](https://gyg-bawei-gz4-01.oss-cn-beijing.aliyuncs.com/vuepress/1686877307640-17fb4ef7-29e0-47ce-b4bc-a796e14134c1.png#id=nRrkh&originHeight=1181&originWidth=1919&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n## 03 hi typeScript\n来，开始创建你的第一个 ts 文件吧\n打开编辑器，将下方代码保存到 `hi.js` 文件中\n```javascript\n// 用 ： 定义了 persson类型 为string\nfunction sayHello(person: string) {\n  return 'Hello, ' + person;\n}\n\nlet user = 'Tom';\nconsole.log(sayHello(user));\n```\n编译执行，输入以下命令\n```vue\ntsc hi.js \n```\n执行成功，会生成一个同名的 js 文件\n![](https://gyg-bawei-gz4-01.oss-cn-beijing.aliyuncs.com/vuepress/1689499060443-bacafb3b-d213-4c7c-b676-a162d8d20828.png#id=EaC9E&originHeight=167&originWidth=1143&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n内容如下：\n```javascript\nfunction sayHello(person) {\n\n    return 'Hello, ' + person;\n}\n\nvar user = 'Tom';\nconsole.log(sayHello(user));\n```\n在ts中，已经使用 `:`定义了 `persson`类型 ，为什么编译后的 js 代码，未检查`person`类型呢 ？\n\n因为 `typeScript`只会在编译时对检测类型，如有错误，在编译阶段就会报错。其实`typeScript`在运行阶段和JavaScript一样，不会对类型检查。\n\n",
      "properties": {
        "title": "Ts vs Js 谁适合前端开发？| 01",
        "urlname": "gkpaocb8zzni39bg",
        "date": "2023-07-14 23:31:22",
        "updated": "2023-10-13 11:21:14"
      },
      "catalog": [
        {
          "title": "typescript 入门指南",
          "doc_id": "gkpaocb8zzni39bg"
        }
      ],
      "body": "",
      "realName": "gkpaocb8zzni39bg",
      "relativePath": "\\gkpaocb8zzni39bg.md"
    },
    {
      "id": 138945863,
      "doc_id": "wr68nublwv2vdtch",
      "title": "wr68nublwv2vdtch",
      "updated": 1697182757000,
      "body_original": "# 无法将“git”项识别为cmdlet\ngit :无法将“git”项识别为cmdlet、 函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路经正\n## 解决方式\n1、更改环境配置\n[git : 无法将“git”项识别为](https://m.baidu.com/sf?pd=topone_trustpaper&resource_id=55858&word=git+:+%E6%97%A0%E6%B3%95%E5%B0%86%E2%80%9Cgit%E2%80%9D%E9%A1%B9%E8%AF%86%E5%88%AB%E4%B8%BA&ext=%7B%22url%22%3A%22http%3A%5C%2F%5C%2Fwww.taodudu.cc%5C%2Fnews%5C%2Fshow-6407388.html%22%2C%22srcid%22%3A%2228420%22%2C%22jumptype%22%3A%22text%22%2C%22urlsign%22%3A%223819040033359751954%22%2C%22sitesign%22%3A%223544305091466905480%22%2C%22query%22%3A%22git+%3A%5Cu65e0%5Cu6cd5%5Cu5c06%5Cu201cgit%5Cu201d%5Cu9879%5Cu8bc6%5Cu522b%5Cu4e3acmdlet%5Cu3001%22%2C%22token%22%3A%22c89ec5%22%7D&top=%7B%22sfhs%22:1%7D&atn=index&lid=11902020421571769082)\n2、安装git 后，在项目根目录，打开右键使用 git bash herf \n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1697179645015-d0cab022-886a-43ec-99d5-de849cb2fe64.png#averageHue=%23b3c0bb&clientId=ufd101da0-3be0-4&from=paste&height=528&id=u55ee9046&originHeight=1055&originWidth=1601&originalType=binary&ratio=2&rotation=0&showTitle=false&size=2895980&status=done&style=none&taskId=ua79a3a8b-5cdf-45ff-8c6b-750c93f70e3&title=&width=800.5)\n\n# remote origin already exists.\n![YP[EPT0~_Q$5}Z8@%G0$KNK_tmb.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1697179775274-de45e3c3-c5c1-4890-8056-4ebbc42d96ba.png#averageHue=%232b322a&clientId=ufd101da0-3be0-4&from=paste&height=148&id=u3e9e3706&originHeight=295&originWidth=1280&originalType=binary&ratio=2&rotation=0&showTitle=false&size=108316&status=done&style=none&taskId=u14fe0927-7d7b-4e05-a51b-facaf56d6c9&title=&width=640)\n本地仓库与远端仓库链接错误\n## 解决方式\n删除与远端仓库的配置\n```javascript\ngit remote rm origin\n```\n重新设置与远端仓库链接，再次执行\n```javascript\ngit remote add origin https://xxx 远端仓库 \n```\n",
      "properties": {
        "title": "git 常见报错",
        "urlname": "wr68nublwv2vdtch",
        "date": "2023-09-10 18:58:47",
        "updated": "2023-10-13 15:39:17"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "wr68nublwv2vdtch"
        }
      ],
      "body": "",
      "realName": "wr68nublwv2vdtch",
      "relativePath": "\\wr68nublwv2vdtch.md"
    },
    {
      "id": 141767061,
      "doc_id": "bp437kq13uf9ch6d",
      "title": "bp437kq13uf9ch6d",
      "updated": 1696824979000,
      "body_original": "eslint检测代码规范、pretter修复代码格式，他们功能有一些重叠，配置不当情况下、比如eslint设置单引号、prettier双引号，会导致编译执行错误，导致冲突，如何解决呢？\n\n冲突本质原因是eslint和prettier并行导致，解决冲突的方法好几种：\n\n1. 关闭冲突规则\n2.  调整执行顺序\n3. 手动调整-统一配置\n## 关闭冲突规则\n使用 eslint-config-prettier 插件来禁用 ESLint 中与 Prettier 冲突的规则。\n该插件会将 Prettier 的规则应用到 ESLint 中，并自动禁用冲突的规则。您可以在 ESLint 配置文件中添加以下配置：\n\n1. 安装 eslint-config-prettier：\n```\nnpm install --save-dev eslint-config-prettier\n```\n\n2. 将 eslint-config-prettier 添加到您的 ESLint 配置中 – [eslintrc](https://eslint.org/docs/latest/use/configure/configuration-files)或[eslint.config.js](https://eslint.org/docs/latest/use/configure/configuration-files-new)\n```\n{\n  \"extends\": [\"eslint:recommended\", \"plugin:prettier/recommended\"],\n  // 其他配置项\n}\n```\n这样 ESLint 将使用 Prettier 的规则，并且禁用与其冲突的规则。\n## 调整执行顺序\n 可以使用 eslint-plugin-prettier 插件将 Prettier 集成到 ESLint 中。该插件将在检查代码的同时自动应用 Prettier 的格式化规则，确保代码风格一致。\n1、安装 eslint-plugin-prettier\n```javascript\nnpm i eslint-plugin-prettier\n```\n2、将prettier放在最后，因为后面的配置项会覆盖前面的；\n\n```\n{\n  \"plugins\": [\"prettier\"],\n  \n}\n```\n3、修改rules，将prettier的规则配置写入eslint，这样eslint会一同校验prettier规则\n```\n\n{\n  \"plugins\": [\"prettier\"],\n  \"rules\": {\n      \"prettier/prettier\": \"error\",\n      // 其他规则\n    }\n  \n}\n```\n## 手动调整-统一配置\n用手撸吧！将prettier和eslint配置设置一致即可\n",
      "properties": {
        "title": "解决eslint和prettier冲突",
        "urlname": "bp437kq13uf9ch6d",
        "date": "2023-10-09 10:41:40",
        "updated": "2023-10-09 12:16:19"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "bp437kq13uf9ch6d"
        }
      ],
      "body": "",
      "realName": "bp437kq13uf9ch6d",
      "relativePath": "\\bp437kq13uf9ch6d.md"
    },
    {
      "id": 140313379,
      "doc_id": "sdgpnwvrp82ng4pr",
      "title": "sdgpnwvrp82ng4pr",
      "updated": 1696692127000,
      "body_original": "# 前言\n使用react-redux的朋友都经历过这种痛苦吧？\n定义一个store仓库，首先创建各种文件，比如reducer、action、store...，然后 将redux和react连接使用。整个流程繁琐，写起来代码冗余。 \nreact-redux创建仓库，文件目录如下：\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1695126608851-248ffdf2-de52-4c6d-bc6b-9d831c332b0b.png#averageHue=%231b1a19&clientId=u0f1adae6-0275-4&from=paste&height=136&id=u99d385c2&originHeight=272&originWidth=600&originalType=binary&ratio=2&rotation=0&showTitle=false&size=15050&status=done&style=none&taskId=uc9979f17-04fa-407d-89d0-e52a9dcff46&title=&width=300)\n好怀念使用 vuex创建写仓库的日子.......\n直到有一天我发现了redux-toolkit ，原来redux还能这样写呀！\n# 什么是redux-toolkit\nredux-toolkit 是官方推荐的编写redux逻辑的方法，简化了redux的配置过程，无需再创建actions、reducer的，更大程度方便使用redux仓库\n# 基本使用\nredux-toolkit的使用步骤，可分为如下5步\n\n- 1、安装 redex-toolkit\n- 2、创建slices \n- 3、创建store \n- 4、将Redux连接到React应用（provide）\n- 5、在React组件中使用（useSelector、useDispath）\n## 环境配置\nvscode\n**React Redux Toolkit RTK Quer**\n安装npm\n```tsx\nnpm i redux react-redux @reactjs/toolkit\n```\n## 创建切片 slices\n一个切片是一个包含 reducer 函数和 action creator 的对象。它定义了一部分状态和与该状态相关的操作。\n```jsx\n// sliceTbale.js\n\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst moviesSlice = createSlice({\n  name: 'movies',\n  // c初始化状态\n  initialState: {\n    currentData:[],// \n    tableData:[]\n  },  \n  reducers: {\n      delete_table: (state, { payload }) => { \n            // 通过筛选实现删除 \n             state.currentTable = state.currentTable.filter((item:{id:any})=>{\n                return item.id !== payload.id\n             }) \n             state.table =  state.currentTable\n             message.success('删除成功') \n        },\n  },\n});\n\nexport const { addMovie } = moviesSlice.actions; // 导出 action creator\nexport default moviesSlice.reducer; // 导出 reducer\n```\n## 创建仓库-store\n我们使用 configureStore 函数来创建 Redux Store，并使用刚刚创建的 reducer 将切片与 Store 关联起来。\n```typescript\n// 创建store仓库\nimport { configureStore } from \"@reduxjs/toolkit\";\nimport  initTable  from \"./module/table\";\n\nconst reduxStore = configureStore({\n    reducer: {\n        // xxx: xxx,\n        table:initTable\n    },\n})\n\nexport default reduxStore\n```\n## redux链接react\n完成以上步骤，redux配置ok啦，如何让整个项目中应用redux呢？\n使用`Provider`包裹 React顶层组件，将 Redux store 对象传递给组件树中的所有组件，使得 Redux 的状态管理能够在整个应用程序中生效。\n打开项目的入口文件 index.tsx，代码如下：\n```tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport RouterConfig from './router/routerConfig';\nimport RouterView from './router/routerView';\nimport \"nprogress/nprogress.css\" // 样式\nimport { Provider } from 'react-redux';\nimport reduxStore from './store';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\nroot.render(\n  <React.StrictMode>\n    <Provider store={reduxStore}> \n      <RouterView config={RouterConfig}></RouterView>\n    </Provider>\n  </React.StrictMode>\n);\n```\n## 组件中使用redux\n使用状态和操作：在组件中，可以使用 useSelector 和 useDispatch 钩子来访问状态和触发 action。\n```tsx\nimport React, { useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\n\ninterface IndexProps {}\n\nconst Index: React.FC<IndexProps> =  (props) => {\n  //  获取redux仓库数据\n  const tableState = useSelector((state:any)=>state.table)\n   // 创建redux 派发器\n  const Dispath = useDispatch()\n  console.log('table仓库数据',tableState)  \n  return (\n    <> \n      {tableState.currentData.length}\n     </>\n  );\n};\n\nexport default Index;\n\n```\n# 进阶使用\n**redux中如何执行异步呢？**\n `createAsyncThunk` 创建异步操作, 通常用于发出异步请求。\n`createAsyncThunk` 创建一个异步action，方法触发的时候会有三种状态：\n\n- pending（进行中）\n- fulfilled（成功）\n- rejected（失败）\n\n```typescript\nexport const getMovieData:any = createAsyncThunk('sliceTable/getMovie', \n  async () => {\n    const res= await getMovieListApi();\n    return res;\n  }\n);\n```\n# 完整示例\n```typescript\nimport { createSlice, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { getMovieListApi } from \"../../API/home\";\n import { message } from \"antd\";\n// // createAsyncThunk 创建异步操作, 通常用于发出异步请求。\n// createAsyncThunk 创建一个异步action，方法触发的时候会有三种状态：\n// pending（进行中）、fulfilled（成功）、rejected（失败）\nexport const getMovieData: any = createAsyncThunk('sliceTable/getMovie',\n    async () => {\n        const res = await getMovieListApi();\n        return res;\n    }\n);\n\nconst sliceName = createSlice({\n    name: \"sliceTable\",\n    initialState: {\n        table: [],\n        currentTable: []\n    },\n    reducers: {\n        initTable: (state, { payload }) => {\n            // console.log('初始化sliceTable数据')\n        },\n        delete_table: (state, { payload }) => { \n            // 通过筛选实现删除 \n             state.currentTable = state.currentTable.filter((item:{id:any})=>{\n                return item.id !== payload.id\n             }) \n             state.table =  state.currentTable\n             message.success('删除成功') \n        },\n        serach_table: (state, { payload }) => { \n            // 通过筛选实现删除 \n            console.log('payload',payload)\n             state.currentTable = state.table.filter((item:{name:string})=>{\n                return item.name.includes(payload)\n             })  \n        },\n        \n    },\n    // 让 slice 处理在别处定义的 actions， // 包括由 createAsyncThunk 或其他slice生成的actions\n    extraReducers: builder => builder\n        .addCase(getMovieData.pending, (state, { payload }) => {\n            // state.loading = true\n            console.log('异步请求 中')\n        })\n        .addCase(getMovieData.fulfilled, (state, { payload }) => {\n            // state.loading = false\n            console.log('拿到异步数据')\n            state.table = payload.data.data.list\n            state.currentTable = payload.data.data.list\n        })\n        .addCase(getMovieData.rejected, (state, { payload }) => {\n            // state.loading = false\n            // state.error = payload\n            console.log('异步操作错误')\n    \n        })\n\n})\n\n\nexport const { initTable,delete_table ,serach_table} = sliceName.actions\nexport default sliceName.reducer\n```\nextraReducers\n// extraReducers 字段让 slice 处理在别处定义的 actions， // 包括由 createAsyncg 或其他slice生成的actions。\n## 使用 connect 函数将 store 内的数据映射到组件 props内\n![](https://cdn.nlark.com/yuque/0/2023/png/1450835/1695112584923-061ddc56-9e07-4c97-baa5-c72c41cc7b6e.png#averageHue=%23282d35&clientId=u31f0e8d7-bb97-4&from=paste&id=uf55f4362&originHeight=912&originWidth=1311&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u1b8a5f38-494d-4fe0-bba4-61c60eb4db7&title=)\n```tsx\nimport React, { PureComponent } from 'react'\nimport { connect } from 'react-redux'\nimport { addNamesAction } from './store/features/names'\nexport class Profile extends PureComponent {\n  addNames(nameValue) {\n    // console.log(nameValue)\n    this.props.addNamesHandler(nameValue)\n  }\n  render() {\n    const { names } = this.props\n    return (\n      <div>\n        <h2>Profile names: {names}</h2>\n        <button onClick={e => this.addNames(', lzumiShinichi')}>addNames</button>\n        <button onClick={e => this.addNames(', 大吉')}>addNames</button>\n        <button onClick={e => this.addNames(', OkabeRintaro')}>addNames</button>\n      </div>\n    )\n  }\n}\nconst mapStateToProps = state => {\n  return {\n    names: state.names.names\n  }\n}\nconst mapDispatchToProps = dispatch => ({\n  addNamesHandler(namesValue) {\n    dispatch(addNamesAction(namesValue))\n  }\n})\nexport default connect(mapStateToProps, mapDispatchToProps)(Profile)\n```\n参考\n[https://www.cnblogs.com/chccee/p/17145403.html](https://www.cnblogs.com/chccee/p/17145403.html)\n[https://juejin.cn/post/7101688098781659172?searchId=20230919111823C8EB8D22FECCCE8115FC#heading-9](https://juejin.cn/post/7101688098781659172?searchId=20230919111823C8EB8D22FECCCE8115FC#heading-9)\n[https://juejin.cn/post/7105000617596157983?searchId=20230919111823C8EB8D22FECCCE8115FC#heading-21](https://juejin.cn/post/7105000617596157983?searchId=20230919111823C8EB8D22FECCCE8115FC#heading-21)\n",
      "properties": {
        "title": "如何提高redux开发效率？当然是redux-tookit啦！",
        "urlname": "sdgpnwvrp82ng4pr",
        "date": "2023-09-19 12:00:35",
        "updated": "2023-10-07 23:22:07"
      },
      "catalog": [
        {
          "title": "react高阶使用",
          "doc_id": "sdgpnwvrp82ng4pr"
        }
      ],
      "body": "",
      "realName": "sdgpnwvrp82ng4pr",
      "relativePath": "\\sdgpnwvrp82ng4pr.md"
    },
    {
      "id": 134613743,
      "doc_id": "xtgxqhiyw52hvk3r",
      "title": "xtgxqhiyw52hvk3r",
      "updated": 1696567460000,
      "body_original": "# 前言\n最近一直在调研图片上传阿里云oss功能，上篇文章主要讲述了阿里云oss大文件分片、断点续传。这篇文章是在原有基础上，前端加了图片剪裁、后端加了本地存储功能。\n\n先看效果\n![图片剪裁上传 -original-original.gif](https://cdn.nlark.com/yuque/0/2023/gif/1450835/1690981814120-bb239300-9abc-40e3-91eb-04a613584b52.gif#averageHue=%23f8f8fd&clientId=u74905274-61e1-4&from=paste&height=727&id=u0d64958a&originHeight=1308&originWidth=2484&originalType=binary&ratio=1.7999999523162842&rotation=0&showTitle=false&size=13671940&status=done&style=none&taskId=u413f0243-67b2-4037-be4d-4e287eb7b13&title=&width=1380.0000365575165)\n技术栈\n\n1. 前端：`react+Ts+antd`\n2. 后端：`node+koa+koa-body+ali-oss`\n\n功能\n\n1. 图片剪裁（`antd剪裁组件`）\n2. 本地文件上传（`antd上传组件+axios`）\n3. 文件存储本地（`node+koa-body`）\n4. 文件存储阿里oss（`node+ali-oss`）\n# 核心代码\n## 环境配置\n### 引入依赖环境\n使用koa搭建node服务，搭配koa周边依赖包开发起来更方便，详细依赖环境如下：\n```php\nconst app = new (require('koa'))(); // koa \nconst router = require('koa-Router')();  // koa 路由\nconst cors = require('@koa/cors') // 运行koa中跨域 \nconst OSS = require('ali-oss') // 阿里云oss-sdk\nconst {koaBody} = require('koa-body'); // 处理请求体中间件、用于解析json、表单 | 包含file内容请求，会生成临时文件,将文件信息添加到ctx.request对象属性，通过ctx.request.files获取\nconst path = require('path'); // 对文件路径的操作\nconst staticServe = require('koa-static') // 使上传的文件能在浏览器中访问\nconst fs = require('fs') // 文件的读写操作 \nconst PORT = '9000' // 端口\n```\n### 配置阿里云oss\n```javascript\nconst client = new OSS({\n    // yourregion填写Bucket所在地域。以华东1（杭州）为例，Region填写为oss-cn-hangzhou。\n    region: 'oss-cn-beijing',\n    // 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。\n    accessKeyId: 'xxx',\n    accessKeySecret: 'xx',\n    // 填写Bucket名称。\n    bucket: 'xxx'\n});\n```\n### 使用中间件\n实现本地上传、解决跨域等功能，需使用koa中间件完成功能\n```php\n// __dirname node中全局变量，当前文件所在目录\n// 上传本地目录\nconst UPLOAD_PATH = path.join(__dirname,'public/')\n// 上传文件后的地址，用于拼接图片名称，回显前端\nconst UPLOAD_URL = `http://localhost:${PORT}`\n//  使用跨域中间件\napp.use(cors())\n\n//应用koabody中间件，处理文件上传操作，生成临时文件路径\napp.use(koaBody({\n    multipart:true ,// 解析文件格式内容\n    formidable:{\n        // 上传文件的存储的位置\n        uploadDir:UPLOAD_PATH,\n        keepExtensions:true // 保留文件的扩展名\n    }\n}))\n// app.use(bodyParser());\napp.use(staticServe(UPLOAD_PATH))\napp.use(router);\n// 启动服务\napp.listen(PORT,()=>{\n    console.log('启动成功 9000')\n});\n\n\n```\n## 阿里云分片上传\n### 接口代码\n```javascript\nrouter.post('/upload_oss',async(ctx)=>{\n    console.log('请求了',ctx.request.files.file)\n    console.log('上传oss upload_oss',ctx.request)\n    const file = ctx.request.files.file\n    let result  = await multipartUpload(file) \n    ctx.body={\n        msg:\"请求成功了\",\n        result\n    }\n})\n```\n### 分片操作\n```javascript\n// 上传进度\nconst progress = (p, _checkpoint) => {\n    // Object的上传进度。\n    console.log('分片进度',p); \n    // 分片上传的断点信息。\n    // console.log(_checkpoint); \n  };\n\nasync function multipartUpload(file) {\n    try {\n      // 依次填写Object完整路径（例如exampledir/exampleobject.txt）和本地文件的完整路径（例如D:\\\\localpath\\\\examplefile.txt）。Object完整路径中不能包含Bucket名称。\n      // 如果本地文件的完整路径中未指定本地路径（例如examplefile.txt），则默认从示例程序所属项目对应本地路径中上传文件。\n      const result = await client.multipartUpload(file.originalFilename, file.filepath, {\n        progress, // 如无需进度实时回显，可不配置\n        // headers,\n        // 指定meta参数，自定义Object的元信息。通过head接口可以获取到Object的meta数据。\n      });\n      console.log(result); \n      return result\n    } catch (e) {\n      // 捕获超时异常。\n       \n      console.log('捕获超时异常。',e);\n    }\n  }\n```\n## 本地文件上传\n###  存储本地文件两种方式\n#### \n一、renameSync（移动临时文件）\n```javascript\nfs.renameSync(ctx.request.files.file.filepath, filePath);\n```\n`优点`：直接使用fs.renameSync，一次操作即可重命名或移动文件，非常简洁和高效。\n`缺点`：fs.renameSync 是一个同步方法，会直接阻塞代码执行，直到文件操作完成\n\n#### 二、创建文件流存储\n```javascript\nconst reader = fs.createReadStream(ctx.request.files.file.filepath);\nconst writer = fs.createWriteStream(filePath);\nreader.pipe(writer);\n```\n\n`优点`：可以同时处理多个文件的上传，不会阻塞代码执行。\n`缺点`：在处理单个文件时可能略微复杂。\n \n#### renameSync 存储单文件\n```javascript\n// 请求中的第二个参数是请求中间件函数，可用于请求前的业务操作 \nrouter.post('/upload_local',async(ctx,next)=>{\n    \n    const filePath = UPLOAD_PATH+`/${ctx.request.files.file.originalFilename}`\n    fs.renameSync(ctx.request.files.file.filepath, filePath);\n    await next()\n},async(ctx)=>{\n    ctx.body={\n        msg:\"请求成功了\", \n        imgUrl:UPLOAD_URL+`/${ctx.request.files.file.originalFilename}` \n    }\n})\n```\n\n# 常见问题\n## multer存储文件名乱码怎么办？\n在第一版代码中，采用的是multer存储文件，上传文件是中文命名，multer中无法解析格式，导致文件名乱码。\n解决方式：将使用 Latin-1 编码的文件名转换为 UTF-8 编码\n示例代码：\n```javascript\n// 文件名称命名\n    filename:function(req,file,cb){\n        console.log('文件名称命名')  \n        const decodedName = Buffer.from(file.originalname, \"latin1\").toString(\n            \"utf8\"\n          );\n        console.log('decodedName',decodedName)\n        cb(null,decodedName)\n    }\n```\n`Buffer.from(file.originalname, \"latin1\")`使用 Buffer.from 方法将以 Latin-1 编码的 file.originalname 字符串转换为一个 Buffer 对象。Latin-1 是一种字符编码，也称为 ISO-8859-1。\n`toString(\"utf8\")`使用 toString 方法将 Buffer 对象转换回字符串，指定目标编码为 UTF-8。这将将 Latin-1 编码的字符串转换为 UTF-8 编码的字符串。\n## Koa接收不到file对象内容\n正常情况下，引入koa-body中间件后，可以获取到前端表单数据，如下：\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1690964658019-3052eed8-4825-445c-87e0-6af5b05359a6.png#averageHue=%23262221&clientId=uc05f2237-7605-4&from=paste&height=198&id=u8c72ae2b&originHeight=357&originWidth=1032&originalType=binary&ratio=2&rotation=0&showTitle=false&size=57940&status=done&style=none&taskId=u5f6d5a7e-e3e9-4338-ab8e-5d99f09c628&title=&width=573.3333485214803)\n**如果获取不到，大概率是 routes 代码书写顺序错乱导致**\n**⚠ 中间件的应用需要写在routes前面才可以**\n正常执行顺序如下：\n```php\nconst koaBody  = require('koa-body')({multipart: true});\napp.use(koaBody); //中间件的应用需要写在routes前面才可以\napp.use(router.routes())\n```\n## koa-body 和 koa-bodypaser不兼容\n在第一版代码中，使用 `koa-bodypaser + multer`来存储本地文件，`koa-body+ali-oss `上传阿里云存储。\n\n这两个功能单独使用是没有问题，但是服务端同时定义两个接口，则会出现阿里云oss或本地存储失败。百度搜了一圈没找到解决方案，最终果断弃坑` multer`， 使用`koa-body` 来解析请求体内容.\n\n`koa-body`不仅可以解析请求体内容、还可以生产文件临时路径、方便存储操作\n\n> - koa-body 用于解析 请求中的 formData 文件内容格式、 json、buffer\n> - koa-bodypaser 用于解析 非文件内容数据，比如json、表单 \n> - 如果node业务中涉及 以上两种情况下，建议使用koa-body。\n\n \n",
      "properties": {
        "title": "React+node 图片剪裁上传，集成本地存储和阿里云OSS",
        "urlname": "xtgxqhiyw52hvk3r",
        "date": "2023-07-28 11:50:14",
        "updated": "2023-10-06 12:44:20"
      },
      "catalog": [
        {
          "title": "案例开发",
          "doc_id": "xtgxqhiyw52hvk3r"
        },
        {
          "title": "本地上传+阿里云oss",
          "doc_id": "xtgxqhiyw52hvk3r"
        }
      ],
      "body": "",
      "realName": "xtgxqhiyw52hvk3r",
      "relativePath": "\\xtgxqhiyw52hvk3r.md"
    },
    {
      "id": 135768675,
      "doc_id": "kxlfse72fgcggs7a",
      "title": "kxlfse72fgcggs7a",
      "updated": 1696729839000,
      "body_original": "![](https://cdn.nlark.com/yuque/0/2023/jpeg/1450835/1696165984294-e26f3ba4-2e42-4021-9ea4-6746a692a83a.jpeg)\n# 专高4第一次记录\n## reactRouter实现页面按钮权限\n路由配置中新增按钮权限\n## 提高redux开发效率\n## webpack4和webpack5的区别\nwebpack5内置了很多plugin插件，比如、打包、压缩、缓存\n### 代码压缩\n#### webpack4\nwebpack4 上需要下载安装 terser-webpack-plugin 插件，并且需要以下配置：\n```tsx\nconst TerserPlugin = require('terser-webpack-plugin')\n\nmodule.exports = { \n  // ...other config\n  optimization: {\n    minimize: !isDev,\n    minimizer: [\n      new TerserPlugin({\n        extractComments: false, \n        terserOptions: { \n          compress: { \n            pure_funcs: ['console.log'] \n          }\n        }\n      }) ]\n  } \n\n```\n#### webpack5\n内部本身就自带 js 压缩功能，他内置了 terser-webpack-plugin 插件，我们不用再下载安装。而且在 mode=“production” 的时候会自动开启 js 压缩功能。\n```tsx\n  // webpack.config.js中\n  module.exports = {\n     optimization: {\n       usedExports: true, //只导出被使用的模块\n       minimize : true // 启动压缩\n     }\n  } \n```\n### 模块联邦\nwebpack5新增模块联邦概念，无需本地下载依赖，让代码直接cdn共享，直接构建项目\n### 打包缓存优化\nwebpack4需要使用cache-loader打包结果来优化之后的打包性能\nwebpack5默认就开启了打包缓存（[官方文档](https://webpack.docschina.org/configuration/cache/)），无需再安装cache-loader\n### 服务启动\n### 文件处理模块\nwebpack 4 加载资源需要用不同的 loader\n\n- webpack4中打包文件，需要安装url-load、file-load\n- webpack5内置asset模块，打包文件无需配置\n### 自定义plugin\nWebpack 插件就像是你的助手，可以按照要求在构建过程中执行各种任务，例如处理文件、优化资源等。\n#### 原理\nwebpack宛如一条生成线，需经过一系列流程后将源文件输出结果，每个流程都是单一的，依次执行流程，多个流程之间有依赖关系，plugin是插入生成线中的功能，在指定时机对生成线的文件做处理。\n#### Webpack 是一座大厦，插件是大厦里的工人。\n用一个简单的比喻来解释插件的工作原理：\n\n1. **大厦的构建过程：** 大厦的建造需要经历多个阶段，从打地基、搭建框架到最终竣工。Webpack 也有类似的构建过程，包括解析模块、编译代码、生成输出文件等。\n2. **大厦里的工人（插件）：** 插件就像大厦里的工人，他们拥有各种技能和工具，可以在不同的施工阶段做出贡献，完成各种任务。\n3. **工人与施工阶段的关联：** 每个工人在施工过程中有自己的职责和任务，依靠他们的技能来完成不同的工作。类似地，Webpack 插件也与构建过程中的不同阶段相对应，每个插件在特定的时机执行自己的任务。\n4. **工人的任务与插件的工作逻辑：** 工人们根据施工计划在特定的时间点完成自己的任务，例如安装管道、涂刷墙壁等。Webpack 插件也有类似的逻辑，它们在特定的构建阶段（如文件解析、代码编译、资源生成）执行自己的功能，例如处理文件、优化代码等。\n5. **工人与整个大厦的关系：** 每个工人负责自己的任务，并相互协作来建造整个大厦。Webpack 插件也与整个构建过程相互协作，通过与其他插件和 Webpack 的集成，共同完成项目的构建工作。\n#### 归纳为以下几个步骤：\n\n1. **安装和配置插件：** 首先，你需要通过 npm 或 yarn 安装所需的插件，并将它们添加到 webpack.config.js 配置文件中的 plugins 数组中。\n2. **初始化插件实例：** 在配置文件中，你需要创建插件的实例对象，并传递任何必要的选项或参数。这将创建插件的一个实例，以便在构建过程中使用。\n3. **定义插件的钩子函数：** 插件会定义一些特定的钩子函数，用于在构建过程的不同阶段执行任务。Webpack 提供了一系列的钩子函数，如 beforeRun、compilation、optimize、emit 等。你需要根据需求选择合适的钩子函数，并在插件实例上实现这些钩子函数。\n4. **编写插件逻辑：** 在钩子函数中，你可以编写插件的逻辑来实现所需的功能。这可以是文件处理、资源优化、代码生成、依赖分析等任何自定义任务。你可以访问构建过程中的各个对象，如编译器（compiler）和编译（compilation），以获取有关构建状态和资源的信息。\n5. **与构建过程交互：** 插件可以通过调用特定的钩子函数，与构建过程的不同阶段进行交互。例如，在 beforeRun 钩子函数中，可以执行一些准备工作；在 compilation 钩子函数中，可以分析编译过程中的模块和依赖；在 emit 钩子函数中，可以进行代码生成和资源输出等操作。\n6. **处理构建结果：** 插件可以根据自己的需求，修改或添加构建结果。例如，可以向输出的文件中插入特定的代码块，对生成的资源进行优化，生成额外的构建报告等。\n### webpack执行流程\n![](https://cdn.nlark.com/yuque/0/2023/jpeg/1450835/1695737597423-6aee6994-33f9-4c88-8c15-3f356c7751cd.jpeg#averageHue=%23fbf5f2&clientId=u48f5c54a-45ef-4&from=paste&id=u8d6aa502&originHeight=1863&originWidth=1225&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u1f1f0f5c-3a06-43c0-a9b3-0aded36aab0&title=)\n## 什么是redux中间件？\n### action和reducer之间的\"中间人\"\n:::info\n一句话总结：redux中间件充当了action和reducer之间的\"中间人\"，拦截和处理应用程序中的action。\n:::\nredux中reducer函数有所限制，比如无法运行异步、日志打印，使用中间件可以兼容此限制。\n\nRedux中间件是Redux应用程序中位于action被发起后、达到reducer之前的一层扩展机制。它允许开发者在action到达reducer之前对其进行拦截、解析和修改。\n\n中间件提供了一种方法，可以在Redux应用程序中添加额外的功能，例如异步操作、日志记录、错误处理等。它们充当了action和reducer之间的\"中间人\"，拦截和处理应用程序中的action。\n\nRedux中的一个常见中间件是redux-thunk，它允许我们在action创建函数中编写异步逻辑。当我们使用redux-thunk时，action创建函数可以返回一个函数而不仅仅是一个普通的action对象。这个函数可以在异步操作完成后再分发真正的action。\n\n中间件的工作原理是通过包装store的dispatch方法来实现的。当我们调用store.dispatch方法来分发一个action时，中间件可以在这个操作被转发给reducer之前拦截这个action，然后执行相应的逻辑。中间件可以选择取消、修改、延迟分发甚至分发多个action。\n\n下面是一个示例中间件的基本结构：\n```javascript\nconst myMiddleware = (store) => (next) => (action) => {\n  // 在这里编写自定义中间件逻辑\n  // 可以通过 store.getState() 获取当前的状态\n  // 可以通过 next(action) 将action传递给下一个中间件或reducer\n\n  // 最后，如果需要，可以返回处理后的action\n  return next(action);\n};\n```\n\n在这个示例中，`myMiddleware` 是一个接受 `store` 参数的函数，它返回一个接受 `next` 参数的函数，最终返回一个接受 `action` 参数的函数。在这个函数中，您可以编写自定义的中间件逻辑，并使用 `next(action)` 来将 action 传递给下一个中间件或 reducer。最后，您可以选择返回处理后的 action。\n\n通过将中间件应用于 Redux 应用程序，我们可以在应用程序的不同阶段插入自定义逻辑，并对 action 进行处理和修改，以满足特定的需求。这使得 Redux 的功能更加灵活和可扩展。\n\nredux中reducer函数有所限制，比如无法运行异步、日志打印，使用中间件可以兼容此限制。\n\n### redux中间件实现原理\n中间件的原理是通过函数组合和闭包的技术【柯里化】\n把接受多个参数的函数转换成接受一个单一参数的函数\n先看一个简单例子\n```\n// 柯里化\n    var foo = function(x) {\n        return function(y) {\n            return x + y\n        }\n    }\n    \n    foo(3)(4)       // 7\n```\n### 常用的异步中间件\n常见的中间件有 **redux-thunk**、**redux-promise**、**redux-saga**，这三个异步中间件。\n#### 同步数据流过程\n![](https://cdn.nlark.com/yuque/0/2023/webp/1450835/1696693597388-635bd91b-8192-46cb-985b-c2bca7bb8ab9.webp#clientId=ucd5a73cd-4a86-4&from=paste&id=u572b8743&originHeight=1080&originWidth=1440&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u6e836e62-e309-4a9f-b5ef-d6d765858f3&title=)\n#### 异步数据流过程\n![](https://cdn.nlark.com/yuque/0/2023/webp/1450835/1696693597102-3bc77b2f-5a9d-4be5-ab87-5f7324bf9ee6.webp#clientId=ucd5a73cd-4a86-4&from=paste&id=u2d25026a&originHeight=1080&originWidth=1440&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=udf56edef-65f3-4ac9-807e-d96523237ce&title=)\n\n## redux为什么是单向数据流\n### 使用单向数据流的原因：\n\n1.  可预测性：单向数据流使应用的状态变化可预测。数据只能通过派发 actions 来修改，reducers 对状态进行处理，确保变化是可控的。 \n2.  可维护性：单向数据流简化了状态管理的逻辑。通过明确的数据流路径，更容易理解和调试应用的状态变化。 \n3.  可追溯性：单向数据流使状态的变化可追溯，每个状态变化都可以通过 actions 和 reducers 进行跟踪和记录。 \n\n 原理\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1695871612688-5c16403d-8f2d-4faa-9a9b-7119ae4ffccf.png#averageHue=%23f5f5f5&clientId=u8f6cba51-4819-4&from=paste&height=283&id=tiqrr&originHeight=566&originWidth=1759&originalType=binary&ratio=2&rotation=0&showTitle=false&size=250025&status=done&style=none&taskId=u8073fb2d-578d-4d1e-bed1-a759275218e&title=&width=879.5)\n### 实现单向数据流的方式：\n\n1.  定义一个唯一的状态树：Redux 使用一个单一的 JavaScript 对象来存储应用的整个状态，这个对象被称为状态树或状态存储。 \n2.  组件派发 actions：组件通过派发 actions 来表示对状态的意图。actions 是一个包含 `type` 字段和可选的 `payload` 字段的普通 JavaScript 对象。 \n3.  reducers 处理状态变化：reducers 定义了如何根据当前的状态和 actions 来计算新的状态。reducers 是纯函数，接收旧状态和 action，返回一个新的状态对象。 \n4.  订阅状态变化：应用中的部分组件可以订阅状态的变化，以便在状态发生变化时重新渲染并响应变化的结果。 \n\n通过这种方式，Redux 实现了单向数据流。组件通过派发 actions 触发状态变化，reducers 处理状态变化并返回新的状态，订阅了状态变化的组件会接收到新的状态并进行相应的更新。**这种单向数据流的方式确保了状态的可控性、可预测性和可追溯性，提高了应用的可维护性和可测试性。**\n## reactRouter实现页面按钮权限\n咱们先看效果，切换用户登录后，操作权限除了左侧菜单，还有页面按钮。\n![按钮权限演示效果.gif](https://cdn.nlark.com/yuque/0/2023/gif/1450835/1695870713594-a9fa493f-e747-43c5-9e1c-d210866c8373.gif#averageHue=%23f5f6fe&clientId=u99d81f03-4fcc-4&from=paste&height=734&id=PO3Vj&originHeight=1468&originWidth=2802&originalType=binary&ratio=2&rotation=0&showTitle=false&size=9278845&status=done&style=none&taskId=uc9077042-3a60-48db-940f-8f25b23923f&title=&width=1401)\n实现思路\n按钮控制本质是条件判断，满足条件显示按钮，否则禁用/消失\n重点是页面权限的数据获取，这需要和后端沟通好—从权限获取-校验的流程。\n:::info\n思路：\n按钮权限的显示，通过简单的条件判断就能实现。\n通常情况下，我们为用户添加权限时，除了页面，还会细化到按钮级别，比如、新增、删除、查看等权限。\n每个页面的按钮权限都不同，如何实现呢？\n\n- 在路由配置中添加页面权限参数\n- 通过路由实例，获取当前页的权限\n- 封装按钮权限组件，动态显隐按钮\n:::\n此方案，在vue中实现比较方便，vueRouter配置路由元信息、添加权限校验的参数，在页面路由实例中读取meta数据，进行页面级别的按钮权限控制。\n但是，在react-Router6版本中没有路由元信息配置，就算自定义路由属性，也无法获取，如下是踩坑代码，大家看看就行，可不要尝试了\n踩坑代码-添加路由自定义属性，获取权限数据首先，在路由配置中设置自定义属性，例如 title 和 requiresAuth：\n```tsx\n<Route\n  path=\"/dashboard\"\n  element={<Dashboard />}\n  title=\"Dashboard\"\n  requiresAuth={true}\n  />\n```\n然后，在 Dashboard 组件中可以通过 useRoutes() 钩子获取路由传递的属性，如下所示：\n```tsx\nimport { useRoutes, useParams, useNavigate } from 'react-router-dom';\n\nfunction Dashboard() {\n  const params = useParams();\n  const navigate = useNavigate();\n\n  // 访问路由传递的属性\n  const { title, requiresAuth } = useRoutes().pathname;\n\n  // 在这里使用元信息进行逻辑处理\n\n  return (\n    <div>\n      <h1>{title}</h1>\n      {/* 组件的其余部分 */}\n    </div>\n  );\n}\n```\n结果不用说了，报错啊啊啊啊啊啊啊\n在react-route6中 无法自定义路由属性，报错日志如下\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1695816639053-45ffb668-67ea-40fc-98af-5078087dbd5a.png#averageHue=%232b2424&clientId=ucb56c198-d407-4&from=paste&height=164&id=u59376759&originHeight=327&originWidth=1501&originalType=binary&ratio=2&rotation=0&showTitle=false&size=60639&status=done&style=none&taskId=ue56d9735-b628-462c-9a0f-26783b8332e&title=&width=750.5)\n在react-Router中如何实现呢？\n将按钮权限和页面路由一同返回，数据结构如下：\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1695866884450-5eb5ecf2-7a09-4353-9cd7-99b1195a295f.png#averageHue=%23232020&clientId=ucb56c198-d407-4&from=paste&height=420&id=ube308f09&originHeight=840&originWidth=866&originalType=binary&ratio=2&rotation=0&showTitle=false&size=91080&status=done&style=none&taskId=u03376b89-f14c-4434-801a-dfb4db63e70&title=&width=433)\n既然无法通过路由实例获取权限数据，那么我们手动创建一个对象，来存储路由和按钮权限映射关系，在用户登录后，执行如下代码\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1695857607911-4a256bcc-be5d-4ad6-8879-67531923cfc0.png#averageHue=%23241f1e&clientId=ucb56c198-d407-4&from=paste&height=428&id=u36e50943&originHeight=856&originWidth=1362&originalType=binary&ratio=2&rotation=0&showTitle=false&size=127733&status=done&style=none&taskId=ube783756-d6bb-47e7-8629-b33004f0cd9&title=&width=681)\n封装按钮权限组件，读取本地权限数据、控制按钮的显隐、禁用状态，代码如下：\n```tsx\nimport { Tooltip } from 'antd';\nimport React from 'react';\nimport { useLocation } from 'react-router-dom';\n\ninterface IndexProps {\n  scopeTtype:string, // 权限码\n  children:any// 子组件\n}\n\nconst Index: React.FC<IndexProps> = (props) => {\n  // 获取当前页面的位置信息、\n  const routeDom = useLocation(); \n  // 从本地缓存读取 页面路径和权限数据\n  const strPersstion = localStorage.getItem('pagePersstion');\n  const pagePersstion = JSON.parse(strPersstion as string); \n  // 找到当前页的按钮权限数据\n  const currentPerssion = pagePersstion.find((item: { page: string; })=>item.page == routeDom.pathname);\n  console.log('当前页面的按钮权限',currentPerssion);\n  //  有权限返回按钮\n  if(currentPerssion.permissions[props.scopeTtype]){\n    return  props.children;\n  }else{ \n    // 没有则禁用、或者隐藏按钮\n    // 要实现按钮禁用，需要设置组件的disabled \n    // 可是react 中的props是只读无法修改，如何修改props中子组件呢？\n    // 通过React API React.cloneElement 克隆出新的元素进行修改如下\n    const Button = React.cloneElement(props.children, {\n      disabled: true\n    });\n\n    return   <>\n      <Tooltip title=\"暂无权限\">  {Button}</Tooltip>\n    </>;\n  };\n};\n\n\nexport default Index;\n```\n使用按钮权限组件\n```tsx\n<AuthButton scopeTtype=\"isDelete\">\n  <Button type=\"primary\" onClick={start} disabled={!hasSelected} loading={loading}>\n    批量删除\n  </Button>\n</AuthButton>\n<AuthButton scopeTtype=\"isAdd\">\n    <Button onClick={showModal}>新增员工</Button>\n</AuthButton>\n```\n模拟的路由数据：员工管理页面的路由、按钮配置\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1695866906840-8af28a37-170e-43c1-ab74-b0f3e1c2ee19.png#averageHue=%23232020&clientId=ucb56c198-d407-4&from=paste&height=420&id=u32376b11&originHeight=840&originWidth=866&originalType=binary&ratio=2&rotation=0&showTitle=false&size=91080&status=done&style=none&taskId=u2b3f7d20-558b-4acf-b2a5-55d284b2e09&title=&width=433)\n页面效果如下：\n\n[React组件实现权限按钮显示和隐藏-阿里云开发者社区](https://developer.aliyun.com/article/795383)\n[react项目之菜单，按钮权限的实现方案_react 按钮权限-CSDN博客](https://blog.csdn.net/liusuyun_1/article/details/123956581)\n[React、Vue 后台管理系统权限控制示例（React高阶组件，Vue指令，插槽） - 灰信网（软件开发博客聚合）](https://www.freesion.com/article/4568591692/)\n# 第二答辩记录\n\n- 环境配置模块讲解 - 正确\n- redux-toolkit 异步写法、使用 -正确\n- 封装裂图组件- 正确\n- redux-toolkit 继承了那些插件 -部分正确\n- 拓展问题 redux-toolkit rtkQuery 简洁写法- 错误\n- vscode 自动格式化配置 - 部分正确\n\n# 第二次预答辩\n\n- redux中间件应用，redux 异步解决\n- 大文件上传-视频分片\n- git 特殊命令 -回退-冻结远端\n- 项目中需添加.env文件、定义环境变量，区分环境\n- vite 环境变量用法 \n# 功能模块\n## 1.typescript 项目基础建设\n\n1. 总结TypeScript的好处\n2. TypeScript的核心知识\t\n- 项目权限系统开发\n1. 出现用户访问无权限时怎么优化用户体验？ 答：lesson7产出403页面配置\n2. 切换不同用户 权限改变出现的问题？ 答：lesson7完善整体用户登陆流程\n3. 怎么样可以更好的配置用户权限（提薪） 答：lesson8 可视化权限操作，tree结构的应用\n4. 如何根据不同权限显示隐藏左侧菜单项（提薪） 答：lesson7 动态路由，配合menu渲染 side\n5. 怎么优化首页加载速度，切换不同权限之后路由懒加载（提薪） 答：lesson7\n- redux相关插件封装\n- readux中间件\n## 1.rbac权限管理 && 表格\n\n1. 不同权限用户登录，展示对应的菜单\n## 2.文件上传、OSS云存储\n\n1. 不同浏览器导出是否一致 答：lesson14根据浏览器判断不同浏览器行为\n2. 选择数据为空时，是否可以导出 答：做前端表单校验\n3. 数据量较多时的分页检查\n4. 大容量数据导出的时间，和对其他功能是否影响 答：使用异步操作进行打包\n5. 批量导出/批量导入的实现 答： lesson12 大文件上传和断点续传\n6. 怎么防止文件下载下来之后被盗用(提薪) 答： lesson13 refer配置\n## 支付宝充值\n支付宝沙箱账号\n买家账号odcjxi3359@sandbox.com\n登录密码111111\n\n- 项目用户信息 & 考勤 等视图模块开发\n1. 如果出现tooltip用于详情展示内容部分超出怎么办？ 答：lesson17判断浏览器视口大小，动态判断方向\n2. 如果出现主题颜色更换怎么办？答：css var的使用\n3. 如何兼容国外用户？答：i18n配置\n4. 怎么解决多个项目使用一个公共组件? (提薪) 答：lesson18 storybook组件库预览搭建\n# 环境复杂度\n## 0. oss上传如何限制文件类型？\n对象存储OSS本身并不限制上传的文件类型、大小。如果有相关需求的话，需要自行在业务层面实现。\n1、前端在上传时进行拦截，常用于上传组件配置【省心方便】\n```jsx\n<input as></input>\n```\n2、后端处理，判断file数据的文件类型\n## 1 .多文件传的实现方案？\n```tsx\nconst uploadFile = (file) => {\n  return new Promise((resolve, reject) => {\n    // 模拟上传过程，这里可以使用你的oss上传逻辑\n    setTimeout(() => {\n      resolve(`Uploaded file: ${file}`);\n    }, Math.random() * 3000);\n  });\n};\n\nconst files = [file1, file2, file3]; // 假设这是要上传的文件数组\n\nconst uploadPromises = files.map((file) => uploadFile(file));\n\nPromise.all(uploadPromises)\n  .then((results) => {\n    console.log('All files are uploaded:', results);\n  })\n  .catch((error) => {\n    console.error('Error occurred during upload:', error);\n  });\n\n```\n\n## 2. Promise.all和Promise.race的区别？\n### 场景\n\n- Promise.all() 适用于当我们需要等待多个异步操作全部完成，然后再进行下一步操作的场景。例如，我们需要从多个 API 请求中获取数据，然后将这些数据合并成一个结果。在这种情况下，我们可以使用 Promise.all() 来等待所有的请求都完成，然后将结果合并起来。\n\n- Promise.race() 适用于当我们需要等待多个异步操作中的其中一个完成，然后再进行下一步操作的场景。例如，我们需要从多个 API 请求中获取数据，但只需要获取其中一个请求的结果即可。在这种情况下，我们可以使用 Promise.race() 来等待其中一个请求完成，然后处理其结果。\n### 返回值\n\n- Promise.all() 返回一个新的 Promise 对象，如果所有的 Promise 对象都成功解决，则返回一个解决值数组，数组中的解决值按照 Promise 对象数组中的顺序排列。如果有一个 Promise 对象被拒绝，则返回一个拒绝原因。\n- Promise.race() 返回一个新的 Promise 对象，其解决值或拒绝原因与第一个解决或拒绝的 Promise 对象相同。\n## 3. useState使用：\n### usestate传值 vs 传函数\n当使用useState时，传入一个函数作为初始状态值的参数和传入一个值的参数的效果是一样的，都会在组件渲染时被调用，但它们的使用场景略有不同。\n\n- 传入一个值：useState(initialValue)会将initialValue作为初始状态值，适用于不需要进行复杂计算的情况。只在组件首次渲染时生效，后续重新渲染时会跳过该初始值的计算。\n```tsx\nfunction useState(initialValue) {\n  let state = initialValue; // 组件的内部状态\n  const setState = (newValue) => {\n    state = newValue; // 更新状态值\n    // 触发组件重新渲染\n    // 这里可以通过某种机制通知 React 重新渲染组件\n  };\n  return [state, setState]; // 返回状态值和更新状态的函数\n}\n\n```\n\n- 传入一个函数：useState(() => initialValue)的函数会在组件首次渲染时都被调用，返回值将被用作初始状态值。这种方式适用于需要根据组件的当前状态计算初始值的场景。\n### setState 传值 vs 传函数\n当使用 setState 更新组件状态时，可以选择传递一个新的值或者传递一个函数。\n无论是传递新值还是传递函数，setState都会触发组件重新渲染。重新渲染会更新组件的显示。\n\n1. 传递一个新值：直接将新值赋给状态。适用于简单的状态更新，不需要基于之前的状态进行计算。\n2. 传递一个函数：将之前的状态作为参数传递给函数，该函数进行计算并返回一个新的状态值。适用于需要基于之前的状态进行复杂计算或逻辑操作的情况。\n#### 示例代码\n1、传入一个值，在add函数内，执行三次setNum后，预期num应是 3，但是执行后仍然是1,\n```tsx\nlet [num, setNum] = useState(0)\n\nconst add()=>{\n\tsetNum(num + 1);\n  setNum(num + 1);\n  setNum(num + 1);\n  console.log(num) // 3\n}\n\n```\n`num`状态在当前函数组件生命周期内，永远是0，无论调用多少次 setState 设置新值也没有。\n因为react 内部 执行`批量更新`的优化策略，可以简单理解为，num变量在函数内重新声明。\n```tsx\nlet [num, setNum] = useState(0)\n\nconst add()=>{\n  let = num = 0\n\tsetNum(num + 1);\n  setNum(num + 1);\n  setNum(num + 1);\n  console.log(num) // 1\n}\n\n```\n对同一次渲染来说 num 是一个固定的值。在多次执行`setState`情况下React 会并并批量处理，以提高性能。也就是说，不会立即进行多次重新渲染，而是在所有更新应用后进行一次重新渲染。\n\n2、传入一个函数，setNum中使用函数作为参数\n```tsx\nlet [num, setNum] = useState(0)\n\nconst add()=>{\n   \tsetNum((num)=>num + 1);\n    setNum((num)=>num + 1);\n    setNum((num)=>num + 1); \n  console.log(num) // 3\n}\n\n```\n通过传递函数的方式，可以获得最新的之前状态，并避免并发更新导致的问题。这种方式允许确保在处理并发更新时的正确性。\n## 4. useState和useReducer的区别：\n一句话总结：\nuseState用于简单的状态管理和局部状态更新，而useReducer用于复杂的状态逻辑和全局状态管理。\n\n- useState和useReducer是React中的两个不同的状态管理钩子。\n\n下面是它们的区别以及代码示例：\n\n1. useState: \n   - useState是React提供的基本状态管理钩子。\n   - 它通过返回一个包含状态值和更新状态值的数组来处理单个状态。\n   - useState是基于当前状态的值进行更新的。\n   - 主要用于简单的状态管理和局部状态更新。\n\n代码示例：\n```jsx\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n```\n\n2. useReducer: \n   - useReducer是React提供的更高级的状态管理钩子。\n   - 它接受一个reducer函数和初始状态作为参数，并返回当前状态和一个dispatch函数来触发状态更新。\n   - useReducer通过传入的reducer函数来更新状态，该函数接受当前状态和action作为参数，并返回新的状态。\n   - 主要用于管理复杂的状态逻辑和全局状态管理。\n\n代码示例：\n```jsx\nimport React, { useReducer } from 'react';\n\nconst initialState = {\n  count: 0,\n};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return { count: state.count + 1 };\n    case 'decrement':\n      return { count: state.count - 1 };\n    default:\n      throw new Error('Unknown action type');\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const increment = () => {\n    dispatch({ type: 'increment' });\n  };\n\n  const decrement = () => {\n    dispatch({ type: 'decrement' });\n  };\n\n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n    </div>\n  );\n}\n```\n\n在上述示例中，useState被用于简单的计数器，而useReducer被用于更复杂的计数器，可以增加和减少计数。\n## 5. 大文件上传的进度如何实现的\n1、`轮询` 定义接口，前端轮询查询进度\n2、`socket` 通过socket长连接，将文件上传进度实时返回给客户端\n## 6. 大文件上传切片处理逻辑：\n\n- 将上传的大文件根据指定的切片大小（一般为固定值）分割成多个小块（切片）。\n- 逐个上传每个切片，可以\t采用并发上传或顺序上传的方式。上传时可以使用标识符标记切片的顺序和所属文件，以便后续在服务端进行组装。\n- 后端接收到每个切片后，进行验证和存储。验证切片的顺序和完整性，存储切片的内容。\n- 当所有切片上传完成后，后端根据标识符将切片进行组装还原成原始文件。\n## 7. 大文件上传实现方式：\n以下是一些常见的实现方式：\n\n- 分片上传：将大文件分割为多个小块（切片），逐个上传，并在服务端进行组装。\n- 断点续传：记录已上传的文件切片，当上传中断时可以从上次中断的地方继续上传，避免重新上传整个文件。\n- 并行上传：同时开启多个上传任务，将文件切片并发上传，提升上传速度。\n- 流式上传：将文件按流式方式上传，不需要等待整个文件加载完成\n## 8. 登录按钮使用防抖，暴力点击按钮\n当登录的时候，使用防抖，如果一直点击，登录的接口是否能发出去？？\n最后一次点击时会发出。\n\n使用防抖函数来处理登录按钮的点击事件，可以确保在短时间内多次点击只有最后一次生效。如果一直点击登录按钮，在防抖函数设定的延迟时间内，只有最后一次点击会触发登录接口的请求，前面的点击事件将被忽略。\n\n因此，只有最后一次点击的登录接口能够发出去，前面的点击事件不会触发登录接口请求。\n\n## 9. 防抖和节流的区别：\n### 防抖（Debounce-规定时间结束后执行）\n：当事件连续触发时，只有在固定的延迟时间（如300ms）内没有再次触发事件，才会执行事件处理函数。如果在延迟时间内再次触发事件，则重新开始计时。\n### 节流（Throttle-规定时间内执行一次）：\n当事件连续触发时，在固定的时间间隔（如300ms）内，只会执行一次事件处理函数。即使在时间间隔内多次触发事件，也只会执行一次，而不会重复执行。\n### 总结\n\n- 防抖：防止抖动，**单位时间内事件触发会被重置，避免事件被误伤触发多次**。代码实现重在清零 clearTimeout\n- 节流：控制流量，**单位时间内事件只能触发一次**。代码实现重在开锁关锁 timer=timeout; timer=null\n```typescript\nexport class Lodash {\n    // 存储防抖节流的函数，用于检测清除\n    private debounceTimeout: NodeJS.Timeout | null\n    private throttleTimeout: NodeJS.Timeout | null\n    private runTime:number\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor() {\n        this.debounceTimeout = null\n        this.throttleTimeout = null\n        this.runTime = 0\n    }\n\n    // 防抖-可以被覆盖，简单点说，在单位时间内，永远执行最后一次防抖函数\n    public debounce(fc: (...args: any[]) => void, delay: number = 1000) {\n        if (this.debounceTimeout) clearTimeout(this.debounceTimeout)\n        return (...args:any[]) => {\n            this.debounceTimeout = setTimeout(() => {\n                fc(...args)\n            }, delay)\n        }\n    }\n\n    // 节流函数-单位时间结束后内只执行一次，\n    \n    // 延迟节流 — 单位时间结束后执行，\n    // 立即执行 -立刻执行节流函数， 需等时间结束，方可执行下一次\n    public throttleAweit(fc:(...args:any[])=>void,delay:number = 1000){\n    \n        // 立即执行的节流函数\n\n        // 1、当前时间 需要大于上次节流执行的事件，方可执行\n\n        // 当前时间\n        const nowTime = new Date().getTime() \n        return (...args:any[])=>{\n            if(nowTime - this.runTime > delay){\n                fc(...args)\n                this.runTime = new Date().getTime()\n            } \n        }\n    }\n\n    public throttleAsync(fc:(...args:any[])=>void,delay:number = 1000){\n       \n\n        // 延迟节流\n        if(this.throttleTimeout){\n            return ()=>{}\n        }\n        return (...args:any[])=>{\n            this.throttleTimeout = setTimeout(()=>{\n                fc(...args)\n                this.throttleTimeout = null\n            },delay)\n        }\n\n         \n    }\n\n    \n}\n\n\n```\n## 10. 路由守卫如何处理的\n\n在 React Router 中，可以通过定义路由组件的渲染逻辑来实现路由守卫。具体而言，可以使用 `Route`组件的 render 或 component 属性提供一个回调函数或组件，根据需要执行特定的操作。\n以下是一个示例，展示了如何使用 React Router 实现简单的路由守卫：\n```typescript\nimport { BrowserRouter as Router, Route, Redirect } from 'react-router-dom';\n\n// 路由守卫组件\nconst PrivateRoute = ({ component: Component, isAuthenticated, ...rest }) => (\n  <Route\n    {...rest}\n    render={(props) =>\n      isAuthenticated ? ( // 如果已经认证通过\n        <Component {...props} />\n      ) : ( // 如果未认证通过\n        <Redirect to=\"/login\" /> // 重定向到登录页面\n      )\n    }\n  />\n);\n\n// 应用程序\nconst App = () => {\n  const isAuthenticated = checkAuthentication(); // 检查是否已经认证通过，返回布尔值\n\n  return (\n    <Router>\n      // 其他路由配置\n      <PrivateRoute\n        path=\"/protected\"\n        component={ProtectedPage}\n        isAuthenticated={isAuthenticated}\n      />\n      // 其他路由配置\n    </Router>\n  );\n};\n\n```\n## 11. token如何处理\nToken 是一种用于身份验证和授权的令牌。在前端开发中，通常将 Token 存储在客户端（如浏览器的本地存储或 Cookie）中，并在每次请求时将其发送到服务器。\n在处理 Token 的流程中，可以采取以下步骤：\n\n- 登录：用户提供用户名和密码，发送给服务器进行验证。如果验证通过，服务器会颁发一个 Token 并返回给客户端。\n- 存储 Token：客户端将 Token 存储在本地，通常是使用浏览器的本地存储机制（如 localStorage）或 Cookie。\n- 发送 Token：在每次请求中，客户端会将 Token 添加到请求的头部（如 Authorization 头部）中，并发送给服务器。\n- 验证 Token：服务器接收到请求后，会验证 Token 的有效性和合法性。服务器可以使用密钥或秘钥来解析和验证 Token 的签名，并判断是否可以信任该 Token。\n- 授权访问：如果服务器验证通过，表示请求是合法的，并且可以根据 Token 中的信息授权用户访问相应的资源。\n- Token 刷新：在一些情况下，Token 会有一定的有效期限制。当 Token 过期时，可以通过一个专门的刷新接口来获取新的 Token。客户端在请求返回后更新存储的 Token。\n## 12. 重复支付功能如何处理\n\n重复支付是指用户重复提交支付请求导致多次支付的情况。为了处理重复支付，可以采取以下策略之一：\n\n- 后端幂等性校验：后端在接收到支付请求时，可以通过唯一标识（如订单号）来判断该支付请求是否已经处理过。如果已经处理过，则直接返回之前的支付结果，防止重复支付。\n- 前端防重复提交：前端可以在用户点击支付按钮后，禁用该按钮，并在支付请求发送成功后才解除禁用。这样可以防止用户多次点击支付按钮导致的重复支付。\n- 支付平台回调校验：在某些支付平台中，支付结果会通过回调通知给后端。后端可以在接收到支付结果回调时，再次校验支付结果的唯一标识，并确保该支付结果只被处理一次。\n## 13. 如何防止文件被盗取\n\n- 访问权限控制：确保文件存储在可信任的位置，并设置适当的访问控制权限。例如，在服务器上存储文件时，通过配置文件系统的权限，只允许授权用户或特定角色访问文件。\n- 文件加密：对敏感的文件内容进行加密，确保只有经过授权的用户能够解密和使用文件内容。可以使用对称加密或非对称加密等加密算法来实现文件的加密和解密。\n- HTTPS 使用：在通过网络传输文件时，使用 HTTPS 协议（即使用 SSL/TLS 加密）来加密传输的数据，确保数据在传输过程中不易被窃听和篡改。\n- 防止直接访问：直接向公众暴露文件的 URL 地址可能会导致文件被盗取。可以通过服务端代理或生成临时链接的方式，限制非授权用户直接访问文件。\n## 14. 如何防止重复支付\n## 15. 如何优化首屏加载速度\n优化首屏加载速度可以提升用户体验和减少用户的等待时间。以下是一些优化技术和策略：\n\n- 代码拆分（Code Splitting）: 将应用程序的代码拆分成多个较小的包，只在需要时才加载。这样可以缩短首次加载所需的时间，避免一次性加载过多的代码。\n- 图片懒加载（Lazy Loading）: 对于页面上的图片，延迟加载它们直到它们即将进入用户的视野范围。这样可以减少页面的初始加载时间。\n- 资源压缩和缓存：对于 CSS、JavaScript 和其他静态资源，使用压缩技术（如文件压缩、代码压缩）减小文件大小，并设置适当的缓存策略，以便浏览器可以缓存这些资源，减少重复的请求和下载时间。\n- 使用 CDN 加速：将静态资源存储在 CDN（内容分发网络）上，以减少资源的访问延迟和下载时间。\n- 接近用户地理位置的服务器：将应用程序的服务器部署在靠近用户地理位置的位置上，以减少网络\n## 16. 如何自定义hooks\n使用自定义 Hooks，可以将一些通用的逻辑封装起来，并在不同的组件中共享和重用。要创建一个自定义 Hook，只需按照以下约定编写一个普通的 JavaScript 函数：\n\n- 函数名以 \"use\" 开头，以表示这是一个自定义 Hook。\n- 在函数内部，可以使用 React 的 Hooks 或其他自定义 Hook。\n- 函数可以返回任何值，但通常返回一个包含状态和行为的对象，以供组件使用。\n\n### 注意事项\n在使用 React Hooks 时，有一些注意事项需要考虑：\n\n1. 只在函数组件或自定义 Hooks 中使用 Hooks：React Hooks 只能在函数组件或自定义 Hooks 中使用，不能在普通的 JavaScript 函数中使用。确保在正确的地方使用 Hooks，以避免引发错误。\n2. 在组件的顶层使用 Hooks：确保在组件的顶层使用 Hooks，不要在循环、条件语句或嵌套函数中使用 Hooks。这是因为 React 需要在每次渲染时保持 Hooks 调用的顺序和数量的一致性。\n3. Hooks 的调用顺序必须保持一致：在使用多个 Hooks 时，确保每次渲染中 Hooks 的调用顺序保持一致。这是因为 React 通过 Hooks 的调用顺序来确定每个 Hooks 对应的状态和引用。\n4. 不要在循环、条件语句或嵌套函数中使用 Hooks：确保在函数组件的最顶层使用 Hooks，不要将 Hooks 放在循环、条件语句或嵌套函数中。这是因为 React 需要依靠 Hooks 的调用顺序来确定每个 Hooks 对应的状态和引用。\n5. 使用 ESLint 插件来检查 Hooks 规则：可以使用 eslint-plugin-react-hooks 插件来检查 Hooks 的使用规则，并提供一些静态规则来帮助遵守最佳实践。这样可以帮助检查和纠正 Hooks 使用中常见的错误。\n6. 注意闭包陷阱：在使用 Hooks 时，需要注意闭包陷阱（Closure Trap）的问题。如果在副作用函数内部使用了 Hooks，确保正确地处理对外部变量的依赖和更新。否则，可能会导致意外的行为和数据不一致。\n7. 惰性初始化状态：使用 useState Hook 时，可以通过传入一个函数作为初始状态，来实现惰性初始化状态。这样可以避免在每次渲染时都重新计算初始状态。\n8. 使用 useCallback 和 useMemo 进行性能优化：如果有需要，可以使用 useCallback 和 useMemo Hooks 来优化函数组件的性能。这两个 Hooks 可以用于缓存函数和计算结果，以避免不必要的重复计算。\n## 17. 什么情况下需要使用自定义hooks\n## 18. 为什么出现react hooks?解决了哪些问题\n\nReact Hooks 是 React 16.8 版本中引入的新特性，用于解决在组件之间共享状态逻辑的问题。以前，为了在函数组件中使用状态和其他 React 特性，需要使用类组件。使用类组件会引入一些复杂性和样板代码，特别是在处理复杂的逻辑和共享状态时\n\n它们解决了以下几个问题：\n\n- 在函数组件中使用状态：使用 useState Hook，可以在函数组件中使用状态，并且可以通过调用 setState 函数来更新状态。\n- 使用副作用和生命周期方法：使用 useEffect Hook，可以在函数组件中执行副作用操作（如数据获取、订阅、操作 DOM），以及模拟类组件中的生命周期方法。\n- 在不同组件之间共享逻辑：通过自定义 Hook，可以将逻辑封装成一个可复用的 Hook，供多个组件使用，实现逻辑的共享和抽象。\n- 处理组件之间的连接：使用 useContext、useReducer、useRef 等 Hooks，可以在组件之间建立连接，共享状态、传递引用和执行其他操作。\n\n## 19. 为什么使用redux?\n\n使用 Redux 的一些优点：\n\n- 集中的状态管理：Redux 将整个应用程序的状态存储在一个统一的存储库（称为 Store）中。这使得状态管理变得简单，可以一目了然地查看和跟踪状态的变化，而不需要在组件树中传递状态。\n- 可预测性的状态更新：Redux 使用纯函数来处理状态的更新，这些函数被称为 Reducer。通过使用 Reducer，可以根据当前的状态和动作以一致的方式更新状态，从而可预测地管理状态。\n- 方便的状态共享：Redux 允许在应用程序的不同组件之间共享状态，而不需要通过组件间的层层传递来实现。任何组件都可以订阅状态的变化，以获取最新的状态更新。\n- 方便的状态调试和记录：由于 Redux 的状态变化是通过 Reducer 函数进行的，因此可以轻松地记录和调试状态的变化。这对于解决应用程序中复杂的状态问题非常有帮助。\n- 生态系统的丰富性：Redux 有一个非常丰富的生态系统，提供了许多与其配套的库和工具，如 React-Redux、Redux Thunk、Redux Saga 等。这些工具可以帮助开发者更好地使用和管理 Redux，并提供额外的功能和扩展\n\n## 20. 为什么使用token?不使用cookie和session\n\n用 Token 来进行身份验证和会话管理有以下几个优点：\n\n- 无状态性：Token 是无状态的，不依赖于服务器的会话存储。服务器不需要维护会话状态，减轻了服务器的负担。这对于构建可水平扩展的系统和无状态的 API 非常有用。\n- 跨域支持：由于 Token 是通过 HTTP 请求的标头（通常是 Authorization 标头）进行传递的，因此可以方便地在跨域环境中进行身份验证。而传统的 Cookie 和 Session 是基于域的，需要配置跨域策略。\n- 安全性：使用 Token 实现身份验证时，可以通过使用加密算法和密钥对 Token 进行签名和验证，以确保 Token 的安全性。这样可以防止 Token 被篡改或伪造。\n- 可扩展性：由于 Token 是独立于应用程序的，可以轻松地将身份验证功能与其他系统集成，例如单点登录（SSO）或第三方身份验证提供商。\n\n尽管 Token 有这些优点，但在某些情况下，Cookie 和 Session 仍然是合适的选择，例如需要存储敏感信息，需要支持旧版浏览器或需要与现有的基于 Cookie 的身份验证系统集成。\n最终，选择使用 Token、Cookie 还是 Session 取决于具体的需求和场景。在许多现代的 Web 应用程序中，Token 已成为首选的身份验证机制，以提供更灵活、安全和可扩展的解决方案\n## 21. 为什么需要封装axios呢\n\n- 代码复用：通过封装 Axios，可以将网络请求的逻辑封装成一个可复用的函数或模块，并在应用程序的不同部分共享。这样可以避免重复编写相同的网络请求代码。\n- 统一的错误处理：封装 Axios 可以在请求发生错误时统一处理错误。可以定义一些错误处理逻辑，例如统一的错误提示、重试机制或跳转到错误页面。\n- 请求拦截和响应处理：通过封装 Axios，可以在请求发送之前进行拦截和处理，例如添加请求头、身份验证或请求参数的转换。同样，可以在收到响应后进行处理，例如解析响应数据、根据状态码进行特定操作等。\n- 可配置性：封装 Axios 可以提供一些配置选项，例如默认请求配置、超时设置、代理设置等。这样可以根据应用程序的需求进行定制，并统一管理。\n- 模块化和抽象化：通过封装 Axios，可以将网络请求抽象成一个模块，使其独立于应用程序的其他部分。这样可以提高代码的可维护性和可测试性。\n## 22. 文件上传的逻辑是什么\n\n文件上传的逻辑可以分为以下几个步骤：\n\n1. 创建文件上传表单：在前端，需要创建一个包含文件上传功能的表单。可以使用 HTML <input type=\"file\"> 元素来实现文件选择和上传。\n2. 处理文件选择事件：通过监听文件选择事件，在用户选择文件后获取文件对象。可以使用 JavaScript 来获取并处理文件对象。\n3. 发起文件上传请求：使用合适的网络请求库（例如 Axios）将文件上传到服务器。需要根据后端提供的接口规范，构造适当的 HTTP 请求（通常使用 POST 方法）。请求中需要包含文件数据和其他可能的相关信息。\n4. 后端处理文件上传：后端接收到文件上传请求后，需要对文件进行处理。这可以包括保存文件到服务器的文件系统、将文件信息存储到数据库或进行其他业务逻辑操作。\n5. 响应文件上传结果：后端处理完文件上传后，需要向前端发送响应，通知上传结果。可以通过 HTTP 响应状态码、JSON 数据等方式来传递结果信息。\n\n在实际的文件上传过程中，可能需要考虑文件大小限制、文件类型验证、断点续传、上传进度展示等方面的逻辑。具体实现方式可以根据项目需求和后端接口规范进行调整。\n## 23. 支付宝沙箱如何切换正式环境地址\n\n1. 获取正式环境的商户号和密钥：在切换到正式环境之前，需要获得支付宝正式环境的商户号和密钥。这些凭证是用于在正式环境中进行支付操作的必要信息。\n2. 更改支付宝接口 URL：在沙箱环境中，支付宝的接口 URL 是模拟的测试地址。要切换到正式环境地址，需要将代码中的接口 URL 更改为支付宝正式环境的 URL。通常，这些 URL 可以在支付宝的开发者文档中找到。\n3. 使用正式环境的商户号和密钥：在调用支付宝接口时，确保使用从支付宝正式环境获取的商户号和密钥来进行身份验证和签名。\n## 24. 支付成功获取不到回调如何解决\n可以按照以下步骤进行排查和解决：\n\n1. 确认支付宝 SDK 配置：确保你在集成支付宝 SDK 的过程中，正确配置了支付宝的回调接口地址。在支付宝 SDK 的初始化或支付接口的参数中，应该包含回调地址的配置项。检查该配置项是否正确设置为你的回调接口的地址。\n2. 检查支付宝应用的设置：登录支付宝开放平台，进入开发者控制台，找到对应的应用，确认应用的回调配置是否正确。确保设置的回调地址与你的回调接口地址一致。\n3. 检查回调接口逻辑：确保回调接口的逻辑能够正确处理支付宝异步通知的数据。在接收到支付宝的回调请求时，你需要对回调参数进行验签（使用支付宝提供的验签方法），并根据验签结果判断回调是否有效。同时，需要根据支付宝回调的参数判断支付状态、金额等信息，并处理业务逻辑。检查回调接口的代码逻辑，确保数据的处理和业务逻辑的正确性。\n4. 检查服务器网络配置：如果回调接口部署在云服务器或私有网络中，需要检查服务器的网络配置，确保支付宝服务器能够正常访问回调接口的地址。检查防火墙、安全组以及路由配置，确保没有阻止支付宝服务器访问的限制。\n5. 开启支付宝日志调试：在支付宝 SDK 中一般会提供开启日志调试的方法。可以尝试开启支付宝 SDK 的日志调试功能，查看是否有相关的错误或异常日志输出，帮助定位问题所在。\n## 25. 自定义hooks如何实现支付地址在不同的环境下使用不同的地址\n\n```typescript\nimport { useEffect, useState } from 'react';\n\nconst usePaymentAddress = () => {\n  const [paymentAddress, setPaymentAddress] = useState('');\n\n  useEffect(() => {\n    // 根据当前环境设置支付地址\n    const currentEnv = process.env.NODE_ENV;\n    let address = '';\n\n    if (currentEnv === 'development') {\n      address = 'https://sandbox-payment-url.com'; // 开发环境的支付地址\n    } else if (currentEnv === 'production') {\n      address = 'https://production-payment-url.com'; // 生产环境的支付地址\n    }\n\n    setPaymentAddress(address);\n  }, []);\n\n  return paymentAddress;\n};\n\nexport default usePaymentAddress;\n\n```\n在上述代码中，我们根据 process.env.NODE_ENV 的值来确定当前环境，并根据环境设置相应的支付地址。然后，通过 setPaymentAddress 更新 paymentAddress 状态。最后，将 paymentAddress 返回给使用该自定义 hooks 的组件。请确保你的项目中已经配置了相应的环境变量。\n使用该自定义 hooks 的组件可以这样获取支付地址：\n\n```typescript\nimport usePaymentAddress from './usePaymentAddress';\n\nconst PaymentComponent = () => {\n  const paymentAddress = usePaymentAddress();\n\n  // 在组件中使用 paymentAddress\n\n  return (\n    <div>\n      Payment Address: {paymentAddress}\n    </div>\n  );\n};\n\n```\n## 26. 自定义hooks如何实现了路由守卫\n\n使用 React Router 提供的钩子函数来进行路由守卫逻辑的实现。\n\n```typescript\nimport { useEffect } from 'react';\nimport { useHistory } from 'react-router-dom';\n\nconst useRouteGuard = () => {\n  const history = useHistory();\n\n  useEffect(() => {\n    const unlisten = history.listen(location => {\n      // 在此处编写路由守卫逻辑\n      if (location.pathname === '/protected') {\n        const isAuthenticated = checkIfUserIsAuthenticated(); // 检查用户是否已认证\n\n        if (!isAuthenticated) {\n          // 如果用户未认证，则重定向到登录页\n          history.push('/login');\n        }\n      }\n    });\n\n    return () => {\n      unlisten(); // 在 hooks 生命周期结束时取消监听\n    };\n  }, [history]);\n\n  // 其他自定义逻辑\n\n  return null;\n};\n\nexport default useRouteGuard;\n\n```\n\n在上述代码中，我们使用了 useHistory 钩子来获取 history 对象，然后使用 history.listen 监听路由变化。在回调函数中，你可以编写路由守卫逻辑，例如，检查用户是否已认证，如果未认证则重定向到登录页。\n最后，我们在 useEffect 的返回函数中取消对路由变化的监听，以避免内存泄漏。\n使用该自定义 hooks 的组件可以这样实现路由守卫：\n```typescript\nimport useRouteGuard from './useRouteGuard';\n\nconst App = () => {\n  useRouteGuard();\n\n  return (\n    <Router>\n      {/* 其他组件和路由配置 */}\n    </Router>\n  );\n};\n\n```\n通过这种方式，你可以在自定义 hooks 中实现路由守卫逻辑，并在根组件中使用该 hooks，确保在路由切换时执行相应的守卫逻辑。\n##  27. react - .d 文件 Declare \n\n是用于声明模块、库或组件的类型信息的文件。它们称为类型声明文件，用于为那些没有内置类型声明的第三方库或模块提供类型定义。通过使用.d文件，你可以为React组件、外部库等提供类型检查、自动补全和文档提示等支持\n##  28. react - hooks 应用场景 如何实现 \n##  29. react - 类组件和函数组件区别 \n### 状态\n\n- `class组件`实例化后拥有自己的状态，可进行数据操作\n- `函数组件`无法被实例化，没有自己状态，每次执行后变量会被重置，因此在函数组件无法执行for循环。为了保存状态、执行副作用，react-hooks应用而生。\n##  30. react - useEeffect  可以实现 class类组件中的生命周期挂载事件吗？ \n是用于声明模块、库或组件的类型信息的文件。它们称为类型声明文件，用于为那些没有内置类型声明的第三方库或模块提供类型定义。通过使用.d文件，你可以为React组件、外部库等提供类型检查、自动补全和文档提示等支持\n##  31. react - redux 相关插件 \n##  32. react - uselayout 和 useEeffect \n\n- useLayoutEffect 的执行时机在 DOM 更新完成后、页面重新渲染前。可以用于读取布局信息或执行其他触发页面重新渲染的操作。\n- useEffect 在组件渲染之后异步执行，不会阻塞渲染。通常用于添加副作用操作（如数据获取、订阅事件等）\n\n在大部分情况下，应优先使用 useEffect。只有在需要在页面布局更新后立即执行代码的特殊情况下，才考虑使用 useLayoutEffect。\n##  33. ts - interface和type区别 \n\n- interface 是用于定义对象、类或函数的契约，它可以描述对象的结构、方法的签名，或作为类的实现接口。可以通过extends实现接口之间的继承。\n- type 是用于定义类型别名，它可以给现有类型（如基本类型、联合类型、交叉类型等）起一个新的名称。可以使用联合类型、交叉类型等来组合多个类型。\n\n接口（interface）和类型别名（type）在大部分情况下可以互相替代使用，但也有一些细微的差别。例如，接口可以被合并（使用相同名称的多个接口会被自动合并），而类型别名则不能。\n##  34. ts - 泛型应用场景 、约束 \n### 应用场景\n（Generics）在 TypeScript 中具有广泛的应用场景，它可以增加代码的可重用性、类型安全性和灵活性。以下是泛型常见的应用场景：\n\n1. 创造可复用的函数或类：使用泛型可以编写通用的函数或类，以适应多种类型的数据。例如，Array 类型提供了通用的泛型数组容器，可以用于存储不同类型的元素。\n\n```typescript\nfunction printArray<T>(arr: T[]): void {\n  for (let item of arr) {\n    console.log(item);\n  }\n}\n\nprintArray([1, 2, 3]); // 打印数组元素\nprintArray(['a', 'b', 'c']); // 打印字符串数组元素\n```\n\n2. 在集合类型中指定元素类型：通过使用泛型可以定义集合类型，指定其中元素的类型。例如，可以使用泛型参数 `<T>` 来声明一个泛型数组类型。\n\n```typescript\ntype MyArray<T> = T[];\n\nconst numbers: MyArray<number> = [1, 2, 3];\nconst strings: MyArray<string> = ['a', 'b', 'c'];\n```\n\n3. 创建类型安全的数据结构：泛型可以用于定义类型安全的数据结构，例如栈（Stack）、队列（Queue）等。\n\n```typescript\nclass Stack<T> {\n  private elements: T[] = [];\n  \n  push(element: T): void {\n    this.elements.push(element);\n  }\n  \n  pop(): T | undefined {\n    return this.elements.pop();\n  }\n}\n\nconst stack = new Stack<number>();\nstack.push(1);\nstack.push(2);\nstack.push(3);\nconsole.log(stack.pop()); // 输出 3\nconsole.log(stack.pop()); // 输出 2\n```\n\n4. 在 React 中编写可复用组件：泛型可以用于编写通用的高阶组件（Higher-order Components，HOC）。HOC 是一个接受一个组件作为参数并返回一个新组件的函数。通过使用泛型，可以使 HOC 更加灵活，适用于不同类型的组件。\n\n```typescript\nfunction withLoading<T>(Component: React.ComponentType<T>) {\n  return function WithLoading(props: T) {\n    // 添加 loading 逻辑\n    return <Component {...props} />;\n  };\n}\n\nconst MyComponent = withLoading(SomeComponent); // 使用泛型为 SomeComponent 添加 Loading 功能\n```\n\n5. 创建可扩展的抽象函数或类：通过泛型可以创建可扩展的抽象函数或类，以便其他开发人员可以通过扩展泛型类型参数来添加额外的功能。\n\n\n### 泛型约束（Generic Constraints）\n\n用于限制泛型类型参数的类型范围。通过使用泛型约束，可以指定传递给泛型的类型参数必须满足特定的条件，从而增加代码的类型安全性。\n\n以下是几种常见的情况，可以考虑使用泛型约束：\n\n1. 限制类型参数必须具有某种属性或方法：有时候我们需要确保泛型类型参数包含特定的属性或方法。例如，我们想写一个函数来获取数组的第一个元素，但不确定数组中元素的类型。这时可以使用泛型约束来约束类型参数必须具有 `length` 属性和索引访问方法，以确保参数是一个数组类型：\n\n```typescript\nfunction getFirstElement<T extends ArrayLike<any>>(arr: T): T[number] | undefined {\n  return arr.length > 0 ? arr[0] : undefined;\n}\n\nconst result = getFirstElement([1, 2, 3]); // result 的类型为 number\n```\n\n2. 将泛型类型参数约束为特定的类型或类型范围：有时候我们需要限制泛型类型参数必须是某个特定类型或满足某个类型范围。例如，我们想写一个函数，接受两个参数并返回它们的和，但限制参数必须是数字类型：\n\n```typescript\nfunction add<T extends number>(a: T, b: T): T {\n  return a + b;\n}\n\nconst result = add(2, 3); // result 的类型为 number\n```\n\n在上述例子中，使用 `extends number` 泛型约束，确保 `a` 和 `b` 的类型参数必须是数字类型。\n\n3. 使用多个泛型类型参数之间的关系：有时候我们需要在泛型类型参数之间建立关系，例如一个类型参数必须是另一个类型参数的子类型。这种情况下，我们可以使用泛型约束来描述关系。\n\n```typescript\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst person = {\n  name: 'John',\n  age: 30,\n};\n\nconst name = getProperty(person, 'name'); // name 的类型为 string\nconst age = getProperty(person, 'age'); // age 的类型为 number\n```\n\n在上述例子中，使用 `K extends keyof T` 泛型约束，确保 `key` 的类型参数是对象 `T` 的键名之一，从而确保获取属性值的键名在对象上有效。\n\n总而言之，使用泛型约束可以在泛型代码中增加类型的限制和约束，提高代码的类型安全性和可读性。泛型约束使得泛型类型参数更加灵活和有用。\n##  35. echarts 数据更新问题，数据更新，echarts未刷新 ，如何解决？ \n##  \n\n1. 使用 setOption 方法：ECharts 提供了 setOption 方法，可以用于更新图表的配置项。通过调用 setOption 方法，并传入新的配置项，可以实现图表的数据更新和刷新。\n```\n// 假设已经创建了一个图表实例 myChart\n\n// 新数据\nconst newData = [10, 20, 30, 40, 50];\n\n// 使用 setOption 方法更新配置项\nmyChart.setOption({\n  series: [{\n    data: newData,\n  }],\n});\n```\n注意，使用 setOption 方法更新图表时，需要确保传入的配置项格式正确，并且包含了需要更新的部分配置。\n\n1. 使用 dispose 和 init 方法重新创建图表：如果使用 setOption 方法无法解决数据更新的问题，可以尝试销毁当前的图表实例，然后重新创建一个新的实例来代替。\n```\n// 假设已经创建了一个图表实例 myChart\n\n// 销毁当前的图表实例\nmyChart.dispose();\n\n// 创建一个新的图表实例\nconst newChart = echarts.init(document.getElementById('chartContainer'));\n\n// 使用新配置项设置图表数据\nnewChart.setOption({\n  // 配置项...\n});\n```\n通过销毁当前图表实例并重新创建一个新的实例，可以确保图表完全重新绘制，并加载最新的数据。\n\n更多\n\n[React.js面试题精选---3](https://mp.weixin.qq.com/s/USOF_5T3TPkRuSGAXYCSNA)\n",
      "properties": {
        "title": "专高4功能模块+复杂度提薪点",
        "urlname": "kxlfse72fgcggs7a",
        "date": "2023-08-09 15:52:46",
        "updated": "2023-10-08 09:50:39"
      },
      "catalog": [],
      "body": "",
      "realName": "kxlfse72fgcggs7a",
      "relativePath": "\\kxlfse72fgcggs7a.md"
    },
    {
      "id": 137283324,
      "doc_id": "kidry53ewgsi52pg",
      "title": "kidry53ewgsi52pg",
      "updated": 1696521566000,
      "body_original": ":::info\n 单向数据流：即规范了数据的流向——由外层组件向内层组件进行传递和更新。 \n:::\n如何更好的理解单一数据流呢?\n可以用去银行贷款这一步骤代入到仓库中\n> React Component---人想去贷款创业 store ----银行的钱 Reducers----银行信贷系统 Action Creator----人自己去贷款的动作 你细品下....... 你(React Component)想改变自己的经济状况,产生一个去贷款的动作(Action Creato),找到了银行的钱(store),管理员调用信贷系统(Reducers),管理员把钱给你,你变了你的经济状况(更改了状态重新渲染组件)\n\n\n当使用React开发应用时，使用单一数据流模式可以带来以下好处，并通过一个简单的购物车应用的例子进行解释：\n\n1.  **可预测性：** 单一数据流模式使状态变化更加可预测。例如，假设我们有一个购物车组件和一个商品列表组件。购物车组件负责显示已选择的商品，而商品列表组件负责显示可供选择的商品。通过单一数据流，我们可以清晰地知道购物车中的商品是如何更新的，因为它们只能通过传递给购物车组件的props进行更新。 \n2.  **易于理解和维护：** 单一数据流模式使代码更易于理解和维护。例如，当我们点击商品列表中的一个商品时，我们可以通过触发一个事件并更新购物车组件的状态来实现商品添加到购物车的功能。这种明确的数据流动方式使得我们可以轻松地理解代码，而不需要查看其他组件的状态。 \n3.  **单一数据源：** 在React中，我们通常使用状态管理库（如Redux）来管理应用的全局状态。这些状态管理库使用单一数据源的概念，将所有的状态集中存储在一个地方。例如，在购物车应用中，我们可以使用Redux来存储购物车的状态，而不是将状态分散在多个组件中。这样做可以使状态的管理更加集中和一致。 \n4.  **可扩展性：** 单一数据流模式使应用的扩展更加容易。例如，在购物车应用中，如果我们想要添加一个“优惠券”功能，我们只需要在数据流中添加一个新的组件，并确保它与购物车组件和商品列表组件正确地进行数据交互。这种模式下，我们可以轻松地扩展应用的功能，而不会对其他组件产生不必要的影响。 \n\n综上所述，通过单一数据流模式，我们可以更好地理解和维护代码，使状态变化更加可预测，并且能够轻松地扩展应用的功能。这些优点使得React中使用单一数据流模式成为一种常见的做法。\nreact实现单向数据流原理？\n\n参考\n[https://www.cnblogs.com/sanchang/p/10513571.html](https://www.cnblogs.com/sanchang/p/10513571.html)\n",
      "properties": {
        "title": "为什么react使用单一数据流",
        "urlname": "kidry53ewgsi52pg",
        "date": "2023-08-24 21:28:11",
        "updated": "2023-10-05 23:59:26"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "kidry53ewgsi52pg"
        }
      ],
      "body": "",
      "realName": "kidry53ewgsi52pg",
      "relativePath": "\\kidry53ewgsi52pg.md"
    },
    {
      "id": 136507317,
      "doc_id": "lusv5pm2rbl2ygkf",
      "title": "lusv5pm2rbl2ygkf",
      "updated": 1696327676000,
      "body_original": "### 装饰器语法\n\n装饰器是 TypeScript（简称 TS）中的一个特性，它可以在不修改\t原始代码的情况下，通过添加额外的功能来改进代码。装饰器通常以`@`符号紧跟着一个函数或者类来表示。装饰器可以用于函数、类、属性和方法。\n\n### 类装饰器\n\n类装饰器用于修饰类，可以添加额外的行为或者修改类的行为。它可以用于在类声明之前对类进行拦截、修改或者扩展，对类进行修饰。类装饰器的使用场景很多，比如日志记录、性能分析、权限控制等。举个例子，想象一个社交平台的用户类，可以使用类装饰器添加检查用户是否在线的功能：\n\n```typescript\nfunction checkOnline(target: any) {\n  return class extends target {\n    isOnline() {\n      // 检查用户是否在线的逻辑\n    }\n  };\n}\n\n@checkOnline\nclass User {\n  // 用户类的定义\n}\n```\n\n### 属性装饰器\n\n属性装饰器用于修饰类的属性，可以在属性声明之前对属性进行拦截、修改或者扩展。它可以在访问属性时执行特定的操作，比如验证输入、计算属性等。一个实际场景可以是一个购物车类中的商品数量属性装饰器：\n\n```typescript\nfunction validateQuantity(target: any, propertyKey: string) {\n  let value = target[propertyKey];\n\n  const getter = function () {\n    return value;\n  };\n\n  const setter = function (newValue: number) {\n    if (newValue < 0) {\n      throw new Error(\"商品数量不能为负数。\");\n    }\n    value = newValue;\n  };\n\n  Object.defineProperty(target, propertyKey, {\n    get: getter,\n    set: setter,\n    enumerable: true,\n    configurable: true,\n  });\n}\n\nclass ShoppingCart {\n  @validateQuantity\n  quantity: number;\n}\n```\n\n### 方法装饰器\n\n方法装饰器用于修饰类的方法，可以在方法定义之前对方法进行拦截、修改或者扩展。它可以用于验证输入、记录日志等场景。举个例子，假设有一个订单类，可以使用方法装饰器添加日志记录功能：\n\n```typescript\nfunction log(target: any, methodName: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function (...args: any[]) {\n    console.log(`调用方法 ${methodName}，参数: ${JSON.stringify(args)}`);\n    const result = originalMethod.apply(this, args);\n    console.log(`方法 ${methodName} 返回值: ${JSON.stringify(result)}`);\n    return result;\n  };\n\n  return descriptor;\n}\n\nclass Order {\n  @log\n  calculateTotal() {\n    // 计算订单总金额的逻辑\n  }\n}\n```\n\n### 解决痛点和实战案例\n\n装饰器在 TS 中的作用非常重要，它可以帮助我们简化代码、增加功能，提高代码重用性和可维护性。以下是几个生活化场景的实例：\n\n#### 1. 性能监测\n\n想象你在开发一个电子游戏，你可以使用装饰器来检测某个方法的执行时间，以便帮助你优化性能。你可以创建一个方法装饰器，用于打印方法的执行时间：\n\n```typescript\nfunction performance(target: any, methodName: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function (...args: any[]) {\n    const start = performance.now();\n    const result = originalMethod.apply(this, args);\n    const end = performance.now();\n    console.log(`方法 ${methodName} 执行时间: ${end - start}ms`);\n    return result;\n  };\n\n  return descriptor;\n}\n\nclass Game {\n  @performance\n  play() {\n    // 玩游戏的逻辑\n  }\n}\n```\n\n#### 2. 权限控制\n\n假设你正在开发一个论坛系统，不同用户具有不同的权限。你可以使用类装饰器来检查用户的权限，并对一些敏感操作进行限制。以下是一个模拟的权限控制的例子：\n\n```typescript\nfunction checkPermission(permission: string) {\n  return function (target: any) {\n    const originalConstructor = target;\n\n    const newConstructor = function (...args: any[]) {\n      // 检查用户权限的逻辑\n      if (!hasPermission(permission)) {\n        throw new Error(`没有权限进行操作：${permission}`);\n      }\n      return new originalConstructor(...args);\n    };\n\n    newConstructor.prototype = originalConstructor.prototype;\n\n    return newConstructor;\n  };\n}\n\n@checkPermission(\"delete_post\")\nclass Forum {\n  deletePost(postId: string) {\n    // 删除帖子的逻辑\n  }\n}\n```\n\n装饰器是 TS 中非常有用的特性，它可以帮助开发者在不修改原始代码的情况下，为代码添加功能和行为。通过使用装饰器，我们可以简化代码、增加功能，解决一些常见的痛点，如性能监测、权限控制等。希望这些例子能帮助你理解装饰器的作用和使用场景。\n",
      "properties": {
        "title": "typescript装饰器：简化代码、增加功能的利器",
        "urlname": "lusv5pm2rbl2ygkf",
        "date": "2023-08-16 19:43:47",
        "updated": "2023-10-03 18:07:56"
      },
      "catalog": [
        {
          "title": "typescript 入门指南",
          "doc_id": "lusv5pm2rbl2ygkf"
        },
        {
          "title": "基础开发",
          "doc_id": "lusv5pm2rbl2ygkf"
        }
      ],
      "body": "",
      "realName": "lusv5pm2rbl2ygkf",
      "relativePath": "\\lusv5pm2rbl2ygkf.md"
    },
    {
      "id": 141197194,
      "doc_id": "rh3dq3cwdm2g1cg4",
      "title": "rh3dq3cwdm2g1cg4",
      "updated": 1696327240000,
      "body_original": "大家好，我是王天～ \n今天咱们用 reac+reactRouter来实现页面级的按钮权限功能。这篇文章分三部分，实现思路、踩坑记录，代码实现。嫌啰嗦的朋友，直接拖到最后一章节看代码哦。\n# 前言\n通常情况下，咱们为用户添加权限时，除了页面权限，还会细化到按钮级别，比如、新增、删除、查看等权限。\n\n如下效果，切换用户登录后，操作权限除了左侧菜单，还有页面按钮。\n![按钮权限演示效果.gif](https://cdn.nlark.com/yuque/0/2023/gif/1450835/1695870713594-a9fa493f-e747-43c5-9e1c-d210866c8373.gif#averageHue=%23f5f6fe&clientId=u99d81f03-4fcc-4&from=paste&height=734&id=MVcPK&originHeight=1468&originWidth=2802&originalType=binary&ratio=2&rotation=0&showTitle=false&size=9278845&status=done&style=none&taskId=uc9077042-3a60-48db-940f-8f25b23923f&title=&width=1401)\n# 实现思路\n按钮控制本质是条件判断，满足条件显示按钮，否则禁用/消失。\n假如每个页面的按钮权限都不同，简单的条件判断，肯定无法满足，那如何实现呢 ？\n王天觉得重点是权限数据结构，如何获取当前页面的按钮权限数据，这需要和后端沟通好，定义页面路径和权限数据的映射关系\n## 使用路由实现页面按钮权限\n步骤：\n:::info\n\n1. 在路由配置中添加页面权限参数\n2. 通过路由实例，获取当前页的权限\n3. 封装按钮权限组件，动态显隐按钮\n:::\n# 实战代码\n## 定义路由配置数据\n需和后端配合，将按钮权限和页面路由一同返回\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1695866884450-5eb5ecf2-7a09-4353-9cd7-99b1195a295f.png#averageHue=%23232020&clientId=ucb56c198-d407-4&from=paste&height=420&id=ube308f09&originHeight=840&originWidth=866&originalType=binary&ratio=2&rotation=0&showTitle=false&size=91080&status=done&style=none&taskId=u03376b89-f14c-4434-801a-dfb4db63e70&title=&width=433)\n## 存储路由和按钮权限映射关系\n既然无法通过路由实例获取权限数据，那么我们手动创建一个对象，来存储路由和按钮权限映射关系。\n用户登录后，在遍历生成路由配置同时、将按钮权限和页面路径的映射数据，存储本地。\n执行如下代码\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1695857607911-4a256bcc-be5d-4ad6-8879-67531923cfc0.png#averageHue=%23241f1e&clientId=ucb56c198-d407-4&from=paste&height=428&id=u36e50943&originHeight=856&originWidth=1362&originalType=binary&ratio=2&rotation=0&showTitle=false&size=127733&status=done&style=none&taskId=ube783756-d6bb-47e7-8629-b33004f0cd9&title=&width=681)\n## 按钮权限组件\n封装按钮权限组件，读取本地权限数据、控制按钮的显隐、禁用状态，代码如下：\n```tsx\nimport { Tooltip } from 'antd';\nimport React from 'react';\nimport { useLocation } from 'react-router-dom';\n\ninterface IndexProps {\n  scopeTtype:string, // 权限码\n  children:any// 子组件\n}\n\nconst Index: React.FC<IndexProps> = (props) => {\n  // 获取当前页面的位置信息、\n  const routeDom = useLocation(); \n  // 从本地缓存读取 页面路径和权限数据\n  const strPersstion = localStorage.getItem('pagePersstion');\n  const pagePersstion = JSON.parse(strPersstion as string); \n  // 找到当前页的按钮权限数据\n  const currentPerssion = pagePersstion.find((item: { page: string; })=>item.page == routeDom.pathname);\n  console.log('当前页面的按钮权限',currentPerssion);\n  //  有权限返回按钮\n  if(currentPerssion.permissions[props.scopeTtype]){\n    return  props.children;\n  }else{ \n    // 没有则禁用、或者隐藏按钮\n    // 要实现按钮禁用，需要设置组件的disabled \n    // 可是react 中的props是只读无法修改，如何修改props中子组件呢？\n    // 通过React API React.cloneElement 克隆出新的元素进行修改如下\n    const Button = React.cloneElement(props.children, {\n      disabled: true\n    });\n\n    return   <>\n      <Tooltip title=\"暂无权限\">  {Button}</Tooltip>\n    </>;\n  };\n};\n\n\nexport default Index;\n```\n## 使用按钮权限组件\n```tsx\n<AuthButton scopeTtype=\"isDelete\">\n  <Button type=\"primary\" onClick={start} disabled={!hasSelected} loading={loading}>\n    批量删除\n  </Button>\n</AuthButton>\n<AuthButton scopeTtype=\"isAdd\">\n    <Button onClick={showModal}>新增员工</Button>\n</AuthButton>\n```\n模拟的路由数据：员工管理页面的路由、按钮配置\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1695866906840-8af28a37-170e-43c1-ab74-b0f3e1c2ee19.png#averageHue=%23232020&clientId=ucb56c198-d407-4&from=paste&height=420&id=u32376b11&originHeight=840&originWidth=866&originalType=binary&ratio=2&rotation=0&showTitle=false&size=91080&status=done&style=none&taskId=u2b3f7d20-558b-4acf-b2a5-55d284b2e09&title=&width=433)\n## 效果：\n当切换用户登录后，很明细发现右侧表格、操作按钮权限变化。效果如下\n![](https://cdn.nlark.com/yuque/0/2023/gif/1450835/1695870713594-a9fa493f-e747-43c5-9e1c-d210866c8373.gif#averageHue=%23f5f6fe&from=url&id=D57Ps&originHeight=1468&originWidth=2802&originalType=binary&ratio=2&rotation=0&showTitle=false&status=done&style=none&title=)\n以上全文完，最后总结一下reactRoute和vueRouter的实现区别。\n## vueRouter vs ReactRouter\n### vueRouter\n此方案中，在vue中实现比较方便，使用vueRouter配置路由`meta`元信息、为按钮权限的数据\n```tsx\n{\n  path: '/imgMove/:id',\n    name: 'imgMove',\n    meta: {\n    itwangtianAuth: true\n    // 此页面是否token校验\n  },\n  component: imgMove\n}\n```\n在页面路由实例中读取meta数据，进行页面级别的按钮权限控制。\n```javascript\n// 在 Vue 组件中获取路由的 meta 数据\nexport default {\n  name: 'ExampleComponent',\n  mounted() {\n    // 获取当前路由对应的路由记录\n    const route = this.$route; \n    // 获取该路由记录的 meta 数据\n    const meta = route.meta; \n    // 使用 meta 数据\n    console.log(meta.itwangtianAuth); \n  }\n}\n```\n### ReactRouter\n但是，在react-Router6版本中没有路由元信息配置，就算自定义路由属性，也无法获取，如下是踩坑代码，大家看看就行、可不要尝试了\n## 踩坑记录\n踩坑代码-添加路由自定义属性，获取权限数据首先，在路由配置中设置自定义属性，例如 title 和 requiresAuth：\n```tsx\n<Route\n  path=\"/dashboard\"\n  element={<Dashboard />}\n  title=\"Dashboard\"\n  requiresAuth={true}\n  />\n```\n然后，在 Dashboard 组件中可以通过 useRoutes() 钩子获取路由传递的属性，如下所示：\n```tsx\nimport { useRoutes, useParams, useNavigate } from 'react-router-dom';\n\nfunction Dashboard() {\n  const params = useParams();\n  const navigate = useNavigate();\n\n  // 访问路由传递的属性\n  const { title, requiresAuth } = useRoutes().pathname;\n\n  // 在这里使用元信息进行逻辑处理\n\n  return (\n    <div>\n      <h1>{title}</h1>\n      {/* 组件的其余部分 */}\n    </div>\n  );\n}\n```\n结果不用说了，报错啊啊啊啊啊啊啊\n在react-route6中 无法自定义路由属性，报错日志如下\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1695816639053-45ffb668-67ea-40fc-98af-5078087dbd5a.png#averageHue=%232b2424&clientId=ucb56c198-d407-4&from=paste&height=164&id=u59376759&originHeight=327&originWidth=1501&originalType=binary&ratio=2&rotation=0&showTitle=false&size=60639&status=done&style=none&taskId=ue56d9735-b628-462c-9a0f-26783b8332e&title=&width=750.5)\n",
      "properties": {
        "title": "reactRouter 实现页面级按钮权限",
        "urlname": "rh3dq3cwdm2g1cg4",
        "date": "2023-09-28 20:42:34",
        "updated": "2023-10-03 18:00:40"
      },
      "catalog": [
        {
          "title": "案例开发",
          "doc_id": "rh3dq3cwdm2g1cg4"
        }
      ],
      "body": "",
      "realName": "rh3dq3cwdm2g1cg4",
      "relativePath": "\\rh3dq3cwdm2g1cg4.md"
    },
    {
      "id": 133877978,
      "doc_id": "pt3e0i88hm0q8fox",
      "title": "pt3e0i88hm0q8fox",
      "updated": 1696169090000,
      "body_original": "## 1. 前言\n我们可以把泛型比喻为一个类型占位符，它告诉编译器：“嘿，这里有一个类型参数，我现在不确定具体是什么类型，但稍后会告诉你。”\n\n通过使用泛型，我们可以编写更灵活、更可复用的代码。它允许我们在定义函数、类或接口时使用类型占位符来表示类型，而不直接指定具体的类型。这样，在实际使用时，我们可以传入不同的类型参数，使得代码可以适用于多种情况。\n\n例如，让我们看一个简单的例子，来解释泛型的使用。假设我们有一个名为 `identity` 的函数，它接受一个参数并返回该参数：\n\n```typescript\nfunction identity<T>(value: T): T {\n  return value;\n}\n```\n![](https://cdn.nlark.com/yuque/0/2023/webp/1450835/1695386338775-6beb1486-eb68-4ea3-81bc-f49487636f28.webp#averageHue=%235d656c&clientId=udef0fc1d-2a9e-4&from=paste&id=Z4gni&originHeight=376&originWidth=776&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u87616256-372e-4a97-8250-b86d2240ce5&title=)\n在上述代码中，`<T>` 表示这是一个泛型函数，`T` 是一个类型参数，可以是任何类型。函数的参数 `arg` 的类型为 `T`，返回值的类型也是 `T`。这样，我们可以在函数调用时传入不同的类型参数，使得函数适用于各种类型的参数。\n\n\n例如，我们可以这样调用 `identity` 函数：\n\n```typescript\nlet result1 = identity<number>(42); // 传入 number 类型\nlet result2 = identity<string>(\"Hello, TypeScript\"); // 传入 string 类型\n```\n\n在第一次调用时，类型参数 `number` 被传递给 `identity` 函数，所以返回值的类型也是 `number`。而在第二次调用时，类型参数 `string` 被传递给 `identity` 函数，所以返回值的类型是 `string`。\n\n通过使用泛型，我们可以编写出更加通用的函数，不限于特定的类型。这样一来，我们能够避免代码的重复编写，提高代码的可复用性和灵活性。\n\n泛型主要用在四个场合：函数、接口、类和别名。\n### 基本使用\n泛型使用尖括号 `<T>` 来表示，并在定义函数、类或接口时指定类型参数。下面是一些基本的使用示例：\n\n```typescript\n// 示例1: 创建一个泛型函数\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n\n// 示例2: 使用泛型函数\nlet output = identity<string>(\"Hello\");\nconsole.log(output);  // 输出: Hello\n\n// 示例3: 使用类型推断，自动推断泛型类型\nlet output2 = identity(\"Hello\");\nconsole.log(output2);  // 输出: Hello\n```\n\n在示例1中，函数 `identity` 使用了泛型类型参数 `T`，表示参数和返回值的类型可以是任何类型。示例2和示例3展示了如何使用泛型函数并指定参数的类型。\n。\n## 2. 使用泛型变量：\n\n泛型变量允许我们在函数或类中使用一种不确定的类型，而在实际使用时才确定具体的类型。\n\n举个例子，考虑一个简单的函数`identity`，它接受一个参数并返回相同的值：\n\n```typescript\nfunction identity<T>(arg: T): T {\n    return arg;\n}\n```\n\n在这个例子中，我们使用了泛型变量`T`，它可以代表任意类型。当我们调用函数`identity`时，编译器会根据传入的参数类型自动推断`T`的具体类型。\n\n例如：\n\n```typescript\nlet result = identity<string>(\"Hello\");\nconsole.log(result); // 输出：Hello\n\nlet value = identity<number>(42);\nconsole.log(value); // 输出：42\n```\n\n通过使用泛型变量，函数`identity`可以适用于不同类型的参数，提供了更高的灵活性和可重用性。\n\n## 3. 泛型类型：\n\n泛型类型允许我们创建可以适用于不同类型的变量、函数或类。\n\n举个例子，考虑一个简单的数组反转函数`reverse`：\n\n```typescript\nfunction reverse<T>(array: T[]): T[] {\n    return array.reverse();\n}\n```\n\n在这个例子中，我们定义了一个泛型函数`reverse`，接受一个数组参数，并返回反转后的数组。泛型类型`T`用于指定数组的元素类型。\n\n例如：\n\n```typescript\nlet numbers: number[] = [1, 2, 3, 4, 5];\nlet reversedNumbers = reverse(numbers);\nconsole.log(reversedNumbers); // 输出：[5, 4, 3, 2, 1]\n\nlet strings: string[] = [\"apple\", \"banana\", \"orange\"];\nlet reversedStrings = reverse(strings);\nconsole.log(reversedStrings); // 输出：[\"orange\", \"banana\", \"apple\"]\n```\n\n通过使用泛型类型，函数`reverse`可以适用于不同类型的数组，提供了更高的灵活性和可重用性。\n\n## 4. 泛型类：\n\n泛型类允许我们创建可以适用于多种类型的类。类中的成员可以使用泛型类型进行声明和使用。\n\n举个例子，考虑一个简单的`Box`类，用于存储任意类型的值：\n\n```typescript\nclass Box<T> {\n    private value: T;\n\n    constructor(value: T) {\n        this.value = value;\n    }\n\n    getValue(): T {\n        return this.value;\n    }\n}\n```\n\n在这个例子中，我们定义了一个泛型类`Box`，它具有一个私有成员`value`和一个公共方法`getValue`用于获取值。\n\n例如：\n\n```typescript\nlet box1 = new Box<number>(42);\nconsole.log(box1.getValue()); // 输出：42\n\nlet box2 = new Box<string>(\"Hello\");\nconsole.log(box2.getValue()); // 输出：Hello\n```\n\n\n过使用泛型参数`<T>`，可以在类的定义中引入类型变量来表示未知的类型。这样一来，我们可以在类实例化时指定具体的类型，从而创建适用于不同类型数据的类的实例。\n\n## 5. 泛型约束：\n泛型约束允许我们限制泛型类型的范围，使其满足特定条件\n### 5.1. 确保属性存在\n举个例子，假设我们想编写一个函数`getLength`，用于获取对象的长度。但是并不是所有的对象都有`length`属性，所以我们需要对泛型类型进行约束，确保它具有该属性。\n\n例如：\n\n```typescript\ninterface HasLength {\n    length: number;\n}\n\nfunction getLength<T extends HasLength>(obj: T): number {\n    return obj.length;\n}\n```\n\n在这个例子中，我们使用泛型约束`T extends HasLength`来限制泛型类型`T`必须满足`HasLength`接口的要求，即具有`length`属性。\n\n例如：\n\n```typescript\nlet str = \"Hello\";\nconsole.log(getLength(str)); // 输出：5\n\nlet arr = [1, 2, 3, 4, 5];\nconsole.log(getLength(arr)); // 输出：5\n```\n\n通过使用泛型约束，函数`getLength`可以接受具有`length`属性的对象，并返回其长度。\n### 5.2 检查对象的key\n1、keyof typescript中检测类型的方法，以联合类型的方式方返回类型的所有key \n2、搭配泛型约、`<T,K extends keyof T >`\n\nrefs[https://juejin.cn/post/6844904184894980104#heading-0](https://juejin.cn/post/6844904184894980104#heading-0)\n使用泛型，可以让我们在编译前发现错误。\n## 6 泛型接口：\n\n泛型接口允许我们定义可以适用于不同类型的接口。\n\n举个例子，考虑一个简单的`Transformer`接口，它定义了一个将输入值转换为输出值的转换器：\n\n```typescript\ninterface Transformer<T, U> {\n    transform(input: T): U;\n}\n```\n\n在这个例子中，我们定义了一个泛型接口`Transformer`，它有两个类型参数`T`和`U`，用于定义输入类型和输出类型。\n\n例如，我们可以实现一个字符串到数字的转换器：\n\n```typescript\nclass StringToNumberTransformer implements Transformer<string, number> {\n    transform(input: string): number {\n        return parseFloat(input);\n    }\n}\n```\n\n通过定义实现了`Transformer`接口的类，我们可以创建不同类型的转换器。\n\n例如：\n\n```typescript\nlet transformer = new StringToNumberTransformer();\nlet result = transformer.transform(\"3.14\");\nconsole.log(result); // 输出：3.14\n```\n\n通过使用泛型接口，我们可以定义可重用、可灵活的接口，适用于不同类型的转换操作。\n\n### 接口搭配泛型，应用在calss类上\n extend people 约束泛型类 在 people 接口范围内\n 此时是 泛型变量占位符，在实例化class类是传递类型\n```typescript\ninterface people{\n    name:string,\n    age:number\n}\n\nclass  Popele<T extends people>{\n    data:T \n    constructor(data:T){\n       this.data =data\n    }\n    hi() {\n        return `${this.data.name},,${this.data.age}`\n    }\n}\n\n\n\nlet zhagnsan = new Popele<people>({name:'张三',age:18})\n```\n\n\n总结：\n泛型在TypeScript中提供了更灵活、可重用的代码编写方式。它可以用于定义函数、类以及接口，让我们能够编写适用于不同类型的代码。\n\n\n",
      "properties": {
        "title": "终于搞懂TS中的泛型啦!!",
        "urlname": "pt3e0i88hm0q8fox",
        "date": "2023-07-21 10:24:33",
        "updated": "2023-10-01 22:04:50"
      },
      "catalog": [
        {
          "title": "typescript 入门指南",
          "doc_id": "pt3e0i88hm0q8fox"
        },
        {
          "title": "基础开发",
          "doc_id": "pt3e0i88hm0q8fox"
        }
      ],
      "body": "",
      "realName": "pt3e0i88hm0q8fox",
      "relativePath": "\\pt3e0i88hm0q8fox.md"
    },
    {
      "id": 134102506,
      "doc_id": "gg9lt52dzff45ecl",
      "title": "gg9lt52dzff45ecl",
      "updated": 1696326502000,
      "body_original": "# redux 三大原则x\n- 单一数据流\n- reducer 纯函数\n- state 是只读的\n# 环境安装\n```jsx\nnpm i redux react-redux   @types/redux-thunk  @types/redux-logger\n```\n> 依次安装 redux、集成react的redux、因redux中的禁止使用异步和打印，需要安装插件支持\n\n# redux 项目目录\n```jsx\n- src\n  - actions               // 存放定义 action 的文件\n    - actionTypes.js      // 存放 action 类型常量的文件\n    - userActions.js      // 存放用户相关的 action 创建函数的文件\n    - cartActions.js      // 存放购物车相关的 action 创建函数的文件\n    - ...\n  - reducers              // 存放定义 reducer 的文件\n    - index.js            // 根 reducer，使用 combineReducers 合并多个 reducer\n    - userReducer.js      // 用户相关的 reducer\n    - cartReducer.js      // 购物车相关的 reducer\n    - ...\n  - store                 // 存放 Redux store 相关的文件\n    - index.js            // 创建 Redux store 的文件\n  - components            // 存放 React 组件的文件夹\n    - UserComponent.js    // 用户相关的组件\n    - CartComponent.js    // 购物车相关的组件\n    - ...\n  - containers            // 存放包装组件（连接 Redux）的容器组件\n    - UserContainer.js    // 用户相关的容器组件\n    - CartContainer.js    // 购物车相关的容器组件\n    - ...\n  - App.js                // 主应用组件\n  - index.js              // 应用入口文件\n\n```\n# reducer函数\n在 Redux 中，reducer 函数是用来处理状态（state）的函数。它接收两个参数：当前的状态（state）和被分发的 action，然后根据 action 的类型来更新状态并返回新的状态对象。\n## reducer 编写规则\n\n1. 只根据 state 和 action 参数计算新的状态值\n2. 不允许修改现有的state值，必须通过复制现有的值\n3. 不能做任何异步的操作逻辑、以及副作用【可以通过插件接触此问题】\nTIP**“ 副作用 ”**** 副作用是在从函数返回值之外可以看到的状态或行为的任何变化**。一些常见的副作用是:\n\n- 将值记录到控制台\n- 保存文件\n- 设置异步计时器\n- 发出 AJAX HTTP 请求\n- 修改存在于函数之外的某些状态，或改变函数的参数\n- 生成随机数或唯一随机 ID（例如 Math.random() 或 Date.now()）\n\n**reducer 永远不允许改变原始/当前状态值！**\n```\n// ❌ 非法 - 默认情况下，这会改变状态！\nstate.value = 123\n```\n\n```jsx\nlet initialState = {\n  userName:\"赵四\"\n}\n\nfunction reducer(state = initialState, action) {\n  switch (action.type) {\n    case \"SOME_ACTION_TYPE\":\n      // 在这里处理 action，并返回新的状态对象\n      return newState;\n    case \"ANOTHER_ACTION_TYPE\":\n      // 处理另一个 action\n      return newState;\n    default:\n      // 默认情况下，返回当前状态，不做任何改变\n      return state;\n  }\n}\n```\n\n1. 一个 Redux 应用中可以有多个 reducer 函数。每个 reducer 函数负责管理和更新应用中的一部分状态。\n2. Redux 通过 `combineReducers` 函数来合并多个 reducer 函数，创建一个根 reducer，然后将根 reducer 传递给 `createStore` 方法。\n3. 根 reducer 会根据 action 的类型将对应的子状态分发给不同的 reducer 进行处理。\n# 设计 actions\n**Actions** 是具有 type 字段的普通 JavaScript 对象，来描述操作行为。\n\n例如，在一个电商系统中，当用户点击购买按钮时，我们可以创建一个名为 \"PURCHASE\" 的 action 来描述这个操作。\n一个action对象通常包含一个 type 字段来描述action的类型，以及可选的 payload 字段来携带额外的数据，type 字段是一个字符串，用于识别action的类型，而 payload 字段则可以是任何类型的数据，包括对象、数组、字符串等，用于携带一些与该操作相关的数据。\n\n下面是一个示例的action对象：\n```jsx\n{\n  type: 'PURCHASE',\n  payload: {\n    id: 1,\n    text: 'Learn Redux',\n    completed: false\n  }\n}\n\n```\n可借助 `dispatch`派发redux中的操作，来修改store数据。如下，定义一个派发dispath的函数，通常是返回 actions对象\n\n```jsx\nexport const get_table =  ( ) => {\n    return  async (dispatch: Dispatch) => {\n        let { data } = await instance.get('/api/table');\n        console.log('触发-get_Table接口了')\n        return  dispatch({\n            type: 'get_table',\n            payload: data\n        });\n    }; \n};\n```\n\n注意！包含actions对象的函数，不可是异步函数。但可以借助 thunk中间件的能力，在action函数内部执行异步操作。\n如下，需 根reducer函数中 开启中间件`applyMiddleware`，使用 异步插件 thunk\n```jsx\nimport { combineReducers, applyMiddleware, legacy_createStore as createStore } from 'redux';\nimport logger from 'redux-logger';  // 打印日志插件\nimport thunk from 'redux-thunk';// 执行异步操作插件\nimport table from './module/table/index'; // 子仓库\nimport user from './module/user/index' // 子仓库\n\nexport default createStore(\n  \tcombineReducers({ table, user }),  // 合并仓库\n  \t applyMiddleware(thunk, logger) // applyMiddleware 使用中间件\n     );\n\n```\n# 使用 redux仓库\n`Provider`组件的作用就是将 Redux 的 store 注入到 React 应用中，并使应用的所有组件都能够访问 Redux 的状态。\n使用 Provider 组件的方式如下：\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport store from './store'; // 导入 Redux 的 store\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n```\n使用 provider 优势是简化了redux的集成，不需要在组件内部手动引入状态。\n\n在React组件内部获取Redux的store有几种常见的方式：\n\n1. 使用`react-redux`库中的`useSelector` Hook：\n\n```typescript\nimport { useSelector } from 'react-redux';\n\nconst MyComponent = () => {\n  const counter = useSelector((state) => state.counter); // 获取counter状态\n\n  // 在组件中使用 counter 值\n\n  return (\n    // JSX\n  );\n};\n```\n\n2. 使用`react-redux`库中的`connect`函数：\n\n```typescript\nimport { connect } from 'react-redux';\n\nconst MyComponent = ({ counter }) => {\n  // 在组件中使用 counter 值\n\n  return (\n    // JSX\n  );\n};\n\nconst mapStateToProps = (state) => ({\n  counter: state.counter, // 将 counter 状态映射为组件的 props\n});\n\nexport default connect(mapStateToProps)(MyComponent);\n```\n\n3. 在函数组件外部使用`useStore` Hook：\n\n```typescript\nimport { useStore } from 'react-redux';\n\nconst MyComponent = () => {\n  const store = useStore();\n  const counter = store.getState().counter; // 获取 counter 状态\n\n  // 在组件中使用 counter 值\n\n  return (\n    // JSX\n  );\n};\n```\n\n第一种和第二种方式是使用`react-redux`提供的库函数来连接组件和store，提供了更方便的API。\n第三种方式是直接使用Redux提供的Hook`useStore`，更为底层，可以在函数组件外部使用，适用于一些特殊情况。\n# 拆分 reducers -store \n如何将一个复杂的业务仓库，按功能模块拆分为多个小仓库方便管理维护 ?\n\n例如，一个应用可能有多个状态需要管理，比如用户信息、购物车、主题等等。可以为每个状态编写一个单独的 reducer 函数，并使用 `combineReducers` 将它们合并成一个根 reducer。\n\n> 使用 `combineReducers` 将子仓库合并到跟reducer中\n\n```jsx\nimport { combineReducers, createStore } from \"redux\";\n\nimport userReducer from \"./userReducer\"; // 用户信息的 reducer\nimport cartReducer from \"./cartReducer\"; // 购物车的 reducer\nimport themeReducer from \"./themeReducer\"; // 主题的 reducer\n\nconst rootReducer = combineReducers({\n  user: userReducer,\n  cart: cartReducer,\n  theme: themeReducer,\n});\n\nconst store = createStore(rootReducer);\n\nexport default store;\n```\n\n在上面的示例中，`combineReducers` 函数将 `userReducer`、`cartReducer` 和 `themeReducer` 合并成一个根 reducer。每个 reducer 函数都负责管理对应的状态片段，并根据相应的 action 类型来更新状态。通过这种方式，一个 Redux 应用可以同时管理多个相关联的状态。\n# react-redux\n React Redux 是 Redux 官方提供的一个库，专门用于在 React 应用中集成和操作 Redux 的状态\n## 组件划分\nreact-redux把组件划分两类，如下：\n### 一、ui组件\nUI 组件有以下几个特征。\n\n- 只负责 UI 的呈现，不带有任何业务逻辑\n- 没有状态（即不使用this.state这个变量）\n- 所有数据都由参数（this.props）提供\n- 不使用任何 Redux 的 API\n\n下面就是一个 UI 组件的例子。\n```javascript\nconst Title =\n  value => <h1>{value}</h1>;\n```\n因为不含有状态，UI 组件又称为\"纯组件\"，即它纯函数一样，纯粹由参数决定它的值。\n### 二、容器组件\n容器组件的特征恰恰相反。\n\n- 负责管理数据和业务逻辑，不负责 UI 的呈现\n- 带有内部状态\n- 使用 Redux 的 API\n\n总之，只要记住一句话就可以了：UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑\n\n> React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它 - 阮一峰\n\n## `connect` 函数\n`connect`是react-redux提供的方法，作用将 UI组件转为 容器组件。`connect`接收两个参数 ，分别是`mapStateProps`和 `mapDispatch`\n\n1. 参数1 `mapStateProps` 负责输入逻辑将 `state`仓库内容、映射到 UI组件的参数 `props`\n2. 参数2`mapDispatch` 负责输出逻辑，将用户的操作映射成 `action`\n#### 参数 `mapStateProps` \n1、`mapStateProps` 是一个函数。建立外部映射关系，将外部`store`和组件中的`props`进行关联。\n`mapStateProps` 函数返回一个对象，数据结构中的键值对，就是一个映射关系，如：\n```typescript\nconst mapStateToProps = (state) => {\n  return {\n    todos:state.user // 仓库中的用户数据\n  }\n}\n```\n上面代码中 `mapStateProps`函数接收 state 为参数，返回对象中的 todos属性 、代表UI组件的同名参数。在组件内部，我们通过映射关系的 `props`，可以获取到 state 中的数据。\n \n`mapStateProps` 会订阅Store ，每当 store更新时，会重新计算UI组件参数，重新渲染组件。\n> 如不想更新UI组件，可以省略 connect 方法中的`mapStateProps`参数\n\n#### 参数 `mapDispatch` \n`mapDispatch` 是`connect`的第二个参数，用于建立UI组件参数和`store.dispatch`方法的映射。`mapDispatch` 可以是一个对象，也可以是一个函数。\n\n`mapDispatch` 作为函数，内置两个参数 ，分别是`dispatch`和 `onwProps`（容器组件中的props）\n```typescript\nconst mapDispatchToProps = (\n  dispatch,\n  ownProps\n) => {\n  return {\n    onClick: () => {\n      dispatch({\n        type: 'SET_VISIBILITY_FILTER',\n        filter: ownProps.filter\n      });\n    }\n  };\n}\n```\n上述代码中 `apDispatch` 作为函数 ，返回一个对象，对象中的键值对定义了如何发出 Action。\n在组件内部，直接访问onclick 方法，即可触发reducer内操作（更新、修改数据等）\n\n`mapDispatch` 作为对象，它的每个键名对应的UI组件的同名参数，值应该是一个函数。如下：\n```javascript\n\nconst mapDispatch:any = {\n    // 属性get-table ,为组件的同名参数\n    get_table:(flter:any) => ({\n        type:\"get_table\", // type 字段为actions 类型 \n        flter:flter // filter 为提交参数\n    })\n}\n```\n\n#### `mapDispatch` 高阶用法\n`bindActionCreators` 是 Redux 提供的一个辅助函数，来简化 `dispatch`派发动作过程，避免手动编写派发动作的代码。\n\n下面是使用 `bindActionCreators` 的示例和代码讲解：\n```javascript\nimport { bindActionCreators } from 'redux';\nimport { addTodo, completeTodo } from './actions';\n\n// 创建动作创建函数的对象\nconst actionCreators = {\n  addTodo,\n  completeTodo\n};\n\n// 获取 Redux store\n// 假设你已经创建了 store 并引入了所需的动作创建函数\n\n// 将动作创建函数与派发函数绑定\nconst dispatch = store.dispatch;\nconst boundActionCreators = bindActionCreators(actionCreators, dispatch);\n\n// 在组件中使用绑定后的动作创建函数\n// 这些函数会自动派发对应的动作到 Redux store\n\n// 示例 1：组件中调用绑定后的动作创建函数\nboundActionCreators.addTodo('Buy groceries');\n\n// 示例 2：将绑定后的动作创建函数传递给组件的 props\n// 在组件内部可以直接调用这些函数来派发动作\n<MyComponent addTodo={boundActionCreators.addTodo} completeTodo={boundActionCreators.completeTodo} />\n```\n\n在示例代码中，首先创建了一个包含了多个动作创建函数的 `actionCreators` 对象。然后使用 `bindActionCreators` 将 `actionCreators` 中的所有动作创建函数与 Redux store 的派发函数 `dispatch` 绑定，生成了一个新的对象 `boundActionCreators`。\n\n通过调用 `boundActionCreators` 的函数，可以在组件中自动派发对应的动作到 Redux store，而无需手动编写派发动作的代码。\n## hooks函数\nreact-redux库提供了多个钩子（hooks）函数，用于react组件访问redux的状态和操作。下面是常用的hooks函数以及用法\n### `useSelector`\n`useSelector`：用于选择 Redux store 中感兴趣的状态。它接受一个选择器函数作为参数，并返回选择器函数返回的值。\n> 使用该钩子可以避免在组件中订阅整个状态树，提供了更好的性能。\n\n\n示例用法：\n\n```jsx\nimport { useSelector } from 'react-redux';\n\nconst MyComponent = () => {\n  const counter = useSelector(state => state.counter);\n  // 在这里使用 counter\n\n  return (\n    // 组件的 JSX\n  );\n};\n```\n### `useDispatch`\n`useDispatch`：用于获取 Redux store 中的 dispatch 函数。`dispatch` 用于派发操作（dispatch actions）改变 Redux 中的状态。\n\n示例用法：\n\n```jsx\nimport { useDispatch } from 'react-redux';\n\nconst MyComponent = () => {\n  const dispatch = useDispatch();\n  // 在这里使用 dispatch\n\n  const handleClick = () => {\n    dispatch({ type: 'INCREMENT' });\n  };\n\n  return (\n    <button onClick={handleClick}>Increment</button>\n  );\n};\n```\n### `useStore`\n`useStore`：用于获取 Redux store 对象。通过这个钩子可以直接访问 Redux store 的内部方法和数据。\n\n示例用法：\n\n```jsx\nimport { useStore } from 'react-redux';\n\nconst MyComponent = () => {\n  const store = useStore();\n  const state = store.getState();\n  // 在这里使用 store 和 state\n\n  return (\n    // 组件的 JSX\n  );\n};\n```\n\n### `useActions`\n`useActions`：用于绑定动作创建函数（action creators），以便在组件中使用。它接受一个包含动作创建函数的对象作为参数，并返回已绑定到Redux store的动作创建函数。\n\n示例用法：\n\n```jsx\nimport { useActions } from 'react-redux';\nimport { increment, decrement } from './actions';\n\nconst MyComponent = () => {\n  const { incrementAction, decrementAction } = useActions({ increment, decrement });\n  // 在这里使用 incrementAction 和 decrementAction\n\n  return (\n    // 组件的 JSX\n  );\n};\n```\n\n## 搭配react hooks\t\n### useEffect\n`useEffect`：React自带的钩子函数，用于在组件渲染完成后执行副作用操作。在React Redux中，如果你想在组件挂载后执行异步操作或订阅状态变化，可以使用该钩子函数。\n\n示例用法：\n```jsx\nimport { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchData } from './actions';\n\nconst MyComponent = () => {\n  const dispatch = useDispatch();\n  const data = useSelector(state => state.data);\n\n  useEffect(() => {\n    dispatch(fetchData());\n  }, []);\n\n  // 在这里使用 data\n\n  return (\n    // 组件的 JSX\n  );\n};\n```\n### useMemo\n`useMemo`：React自带的钩子函数，用于在组件渲染过程中进行记忆化计算，以提高性能。在React Redux中，可以使用该钩子函数对选择器函数进行记忆化，以避免不必要的重复计算。\n\n示例用法：\n\n```jsx\nimport { useSelector } from 'react-redux';\nimport { createSelector } from 'reselect';\n\nconst selectData = state => state.data;\n\nconst memoizedSelector = createSelector(\n  selectData,\n  data => data.filter(item => item.completed)\n);\n\nconst MyComponent = () => {\n  const filteredData = useSelector(memoizedSelector);\n  // 在这里使用 filteredData\n\n  return (\n    // 组件的 JSX\n  );\n};\n```\n\n# 总结\n对比是一种非常棒的学习编程方法，用已知的经验代入到新的知识上，帮助我们加深理解，促进内化。\n下面用vuex和redux进行对比，会发现两者除了在语法上不同，但在功能、设计、理念、用法上如此一致，\n## 功能\n无论redux还是vuex，本质作用都是一个状态管理的工具，用于共享数据的仓库。\n**区别：**\n1、 redux可以适用于任何JavaScript框架中，无论react还是angluar 或者vue，当然vue有自己的仓库工具vuex。\n2、vuex只适用于 vue框架之中\n## 设计上\n1、redux\n\n1. redux 中不可以直接修改原始state数据，需要拷贝原数据进行修改\n2. 不可执行异步操作，但可以通过中间件处理异步操作\n\n2、vuex \n\n1. vuex 不能直接修改store数据，需要通过提交mutaions来修改。 \n2. 提供了 actions 来处理异步函数，Actions 类似于 mutations，但可以包含异步代码\n## **使用步骤：**\nvuex和react在语法上各有不同，但在步骤都可以统一为3步：\n1、创建仓库；2、获取仓库；3、修改仓库、\n在具体实现上如下：\nRedux：使用 Redux 的步骤包括定义 action 类型、创建 action 创建函数、编写 reducer 处理器，以及创建和配置 store。\nVuex：在使用 Vuex 时，需要定义 state，然后编写 mutations 来修改 state，接着可以定义 actions 来处理异步操作，最后创建一个 Vuex 的实例并配置它。\n\n## 优缺点：\n### redux\nRedux 的优点：\n\n- 可预测性：通过 action 和 reducer 明确描述数据变化。\n- 可追溯性：记录所有的 action，便于调试和错误处理。\n- 可测试性：纯函数 reducer 和 action 创建函数易于测试。\n\nRedux 的缺点：\n\n- 学习曲线较陡：相对于简单的状态管理需求，使用 Redux 可能有些繁琐。\n- 需要编写大量的模板代码。\n- 需要使用第三方中间件来处理异步操作。\n### vuex\nVuex 的优点：\n\n- 与 Vue.js 集成：作为 Vue.js 的官方状态管理库，与 Vue.js 的集成非常方便。\n- 简单易用：相对于 Redux，使用 Vuex 更加简单和直观。\n- 适合中小型项目：对于中小型单页面应用，Vuex 提供了足够的功能，而且使用起来更加轻量。\n\nVuex 的缺点：\n\n- 对于小型项目可能过于繁琐。\n- 在大型项目中，过度使用 Vuex 可能导致较为复杂的代码结构。\n> 参考链接：\n> [https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html](https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html)\n[https://cn.redux.js.org/](https://cn.redux.js.org/)\n\n\n\n",
      "properties": {
        "title": "学习react-redux，看这篇文章就够啦！",
        "urlname": "gg9lt52dzff45ecl",
        "date": "2023-07-24 08:44:41",
        "updated": "2023-10-03 17:48:22"
      },
      "catalog": [
        {
          "title": "react高阶使用",
          "doc_id": "gg9lt52dzff45ecl"
        }
      ],
      "body": "",
      "realName": "gg9lt52dzff45ecl",
      "relativePath": "\\gg9lt52dzff45ecl.md"
    },
    {
      "id": 134371301,
      "doc_id": "oqz4cvgu5cqxztwx",
      "title": "oqz4cvgu5cqxztwx",
      "updated": 1696167590000,
      "body_original": "# 数据更新不渲染页面？react 函数组件避坑\n> \nreact 函数组件中定义变量i = 0，页面模板上使用 i 变量，在按钮点击事件函数中修改 i++，但是页面上没有渲染，怎么回事？\n> \n\n在 React 函数组件中，组件的渲染是由状态（state）和属性（props）的变化触发的，而直接在函数组件中定义的变量并不会引起组件的重新渲染。\n\n如果你想在组件中更新并重新渲染页面上的内容，你应该使用 React 的状态管理。你可以使用 `useState` 钩子来声明一个状态变量，并使用状态变量的更新函数来更新它。当状态变量的值发生改变时，组件将会重新渲染并展示最新的值。\n\n以下是一个示例，展示如何在 React 函数组件中更新并渲染一个计数器：\n\n```jsx\nimport React, { useState } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Increment</button>\n    </div>\n  );\n}\n```\n\n在上面的示例中，我们使用 `useState` 钩子来声明了一个名为 `count` 的状态变量，并将其初始值设置为 0。当点击按钮时，`handleClick` 函数会通过调用 `setCount` 函数来更新 `count` 的值，从而触发组件的重新渲染。最后，我们在 JSX 中展示了计数器的值，每次点击按钮时计数器会自动增加并重新渲染。\n\n通过使用状态管理，在函数组件中更新值并触发重新渲染，可以实现页面内容的动态更新。这是 React 中推荐的做法，而直接修改函数组件外部定义的变量并不能引起组件的重新渲染。\n# react 中 阻止事件传播\n在 React 中，可以使用 `event.stopPropagation()` 方法来阻止事件的默认传播。这个方法会阻止事件进一步冒泡到父元素或其他监听同一事件的子元素上。\n\n以下是一个示例，展示如何在 React 组件中阻止事件默认传播：\n\n```jsx\nfunction MyComponent() {\n  const handleClick = (event) => {\n    event.stopPropagation();\n    console.log('Button clicked!');\n  };\n\n  return (\n    <div onClick={() => console.log('Div clicked!')}>\n      <button onClick={handleClick}>Click me</button>\n    </div>\n  );\n}\n```\n\n在上面的示例中，当点击 `<button>` 元素时，`handleClick` 函数会被调用，而且由于在函数中调用了 `event.stopPropagation()`，所以事件不会进一步冒泡到外部的 `<div>` 元素。同时，父元素 `<div>` 上的点击事件处理函数也会被触发。\n\n需要注意的是，在 React 中，`event.stopPropagation()` 方法并不会阻止事件在组件内部的其他事件处理函数中继续执行，只会阻止事件冒泡到父元素上。如果你想要完全阻止事件的默认行为和冒泡，可以使用 `event.preventDefault()` 方法，它会取消事件的默认行为并停止事件在整个 DOM 树中的传播。\n\n```jsx\nfunction MyComponent() {\n  const handleClick = (event) => {\n    event.preventDefault();\n    event.stopPropagation();\n    console.log('Button clicked!');\n  };\n\n  return (\n    <div onClick={() => console.log('Div clicked!')}>\n      <button onClick={handleClick}>Click me</button>\n    </div>\n  );\n}\n```\n\n在这个示例中，不仅阻止了事件的默认行为，还阻止了事件冒泡，确保了事件不会触发父元素上的点击事件处理函数。\n# react hoost 常用函数\n以下是几个值得关注的常见 Hook 函数，它们能够在函数组件中实现不同的功能。我将为每个函数提供示例代码和详细说明，以便更好地理解它们的使用。\n\n1. useState - 用于在函数组件中管理状态。\n\n```jsx\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  // 声明一个名为 count 的状态变量，初始值为 0\n  const [count, setCount] = useState(0);\n\n  // 增加 count 的值\n  const increment = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n```\n\nuseState 函数接受一个初始状态值，并返回一个包含当前状态和更新状态的函数的数组。在上面的示例中，我们使用 useState 创建了一个名为 count 的状态变量，并使用 setCount 函数来更新它。点击 \"Increment\" 按钮时，count 的值会增加。\n\n2. useEffect - 用于在组件加载后执行副作用操作。\n\n```jsx\nimport React, { useState, useEffect } from 'react';\n\nfunction DataFetcher() {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    // 模拟数据获取操作\n    fetch('https://api.example.com/data')\n      .then(response => response.json())\n      .then(data => setData(data));\n  }, []);\n\n  return <div>Data: {data}</div>;\n}\n```\n\nuseEffect 函数接受两个参数：一个副作用函数和一个依赖数组。副作用函数在组件加载后执行，并且可以执行异步操作、数据获取等。上面的示例中，我们使用 useEffect 来获取数据，并将数据保存在状态变量 data 中。空的依赖数组 [] 表示副作用函数只执行一次。\n\n3. useContext - 用于在函数组件中访问 React 的上下文（Context）。\n\n```jsx\nimport React, { useContext } from 'react';\n\n// 创建一个上下文\nconst ThemeContext = React.createContext('light');\n\nfunction ThemeButton() {\n  // 使用 useContext 来访问上下文的值\n  const theme = useContext(ThemeContext);\n\n  return (\n    <button style={{ background: theme }}>\n      Button with Theme\n    </button>\n  );\n}\n```\n\nuseContext 函数接受一个上下文对象，并返回当前上下文的值。在上面的示例中，我们创建了一个名为 ThemeContext 的上下文，并为它指定了默认值 \"light\"。然后，在 ThemeButton 组件中，使用 useContext 来获取 ThemeContext 的当前值，并将其应用于按钮的样式。\n\n这些是 React Hook 的一些常用函数示例，包括 useState、useEffect 和 useContext。它们可以用于在函数组件中管理状态、执行副作用操作和访问上下文。当然，还有其他很多有用的 Hook 函数，可以根据具体需求选择使用。\n\n请注意，示例代码仅供参考，具体的用法可能需要根据你的项目和需求进行调整。如果你有任何进一步的问题，请随时提问！\n# reactRouer6 新特性\n\n在 React Router v6 中，一些常用的组件包括：\n\n1. `<BrowserRouter>`：用于提供基于浏览器的导航功能。\n2. `<Link>`：用于生成导航链接，导航到指定的路由。\n3. `<Route>`：用于定义路由和相应的组件。\n4. `<Routes>`：用于定义路由配置的容器，包含多个 `<Route>`。\n5. `<Outlet>`： 用于在父级路由组件中渲染子级路由组件。\n6. `Navigate`：用于执行编程式导航操作。\n7. `Match`：用于条件渲染组件，根据当前路由匹配结果来确定是否渲染。\n8. `UseMatch`：用于在组件中访问路由匹配信息。\n\n这里只是列举了一些常用的组件，React Router v6 还提供了其他的功能和辅助组件。具体使用哪些组件，取决于你的需求和项目的路由配置。\n\n需要注意的是，React Router v6 的 API 和用法与之前的版本（如 v5）有很大的变化。\n\n可以在官方文档中找到有关 React Router v6 的更多信息：[https://reactrouter.com/docs/en/v6/getting-started/introduction](https://reactrouter.com/docs/en/v6/getting-started/introduction)\n",
      "properties": {
        "title": "react 基础操作-语法、特性 、路由配置",
        "urlname": "oqz4cvgu5cqxztwx",
        "date": "2023-07-26 09:26:42",
        "updated": "2023-10-01 21:39:50"
      },
      "catalog": [
        {
          "title": "react基础开发",
          "doc_id": "oqz4cvgu5cqxztwx"
        }
      ],
      "body": "",
      "realName": "oqz4cvgu5cqxztwx",
      "relativePath": "\\oqz4cvgu5cqxztwx.md"
    },
    {
      "id": 134102445,
      "doc_id": "slaatvufmrio04vo",
      "title": "slaatvufmrio04vo",
      "updated": 1695815648000,
      "body_original": "# 一、什么是hooks？\nReact Hooks 是 React 提供的一种功能，允许我们在函数组件中使用状态和其他 React 特性。使用 Hooks 可以简化函数组件中的状态管理和副作用处理。\n## 为什么要使用 Hooks 呢？\n因为在 React 之前，只能使用类组件来拥有状态和处理副作用。这导致在函数组件中复用状态逻辑变得困难，同时处理副作用也变得复杂，如数据获取和事件处理等。\n\nReact Hooks 的目的是解决这些问题。它提供了一种简洁的方式来在函数组件中定义和复用状态逻辑，以及处理副作用。通过使用 Hooks，我们可以更自由地编写组件，而不需要使用类组件的繁琐结构。\n## Hooks 的实现原理\nHooks 的实现原理是基于 JavaScript 的闭包和函数作用域。每个 Hook 函数都会在组件中创建一个特殊的“挂钩”，用于保存特定的状态值和处理函数。这些挂钩与组件实例相关联，并在组件的多次渲染之间保持一致性。\n## 举个栗子\n下面是一个使用 React Hooks 的示例，展示了如何创建一个计数器组件：\n\n```jsx\nimport React, { useState } from 'react';\n\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    setCount(prevCount => prevCount + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n};\n\nexport default Counter;\n```\n\n在这个示例中, 我们使用了 `useState` Hook 来在函数组件中添加状态。通过调用 `useState`，我们可以获取当前的状态值 `count` 和更新状态值的函数 `setCount`。在按钮的点击事件中，我们调用 `setCount` 来更新计数器的值，并触发重新渲染。\n\n# 二、react常用hooks\n## useState\n `useState` 这个Hook 用于在函数组件中管理状态，示例如上。\n## useEffec\nuseEffect  弥补函数组件没有生命周期的缺陷，用来处理一些副作用，比如获取数据、订阅事件、更新 DOM 等。\n常见的副作用\n- 订阅数据：订阅某个数据源，当数据变化时更新组件 state。\n- 手动更改 DOM: 通过访问 DOM 节点或使用第三方 DOM 库来改变 DOM 结构。\n- 日志记录：在控制台打印日志信息。\n- 计时器：通过设置 Interval 或 Timeout 来执行定时操作。\n- 事件监听：为 DOM 节点添加或移除事件监听器。\n1. useEffect 第一个参数是一个回调函数，组件渲染后执行的操作。比如发送网络请求，然后将数据保存在组件的状态中，以便渲染到页面上。\n2. useEffect 的第二个参数是一个依赖数组，指定影响 useEffect 执行的变量。当这些变量的值发生变化时，useEffect 会重新执行回调函数。\n\n示例代码如下：\n```jsx\nimport { useEffect } from \"react\";\n\nuseEffect((list:any)=>{\n  // 渲染组件后执行的操作\n  // xxx \n  retrun ()=>{\n    // 组件销毁前执行的回调函数\n  }\n},[list])\n\n```\n\t\t\n\n> 如果没有依赖数组，useEffect 会在每次组件渲染完成后都执行\n\n:::warning\n注意！useEffect 中第一个参数、是一个回调函数，一般有两种用途 ：\n\n1. `retrun` 之前的代码执行一些组件渲染后的操作\n2. `retrun` 一个函数，是一个清理作用的回调函数，在组件销毁前执行、用于关闭定时器、请求。\n:::\n\n下面是几个常见的用法：\t\n### 获取数据并更新状态：\n假设有一个函数组件，在组件渲染后执行一些额外的任务。可能是发送网络请求，从服务器获取数据。那么，可以使用 useEffect 来实现这个功能。\n```jsx\nimport React, { useState, useEffect } from 'react';\n\nconst MyComponent = () => {\n  const [data, setData] = useState([]);\n\n  useEffect(() => {\n    // 在组件渲染后获取数据\n    fetch('https://api.example.com/data')\n      .then(response => response.json())\n      .then(data => setData(data));\n  }, []);\n\n  return (\n    <div>\n      {data.map(item => (\n        <p key={item.id}>{item.name}</p>\n      ))}\n    </div>\n  );\n};\n```\n\n### 订阅和取消订阅事件：\n```jsx\nimport React, { useEffect } from 'react';\n\nconst MyComponent = () => {\n  useEffect(() => {\n    const handleClick = (event) => {\n      console.log('Button clicked');\n    };\n\n    window.addEventListener('click', handleClick);\n\n    return () => {\n      window.removeEventListener('click', handleClick);\n    };\n  }, []);\n\n  return (\n    <div>\n      <button>Click me</button>\n    </div>\n  );\n};\n```\n\n在这个示例中，当组件渲染后，`useEffect` 中的回调函数将订阅 `click` 事件，并在事件发生时打印一条消息。在组件卸载时，`useEffect` 的返回函数会取消订阅事件，以防止内存泄漏。\n\n### 这里还有一些小技巧：\n\n-  如果 `useEffect` 的依赖项中的值没有改变，但你仍然希望执行回调函数，可以将依赖项设置为一个空数组。这样，回调函数只会在组件挂载后执行一次。 \n-  如果你想在 `useEffect` 的回调函数中使用异步函数，可以将该函数声明为 `async` 并使用 `await` 关键字来处理异步操作。例如： \n\n```jsx\nuseEffect(() => {\n  const fetchData = async () => {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    console.log(data);\n  };\n\n  fetchData();\n}, []);\n```\n\n### 执行两次的useEffect\n在react18新特性中 useEffect会执行两次，起原因模拟组件挂载和销毁的状态，帮助开发者提前发现重复挂载造成的bug。\n**如何关闭？**\n删除根页面中的`StrictMode` 严格模式\n```tsx\nimport App from './App';\n\nconst root = ReactDOM.createRoot(\n  document.getElementById('root') as HTMLElement\n);\nroot.render(\n  // <React.StrictMode>\n    <App />\n  // </React.StrictMode>\n);\n```\n## useRef\nuseRef是React Hooks中的一个创建持久引用的hook，它提供了一种在函数组件中存储和访问 DOM 元素或其他引用的方法。\n### 为什么使用useRef\n在 JavaScript 中，我们可以创建变量并将其赋给不同的值。然而，在函数组件中，每次重新渲染时，所有的局部变量都会被重置。这就意味着我们无法在函数组件中创建一个持久存在的变量。\n\n这时候就可以使用 useRef 来解决这个问题。useRef可以用于在函数组件中存储和访问可变的数据，这些数据不会触发组件重新渲染。\n### useRef 实现原理\n`useRef` 的实现原理其实很简单。在每次函数组件执行时，它返回一个持久化的引用对象。这个对象有一个 `current` 属性，可以用来存储和读取值。当我们修改这个 `current` 属性的值时，组件的重新渲染不会受到影响。\n\n### useRef 的主要用途\n\n1. `访问 DOM 元素`：通过使用 useRef 创建一个引用，可以将其附加到 JSX 元素的 ref 属性上，从而获取对该 DOM 元素的引用。这使得我们能够直接操作 DOM，例如修改元素的样式、调用 DOM API 等。值得注意的是，useRef 返回的引用对象在组件的整个生命周期中保持不变，即使重新渲染时也不会变化。\n2. `存储组件内部的值`：可以使用 useRef 来存储某些组件内的值，类似于类组件中的实例变量。与状态 Hook（如 useState）不同，使用 useRef 存储的值的更改不会触发组件的重新渲染。因此，这种方法适用于需要在多次渲染之间共享数据的场景，或者需要存储一些在渲染期间保持稳定的状态。\n3. `缓存计算结果`：通过结合 useRef 和 useEffect Hook，可以实现对计算结果的缓存。将计算结果存储在 useRef 返回的引用中，然后在后续渲染中使用该引用。这可以避免重复的计算，提高性能。\n### 举个栗子\n下面是一个文字选中示例，使用了 `useRef`，展示了如何在函数组件中使用它：\n\n```jsx\nimport React, { useRef } from 'react';\n\nconst TextInput = () => {\n  const inputRef = useRef(null);\n\n  const focusInput = () => {\n    inputRef.current.focus();\n  };\n\n  return (\n    <div>\n      <input type=\"text\" ref={inputRef} />\n      <button onClick={focusInput}>Focus Input</button>\n    </div>\n  );\n};\n\nexport default TextInput;\n```\n\n在这个示例中，我们使用 `useRef` 创建了一个引用 `inputRef`。我们将这个引用赋给 `<input>` 元素的 `ref` 属性，以便可以在其他地方访问到这个 DOM 元素。\n\n在 `focusInput` 函数中，我们使用 `inputRef.current` 来获取引用的当前值（即 DOM 元素），并调用它的 `focus` 方法，使输入框获得焦点。\n\n### 注意！\n:::warning\n### useRef虽好，请勿滥用\n`ref` 和 `useRef`都是 React 提供的用于引用 DOM 元素或其他值的机制。它们的滥用可能会导致性能问题和代码可读性\n:::\n## useMemo\n当函数组件中状态变化时，会重新自上而下渲染当前组件、以及子组件。如何隔离状态，避免不必要的渲染 ？\n\n推荐使用 `useMemo` 钩子函数，它的作用是缓存计算结果，在依赖项发生变化时才重新计算。\n\n`useMemo` 接受两个参数：一个计算函数和一个依赖数组。计算函数会在组件渲染时执行，并返回一个计算结果。这个计算结果会被缓存起来，直到依赖项发生变化。\n\n下面是一个示例，展示了如何使用 `useMemo`：\n\n```jsx\nimport React, { useMemo } from 'react';\n\nconst MyComponent = ({ a, b }) => {\n  const result = useMemo(() => {\n    console.log('Recalculating result');\n    return a + b;\n  }, [a, b]);\n\n  return (\n    <div>\n      <p>Result: {result}</p>\n    </div>\n  );\n};\n\n// 示例二\n\nconst MyBtn = ({ text, size }: { text: string, size: any }) => {\n  return useMemo(() => {\n    return <Button size={size}>{text + '--' + new Date().getTime()}</Button>\n  }, [text, size]); \n}\n\n\n```\n\n在这个示例1 中，我们使用 `useMemo` 来缓存 `a + b` 的计算结果。当 `a` 或 `b` 发生变化时，`useMemo` 会重新计算结果；否则，它将直接返回上一次缓存的结果。\n\n当依赖项发生变化时，`useMemo` 会重新计算计算函数，并更新缓存的结果。否则，它会直接返回之前缓存的结果，避免不必要的重复计算。\n\n示例2：只有当MyBtn的props发生改变时，才会触发组件内部渲染，如果不使用useMemo，则父组件中状态改变后，子组件重新渲染你导致 时间戳每次不同 。\n\n请注意，`useMemo` 只有在需要进行计算操作并根据依赖项变化时才有必要使用。如果没有计算操作，或者根据依赖项变化时仅进行简单的引用比较，那么使用 `React.memo` 或其他适当的优化手段可能更合适。\n\n## useCallback\nuseCallback 作用是缓存回调函数，通过使用 useCallback，我们可以确保在依赖项不发生变化时，不会重新创建同一个函数，从而避免不必要的子组件重渲染或副作用函数的触发，提高性能。\n\n使用场景：\n\n1. `传递回调函数给子组件`：当我们将一个函数作为 prop 传递给子组件，并且该函数的依赖项在父组件重新渲染时可能发生变化时，可以使用 useCallback 缓存该函数，以确保子组件只在依赖项变化时才重渲染。\n2. `优化副作用函数的执行`：在使用 useEffect 或 useLayoutEffect 的副作用函数中，当依赖项发生变化时，函数会被重新执行。通过使用 useCallback，可以缓存副作用函数，避免在依赖项未变化时触发不必要的副作用。这在性能敏感的场景中尤其有用。\n\n> 注意！useCallBack的本质工作不是在依赖不变的情况下阻止函数创建，而是在依赖不变的情况下不返回新的函数地址而返回旧的函数地址。不论是否使用useCallBack都无法阻止组件render时函数的重新创建！！\n\n### 示例\nuseCallBack在什么情况下使用？在往子组件传入了一个函数。\n```javascript\nimport React, { useState, useCallback } from 'react';\n// 子组件\nconst ChildComponent = ({ increment }) => {\n  // 子组件使用 increment 回调函数\n  return (\n    <button onClick={increment}>Increment</button>\n  );\n};\n\n// 父组件\nconst ParentComponent = () => {\n  const [count, setCount] = useState(0);\n\n  const increment = useCallback(() => {\n    setCount(count + 1);\n  }, [count]);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <ChildComponent increment={increment} />\n    </div>\n  );\n};\n\n\n```\n### usecallback 和  react.mome 区别\nuseCallback 和 useMemo 都用于优化性能，避免不必要的重复计算和渲染。\n\n`useCallback返 回一个稳定的回调函数`\n\n-  依赖数据未改变时、再次运行函数，其实是执行上次函数的数据据引用。\n- 在依赖项发生变化时才会重新创建该函数。它对于传递给子组件的回调函数非常有用，确保子组件在父组件重新渲染时不会重新渲染。\n\n`useMemo 用于缓存计算结果`\n\n- 并且只有当依赖项发生变化时才会重新计算。它对于根据一些依赖项计算出的值进行缓存非常有用。它可以避免在每次重新渲染时重复计算相同的值，从而提高性能。\n### 注意！防止缓存浪费\n:::warning\n处处使用缓存，比如不使用呢\n:::\n\n# 三、实战-自定义hooks\n## useRouteGuard：路由守卫\n如下代码，是一个路由拦截器，包含权限校验、token检测功能\n```javascript\nimport { useEffect } from \"react\"\nimport { useLocation, useNavigate } from \"react-router\"\n// 白名单\nconst filterPath = ['/','/home'];\n// 路由守卫好比一个门神守卫网站，当页面路由路径发生变化时，门神启动进行拦截，身份确认成功后放行，失败返回初始页\n// 通过 useLocaltion 获取页面的位置信息，返回一个对象，包含页面路径、参数、hash值等\nexport const useWatchRoute = ()=>{\n  \n    const localtion = useLocation()\n    const navigate =  useNavigate()\n    useEffect(()=>{\n        console.log('localtion',localtion)\n        // 检测本地token\n        const token = localStorage.getItem('token')\n        // 指定页面不进行token检测[白名单]\n        const hasPermission = filterPath.some((path)=> path===localtion.pathname)\n    \n        if(!token && !hasPermission){\n            // router编程式导航-跳转页面\n            navigate('/login')\n        }\n\t  // useEffect 第二个参数是依赖数组，当数组中依赖项发生变化时，useEffect会重新执行\n    },[localtion.pathname])   \n\n    return null\n}\n```\n\n以上示例，使用 useLocaltion 获取当前页路由数据，使用useEffect钩子来创建一个监听器，以在路由变化时执行我们的路由守卫逻辑。\n \n使用这个自定义的路由守卫hooks时，你可以像下面这样在需要应用路由守卫的组件中使用它：\n```tsx\nimport React from 'react';\nimport useRouteGuard from './useRouteGuard';\n\nfunction ProtectedRouteComponent() {\n  useWatchRoute();\n\n  return (\n    <div>\n      {/* 组件内容 */}\n    </div>\n  );\n}\nexport default ProtectedRouteComponent;\n\n```\n## useUpdate ：重新渲染\n创建一个自定义hooks ，结合函数组件特性，当子组件状态更新后，父组件重新渲染实现强制渲染效果\n```jsx\nexport const useUpdate = ()=>{\n  const [,setUpdate] = useState({})\n  return useCallback(()=>{ \n    setUpdate({}) \n  },[])\n}\nconst update = useUpdate();\nreturn (\n  <div>\n    <p>时间{Date.now()}</p>\n    <button onClick={update}> 更新时间</button>\n  </div>\n)\n```\n## useMount：监听渲染\n监听组件渲染，模拟类组件中的`componentDidMount`组件挂载的生命周期\n:::warning\n实现创建、销毁自定义hooks，本质是结合`useEffect`回调函数特性：\n\n- `retrun` 之前的代码执行一些组件渲染后的操作\n- `retrun` 之后的函数是一个清理回调函数，在组件销毁前执行、用于关闭定时器、请求\n:::\n```jsx\nexport const useMount = (fn: () => void) => {\n  useEffect(() => {\n    fn?.();\n  }, []);\n};\n\n```\n## useUnmount：监听销毁\n监听组件销毁，模拟类组件中的`componentWillUnmount`组件销毁的生命周期\n```jsx\n// 自定义hooks ，定义组件挂载前的函数、销毁后的函数\nexport const useUnmount = (fn:()=>void) =>{\n  // const ref = useRef(fn)\n  // ref.current = fn;\n  useEffect(()=>{\n    // retrun 之前的代码执行一些组件渲染后的操作\n    // retrun是在组件销毁前 执行一个清理回调函数、用于关闭定时器、请求\n    return ()=>{\n      fn()\n    }\n  },[])\n}\n```\n## useMount 与 useUmount 案例\n引入自定义hooks\n```jsx\nimport {useMount,useUnmount,useUpdate} from \"./components/tool\"\n```\n定义一个`Child`组件\n```jsx\nconst Child = ()=>{\n  useMount(()=>{ \n    console.log('组件挂载了')\n    Toast.show('首次渲染')\n\n  })\n  useUnmount(()=>{\n    console.log('组件销毁了')\n    Toast.show('组件卸载了')\n  })\n  return <div>应用自定义hooks的组件 </div>\n}\n```\n定义开关，切换`Child`组件显隐\n```jsx\n\n const [flag, setFlag] = useState<boolean>(true);\n  const btnClick = ()=>{\n    setFlag(!flag)  \n  }\n    return (\n        <div className=\"App\">\n            <button    onClick={btnClick} >\n      \t  </button>\n           { flag&&<Child></Child>}\n        </div>\n    );\n```\n# 四、常见问题\n## useEffect 内部不能修改 state：\n\n在useEffect的回调函数中，不要直接修改状态。修改状态可能导致无限循环的重新渲染。正确的做法是使用setState或提取相关的状态变量，然后在useEffect的依赖项数组中引用。\n```typescript\nuseEffect(() => {\n  // 错误示例：直接修改状态\n  // setCount(count + 1);\n\n  // 正确示例：使用setState或提取相关变量\n  setCount(prevCount => prevCount + 1);\n  // 或者\n  const newCount = count + 1;\n  // 使用newCount进行其他操作\n}, [count]); // 注意在依赖项数组中引用状态\n\n```\n## useEffect 可能出现死循环：\n当useEffect的依赖项数组不为空时，如果依赖项的值在每次重新渲染时都发生变化，useEffect的回调函数会在每次重新渲染后触发。如果回调函数内部又引发了状态的变化，可能导致无限循环的渲染。\n解决这个问题的方法是仔细选择依赖项，确保只在需要的时候才触发useEffect的回调函数。如果确实需要在每次重新渲染时执行副作用，但又想避免循环，可以考虑使用useRef来记录上一次的值。\n\n```typescript\nconst prevCountRef = useRef();\nuseEffect(() => {\n  prevCountRef.current = count;\n  // 执行其他副作用操作\n});\n\n```\n## hooks中禁用循环\n循环、添加判断、嵌套函数中禁用hooks\n### 官方解释：\n> 不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层以及任何 return 之前调用Hooks\n\n### 为什么呢？\n这是因为Hooks应该在组件的顶层使用，以确保它们的调用顺序始终保持一致。\n### 错误示例\n下面是一个示例，展示了在循环中错误使用 Hook 的情况：\n```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Effect triggered');\n    return () => {\n      console.log('Effect cleanup');\n    };\n  }, [count]);\n\n  const handleClick = () => {\n    for (let i = 0; i < 3; i++) {\n      setCount(count + 1); // 错误的调用 Hook，可能导致多次注册\n    }\n  };\n\n  return (\n    <div>\n      <button onClick={handleClick}>Increase Count</button>\n    </div>\n  );\n}\n\n```\n在上面的代码中，handleClick 函数在循环中调用 setCount，这样会导致 useEffect 钩子被多次注册。这可能会导致在状态更新后多次触发副作用函数和清理函数，或者导致一些其他的问题。\n### 解决\n为了解决这个问题，应该在循环中避免直接调用 Hook。可以使用其他方式来实现预期的逻辑，并在循环外部调用 Hook。例如，可以使用计数变量来累积需要更新的数值，然后在循环结束后再次调用 Hook 来更新状态。以下是修复后的示例：\n```typescript\nimport React, { useState, useEffect } from 'react';\n\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log('Effect triggered');\n    return () => {\n      console.log('Effect cleanup');\n    };\n  }, [count]);\n\n  const handleClick = () => {\n    let updatedCount = count;\n    for (let i = 0; i < 3; i++) {\n      updatedCount += 1;\n    }\n    setCount(updatedCount);\n  };\n\n  return (\n    <div>\n      <button onClick={handleClick}>Increase Count</button>\n    </div>\n  );\n}\n\n```\n通过将状态更新的逻辑放在循环外部，我们确保了 setCount 只会被调用一次，避免了 Hooks 的误用问题。\n### 如何更好的规避呢？\n可以配置 `eslint`进行语法校验，规避hooks中写循环语句，示例配置\n```json\n{\n  \"plugins\": [\n    // ...\n    \"react-hooks\"\n  ],\n  \"rules\": {\n    // ...\n    \"react-hooks/rules-of-hooks\": \"error\"\n  }\n}\n```\n\n",
      "properties": {
        "title": "react hooks 全攻略",
        "urlname": "slaatvufmrio04vo",
        "date": "2023-07-24 08:44:10",
        "updated": "2023-09-27 19:54:08"
      },
      "catalog": [
        {
          "title": "react高阶使用",
          "doc_id": "slaatvufmrio04vo"
        }
      ],
      "body": "",
      "realName": "slaatvufmrio04vo",
      "relativePath": "\\slaatvufmrio04vo.md"
    },
    {
      "id": 137754173,
      "doc_id": "lw9yfokviowgggeg",
      "title": "lw9yfokviowgggeg",
      "updated": 1695815019000,
      "body_original": "# hooks版本\n[react hooks 全攻略](https://www.yuque.com/itwangtian/ycsiao/slaatvufmrio04vo?view=doc_embed&inner=E9R9I)\n# 组件版本\n\n- history监听路由变化，更新路由前进行权限校验\n- 使用内置hooks  `useLocation`来获取路径信息\n```javascript\n// 路由鉴权组件 -\n// 作用1：登录鉴权\n// 作用2：实现路由重定向\nimport React from \"react\";\nimport * as Type from \"../../../utils/type\";\nimport { NavLink, Navigate, useLocation } from \"react-router-dom\";\nimport RouterConfig from \"../../../router/routerConfig\"; // 路由配置数据\n \n// 查找当前路径的路由数据\nconst searchRoute = (path: string, routes: Type.RoterList) => {\n  let reslut = {};\n  for (const iterator of routes) {\n    if (iterator.path === path && !iterator.children) return iterator;\n    if (iterator.children) {\n      const res = searchRoute(path, iterator.children);\n      reslut = res;\n    }\n  }\n  return reslut;\n};\n\nconst AuthRoute = (props: any) => {\n  // 实现路由重定向，判断下当前路由配置是否包含 属性to\n\n  // 获取当前路由的配置数据\n  const { pathname } = useLocation();\n  console.log('useLocation()', useLocation())\n  let routeData = searchRoute(pathname, RouterConfig) as any\n  //   鉴权代码 --判断用户token、缓存信息,没有token跳转登录页，登录页无需校验token\n\n  if (!localStorage.getItem('token') && pathname !== '/login') {\n    window.location.href = '/login'\n  }\n  // 重定向\n  if (routeData.to) {\n    // 跳转重定向页面\n    return <Navigate to={routeData.to}></Navigate>\n  } else {\n    return <>{props.children}</>\n  }\n};\n\nexport default AuthRoute;\n\n```\n使用 authRoute 路由守卫组件\n```javascript\n// import RouteDom from \"./router/routerView\";\nimport { BrowserRouter, Link } from \"react-router-dom\";\n// 引入路由组件\nimport RouteApp from \"./router/routerView\"; 、\n// 引入路由守卫组件\nimport AuthRoute from \"./components/common/authRoute\";\nconst root = ReactDOM.createRoot(\n  document.getElementById(\"root\") as HTMLElement\n);\nroot.render(\n    <Provider store={Stroe}>\n  \t  <BrowserRouter>\n        \t<AuthRoute>\n            <RouteApp></RouteApp>\n          </AuthRoute> \n  \t  </BrowserRouter>\n    </Provider>\n);\n```\n",
      "properties": {
        "title": "路由守卫全系列",
        "urlname": "lw9yfokviowgggeg",
        "date": "2023-08-30 08:53:54",
        "updated": "2023-09-27 19:43:39"
      },
      "catalog": [
        {
          "title": "案例开发",
          "doc_id": "lw9yfokviowgggeg"
        }
      ],
      "body": "",
      "realName": "lw9yfokviowgggeg",
      "relativePath": "\\lw9yfokviowgggeg.md"
    },
    {
      "id": 140367126,
      "doc_id": "hxorr1qcrd6l69h5",
      "title": "hxorr1qcrd6l69h5",
      "updated": 1695122101000,
      "body_original": "1. 打开 Visual Studio Code。\n2. 进入命令面板（Command Palette）：通过快捷键 Ctrl+Shift+P（Windows/Linux）或 Cmd+Shift+P（Mac），或者从菜单栏选择 \"View\" > \"Command Palette\"。\n3. 在命令面板中，输入 \"Preferences: Configure User Snippets\"，然后选择此命令。\n4. 在弹出的下拉菜单中，选择对应的文件类型，这里选择 \"JavaScript\"。\n\n用chatgpt 做一些繁杂简单的配置工作，简直是太爽啦\n比如把一个代码片段发过去，让chatgpt直接生成配置文件，省区了一个个添加换行符了\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1695122045441-71ebc851-2d36-4805-8efd-00ab1fc0e1ca.png#averageHue=%23afb673&clientId=u26c22e8c-8ef3-4&from=paste&height=551&id=uaf40fbc2&originHeight=1102&originWidth=2303&originalType=binary&ratio=2&rotation=0&showTitle=false&size=163341&status=done&style=none&taskId=ua4734e21-8727-4bf8-baf6-d378d3aa36a&title=&width=1151.5)\n",
      "properties": {
        "title": "vscode新建代码片段",
        "urlname": "hxorr1qcrd6l69h5",
        "date": "2023-09-19 19:10:03",
        "updated": "2023-09-19 19:15:01"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "hxorr1qcrd6l69h5"
        }
      ],
      "body": "",
      "realName": "hxorr1qcrd6l69h5",
      "relativePath": "\\hxorr1qcrd6l69h5.md"
    },
    {
      "id": 139959480,
      "doc_id": "epc7nta9i3wfbegk",
      "title": "epc7nta9i3wfbegk",
      "updated": 1694748336000,
      "body_original": "# declare\n> 类型补全\n\ndeclare 在 TypeScript 中的作用是声明全局变量、函数、类或模块的类型信息，而不需要提供具体实现\n\n应用场景主要包括以下几个方面，解决相应的问题：\n\n1. `与外部 JavaScript 代码交互`：当使用第三方 JavaScript 库时，使用 declare 可以声明该库的类型信息，让 TypeScript 在编写代码时提供类型检查和智能提示，避免类型错误。\n2. `引入缺少的类型声明`：当使用没有提供类型声明文件的 JavaScript 库时，通过 declare 手动声明其类型信息，以便享受 TypeScript 的类型检查和编辑器支持。\n3. `扩展全局对象的类型`：在 TypeScript 中，可以使用 declare 扩展全局对象的类型，添加或覆盖属性和方法，使其与实际情况匹配。\n\n**下面是几个使用 declare 的代码示例：**\n\n- 声明全局变量和函数：\n```tsx\ndeclare const globalVar: number;\ndeclare function globalFunc(arg: string): void;\n\nconsole.log(globalVar);\nglobalFunc(\"Hello\");\n```\n\n- 声明模块的类型信息：\n```tsx\ndeclare module \"moduleName\" {\n  export function someFunc(): void;\n  export const someVar: number;\n}\n\nimport { someFunc, someVar } from \"moduleName\";\nsomeFunc();\nconsole.log(someVar);\n```\n\n- 扩展全局对象类型：\n```tsx\ndeclare global {\n  interface Array<T> {\n    customMethod(): void;\n  }\n}\n\nconst arr: number[] = [1, 2, 3];\narr.customMethod();\n```\n\n- 声明类的类型信息：\n```tsx\ndeclare class MyClass {\n  constructor(arg: string);\n  someMethod(): void;\n}\n\nconst instance = new MyClass(\"Hello\");\ninstance.someMethod();\n```\n\n \n# .d.ts 文件声明全局变量\n在 TypeScript 中，`.d.ts` 文件被用于声明全局变量、函数、类等的类型信息，以补充缺失或不确定的类型定义。这些声明文件不需要被导出，而是被自动地包含在项目的类型检查过程中。\n\n当你在一个模块文件中引入一个类型声明文件（`.d.ts` 文件），TypeScript 会自动识别并应用其中的类型信息。你可以直接在代码中使用声明文件中声明的类型，无需手动导入。\n\n举个例子，假设你有一个名为 `globals.d.ts` 的声明文件，其中声明了一个全局变量：\n\n```typescript\ndeclare const GLOBAL_VARIABLE: string;\n```\n\n在其他 TypeScript 文件中，你可以直接使用 `GLOBAL_VARIABLE` 而不需要显式导入它：\n\n```typescript\nconsole.log(GLOBAL_VARIABLE); // 此处的类型推导会识别 GLOBAL_VARIABLE 的类型为 string\n```\n\n同样的规则也适用于其他类型的声明，如全局函数、全局类等。\n\n需要注意的是，如果你使用的是第三方库的声明文件，通常你需要使用 `import` 或 `require` 语法导入该库的命名空间或模块，而不是直接使用声明文件中的类型。这是因为第三方库提供的声明文件通常会用命名空间或模块的方式导出类型，而不是全局声明。\n:::warning\n`.d.ts` 文件中的类型声明在 TypeScript 项目中会被自动包含，你可以直接在代码中使用这些类型，无需手动导出或导入。\n:::\n## 无法获取`.d.ts` 文件的类型？\n如无法自动获取`.d.ts` 文件的类型，建议配置 `tsconfig.json` 文件，在编译打包时会自动将类型声明文件加入到编译，此时不用每次导出类型。\n```tsx\n{\n  \"compilerOptions\": {\n   // \n  },\n  \"files\": [\"type.d.ts\"], //配置编译的文件\n  \"include\": [\n    \"src\"\n  ]\n}\n```\n",
      "properties": {
        "title": "declare 和 .d.ts",
        "urlname": "epc7nta9i3wfbegk",
        "date": "2023-09-15 11:08:27",
        "updated": "2023-09-15 11:25:36"
      },
      "catalog": [
        {
          "title": "typescript 入门指南",
          "doc_id": "epc7nta9i3wfbegk"
        },
        {
          "title": "基础开发",
          "doc_id": "epc7nta9i3wfbegk"
        }
      ],
      "body": "",
      "realName": "epc7nta9i3wfbegk",
      "relativePath": "\\epc7nta9i3wfbegk.md"
    },
    {
      "id": 136262450,
      "doc_id": "hd4ini1ztt013yxo",
      "title": "hd4ini1ztt013yxo",
      "updated": 1694571684000,
      "body_original": "在 TypeScript 中，`type` 关键字用于创建类型别名（Type Aliases）。类型别名允许你为一个具体的类型或类型组合定义一个名称，以便在代码中重复使用。\n\n`type` 的作用有以下几个方面：\n\n1.  **类型复用：** 通过类型别名，你可以将一个复杂的类型定义为一个名称，然后在需要使用该类型的地方直接使用该名称。这有助于提高代码的可读性和可维护性。 \n```typescript\ntype User = {\n  name: string;\n  age: number;\n};\n\ntype Callback = (data: User) => void;\n\nfunction fetchData(callback: Callback) {\n  // ...\n}\n```\n\n在上面的例子中，通过类型别名 `User` 和 `Callback` 分别定义了一个用户对象类型和一个回调函数类型，然后在 `fetchData` 函数中使用了这两个类型别名。 \n\n2.  **类型组合：** 类型别名还可以用于组合现有的类型来创建新的类型。这可以通过交叉类型（Intersection Types）和联合类型（Union Types）来实现。 \n```typescript\ntype Point = {\n  x: number;\n  y: number;\n};\n\ntype Color = 'red' | 'green' | 'blue';\n\ntype ColoredPoint = Point & { color: Color };\n\ntype Shape = Square | Circle;\n\ninterface Square {\n  kind: 'square';\n  size: number;\n}\n\ninterface Circle {\n  kind: 'circle';\n  radius: number;\n}\n```\n\n在上述代码中，`ColoredPoint` 类型通过交叉类型将 `Point` 类型和包含 `color` 属性的对象类型组合而成，`Shape` 类型通过联合类型将 `Square` 和 `Circle` 接口组合而成。 \n\n3.  **类型推导（Type Inference）：** 当你使用类型别名初始化变量时，TypeScript 可以推导变量的类型，并将其视为该类型别名所代表的类型。 \n```typescript\ntype Point = {\n  x: number;\n  y: number;\n};\n\nconst origin: Point = { x: 0, y: 0 };\n```\n\n在上面的例子中，通过类型别名 `Point` 定义了一个坐标点类型，然后通过赋值给 `origin` 变量，TypeScript 推导出 `origin` 的类型为 `Point`。 \n\n类型别名的使用使得 TypeScript 中的类型定义更加灵活和可维护。通过使用类型别名，你可以更好地组织和管理代码中的复杂类型，提高代码的可读性和可维护性。\n\n此外，类型别名还可以与其他 TypeScript 的高级类型特性（如泛型、条件类型等）结合使用，进一步增强类型系统的能力。\n## type vs interface\n\n## 表示类型\n`类型别名（type）`是一个定义别名的工具，可以将多个类型组合起来形成一个新类型。比如特定的对象结构，联合类型、函数类型等、**可以表示非对象类型**\n\n可以应用于以下数据类型：\n\n- 基本类型（如字符串、数字、布尔值等）\n- 联合类型（Union Types）\n- 交叉类型（Intersection Types）\n- 元组（Tuple）\n- 函数类型（Function Types）\n- 对象类型（Object Types）\n- 类型字面量（Type Literals）\n- 类型别名的自身引用（Recursive Type Aliases）\n\n`接口（interface）`主要用于定义对象的形状和结构，**只能表示对象类型**\n\n- 对象类型（Object Types）\n- 类类型（Class Types）\n## 继承状态\n\n1. type 不可继承\n2. interface可以继承 class 、interface、type\n",
      "properties": {
        "title": "type 别名",
        "urlname": "hd4ini1ztt013yxo",
        "date": "2023-08-14 21:00:41",
        "updated": "2023-09-13 10:21:24"
      },
      "catalog": [
        {
          "title": "typescript 入门指南",
          "doc_id": "hd4ini1ztt013yxo"
        },
        {
          "title": "基础开发",
          "doc_id": "hd4ini1ztt013yxo"
        }
      ],
      "body": "",
      "realName": "hd4ini1ztt013yxo",
      "relativePath": "\\hd4ini1ztt013yxo.md"
    },
    {
      "id": 133358097,
      "doc_id": "uddiy4ty1tfry4vt",
      "title": "uddiy4ty1tfry4vt",
      "updated": 1694565582000,
      "body_original": "# TypeScript 基础语法\nTypeScript 程序由以下几个部分组成：\n\n- 模块\n- 函数\n- 变量\n- 语句和表达式\n- 注释\n## 第一个 TypeScript 程序\n我们可以使用以下 TypeScript 程序来输出 \"Hello World\" ：\n### Runoob.ts 文件代码：\n```javascript\nconst hello : string = \"Hello World!\"\nconsole.log(hello)\n```\n\n以上代码首先通过 **tsc** 命令编译：\n```javascript\ntsc Runoob.ts\n```\n得到如下 js 代码：\n### Runoob.js 文件代码：\n```javascript\nvarhello = \"Hello World!\"; console.log(hello);\n```\n最后我们使用 node 命令来执行该 js 代码。\n```javascript\nnode Runoob.js  // 输出 Hello World\n```\n整个流程如下图所示：\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1689559326212-36375ee2-91e2-41ac-826d-4dd382725229.png#averageHue=%23fab183&clientId=u1b51deef-a82c-4&from=paste&id=ufcf458d9&originHeight=114&originWidth=582&originalType=url&ratio=2&rotation=0&showTitle=false&size=15574&status=done&style=none&taskId=u732057ab-7cc5-4439-aa82-93a0cf8f18a&title=)\n我们可以同时编译多个 ts 文件：\n```javascript\ntsc file1.ts file2.ts file3.ts\n```\n\n## TypeScript 与面向对象\n面向对象是一种对现实世界理解和抽象的方法。\nTypeScript 是一种面向对象的编程语言。\n面向对象主要有两个概念：对象和类。\n\n- **对象**：对象是类的一个实例（**对象不是找个女朋友**），有状态和行为。例如，一条狗是一\t个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。\n- **类**：类是一个模板，它描述一类对象的行为和状态。\n- **方法**：方法是类的操作的实现步骤。\n\n下图中 **girl、boy** 为类，而具体的每个人为该类的对象：\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1689508371619-9b084e5c-3581-4be2-8d27-a3bb709b8173.png#averageHue=%23ebf0ec&clientId=u9dd074f8-1f39-4&from=paste&id=u75eb17c8&originHeight=454&originWidth=414&originalType=url&ratio=1.600000023841858&rotation=0&showTitle=false&size=214469&status=done&style=none&taskId=uf7ff399b-bdf9-433d-985f-6995c4addca&title=)\nTypeScript 面向对象编程实例：\n```javascript\nclass Site { \n   name():void { \n      console.log(\"Runoob\") \n   } \n} \nvar obj = new Site(); \nobj.name();\n```\n以上实例定义了一个类 Site，该类有一个方法 name()，该方法在终端上输出字符串 Runoob。\nnew 关键字创建类的对象，该对象调用方法 name()。\n编译后生成的 JavaScript 代码如下：\n```javascript\nvar Site = /** @class */ (function () {\n    function Site() {\n    }\n    Site.prototype.name = function () {\n        console.log(\"Runoob\");\n    };\n    return Site;\n}());\nvar obj = new Site();\nobj.name();\n```\n执行以上 JavaScript 代码，输出结果如下:\n:::info\nRunoob\n:::\n\n# 基本类型\n## 原数据类型\n\nJavaScript中的数据类型，可分为两类：\n\n1、原始数据类型（Primitive Data Types），指的是不能再细分修改的数据类型，JavaScript中有 6 种原始数据类型。\n\n2、引用数据类型（Reference Data Types），存储多个值、或复杂对象数据类型，比如object\n\n咱们介绍5种原始数据类型在typeScript中的应用\n\n- Boolean 布尔值\n- String 文本类型\n- Number  数字\n- Array  数组\n- Null 和 Undefined 空和未定义\n\n在定义类似时，通过 `:` 声明数据类型，如：\n\n定义一个布尔值\n\n```typescript\nlet a:string = '1';\nlet b:number = 123;\nlet c:null = null;\nlet d:undefined = undefined;\nlet e:Boolean = false\n\nconsole.log(a,b,c,d,e)\n```\n\n## 特殊类型\n\n## any (任意值)\n\n允许赋值给任意类型\n原则上在typeScript中不允许修改数据类型，咱们可以声明变量 any 类型，使数据为任意类型。\n\n```typescript\nlet e:any = \"yyds\"\ne = 666\nconsole.log('any|e:',e)\n```\n\n## 类型推断\n\n**声明变量、未指定类型，默认是任意类型**\n\n在定义变量时未赋值，会进行类型推断的规则，推断出下一个类型，最终为any类型，如：\n\n```typescript\nlet something;\nsomething = 'seven';\nsomething = 7;\nconsole.log(something)\n// 打印输出 7\n```\n\n## 联合类型\n\n联合类型（union Types） 定义一个变量，可以接收多种类型的值\n\n举个例子，假设你有一个名为result的变量，你希望它可以保存数字或者字符串类型的值。你可以这样声明它的类型：\n\n```typescript\nlet result: number | string;\n```\n\n现在，result变量可以存储数字类型的值，也可以存储字符串类型的值。例如：\n\n```typescript\nresult = 42;       // 保存数字类型的值\nresult = \"Hello\";  // 保存字符串类型的值\n```\n\n使用联合类型，在类型声明中将这两种类型联合起来，表示该变量可以是其中任意一种类型。这就像是给变量指定了多个备选类型。\n\n参考资料\n[https://ts.xcatliu.com/introduction/what-is-typescript.html](https://ts.xcatliu.com/introduction/what-is-typescript.html)\n[https://www.modb.pro/db/617658](https://www.modb.pro/db/617658)\n[https://www.runoob.com/typescript/ts-basic-syntax.html](https://www.runoob.com/typescript/ts-basic-syntax.html)\n",
      "properties": {
        "title": "语法-类型注解",
        "urlname": "uddiy4ty1tfry4vt",
        "date": "2023-07-16 20:03:45",
        "updated": "2023-09-13 08:39:42"
      },
      "catalog": [
        {
          "title": "typescript 入门指南",
          "doc_id": "uddiy4ty1tfry4vt"
        },
        {
          "title": "基础开发",
          "doc_id": "uddiy4ty1tfry4vt"
        }
      ],
      "body": "",
      "realName": "uddiy4ty1tfry4vt",
      "relativePath": "\\uddiy4ty1tfry4vt.md"
    },
    {
      "id": 138951223,
      "doc_id": "el2150t8n7tdkgcp",
      "title": "el2150t8n7tdkgcp",
      "updated": 1694414703000,
      "body_original": "开发中遇到问题，点开表单登记\n注意：填写的认真程度，决定了问题解决速度\n[React问题登记](https://docs.qq.com/form/page/DZUJqQXFrU1drY0dt)\n",
      "properties": {
        "title": "💡问题登记",
        "urlname": "el2150t8n7tdkgcp",
        "date": "2023-09-10 20:40:54",
        "updated": "2023-09-11 14:45:03"
      },
      "catalog": [],
      "body": "",
      "realName": "el2150t8n7tdkgcp",
      "relativePath": "\\el2150t8n7tdkgcp.md"
    },
    {
      "id": 138956175,
      "doc_id": "pfyhe9lm7o95vz3r",
      "title": "pfyhe9lm7o95vz3r",
      "updated": 1694355658000,
      "body_original": "# 问题描述\n使用react脚手架创建项目后，执行npx run eject 报错\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1694354524793-224b7219-886f-45e8-8d01-c1a6353ec45d.png#averageHue=%232d2a20&clientId=u2054a359-5877-4&from=paste&height=191&id=d7KJ2&originHeight=382&originWidth=1408&originalType=binary&ratio=2&rotation=0&showTitle=false&size=438294&status=done&style=none&taskId=u2b12c4a2-5f2b-4d0c-af37-6c9ef002761&title=&width=704)\n# 原因\n`npx create-react-app xxx ` 创建项目时会创建`.gitnore`配置文件，当仓库中代码有更改未提交，会导致 `npx run eject`失败\n# 解决\n1、删除git相关配置文件\n2、初始化git仓库，提交代码\n```typescript\ncd  project\t//进入项目根目录\ngit init　　// 当前目录新建代码库\ngit add .　　// 添加当前目录所有文件到暂存区\ngit commit -m '描述信息'　　// 提交暂存区到仓库区\nnpm run eject\t//项目根目录运行\n```\n\n",
      "properties": {
        "title": "npx run eject 异常",
        "urlname": "pfyhe9lm7o95vz3r",
        "date": "2023-09-10 21:59:19",
        "updated": "2023-09-10 22:20:58"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "pfyhe9lm7o95vz3r"
        }
      ],
      "body": "",
      "realName": "pfyhe9lm7o95vz3r",
      "relativePath": "\\pfyhe9lm7o95vz3r.md"
    },
    {
      "id": 138953526,
      "doc_id": "xgy8xa51aumswod7",
      "title": "xgy8xa51aumswod7",
      "updated": 1694352131000,
      "body_original": "# 问题描述\nwin10电脑安装了cnpm ，cnpm -v 检查版本号没有问题，但是cnpm 下包报错\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1694352119023-6ae792d5-28ce-43d8-827e-1edc74eef30c.png#averageHue=%23525119&clientId=u7fe365d4-7d94-4&from=paste&height=142&id=u3c0ec79e&originHeight=284&originWidth=1459&originalType=binary&ratio=2&rotation=0&showTitle=false&size=290392&status=done&style=none&taskId=u7f44d2f4-b4a4-437b-9082-59d8b1894f2&title=&width=729.5)\n# **解决方案：**\n1、在系统中 搜索框 输入 Windos PowerShell 或者 右击任务栏的电脑图标，选择Windos PowerShell（管理员）；\n2、点击“管理员身份运行”；\n3、输入“ set-ExecutionPolicy RemoteSigned”回车；\n4、根据提示，输入**A**，回车;\n5、再次回到控制台 输入cnpm --version 执行就成功，若不成功，关闭Visual Studio软件重新打开执行就好了。\n",
      "properties": {
        "title": "🚫系统禁止cnpm运行",
        "urlname": "xgy8xa51aumswod7",
        "date": "2023-09-10 21:16:42",
        "updated": "2023-09-10 21:22:11"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "xgy8xa51aumswod7"
        }
      ],
      "body": "",
      "realName": "xgy8xa51aumswod7",
      "relativePath": "\\xgy8xa51aumswod7.md"
    },
    {
      "id": 137979191,
      "doc_id": "tvze4ptzu906v7mh",
      "title": "tvze4ptzu906v7mh",
      "updated": 1694250063000,
      "body_original": "# 一句话总结：\n要更新视图呀，保组件以最新的状态更新。\n# 重新渲染步骤：\n## 重新计算组件的虚拟 DOM 树\n当状态发生变化时，React 会重新计算组件的虚拟 DOM 树。这个过程是高效的，因为 React 使用了一些算法和优化技术，例如虚拟 DOM 的 diff 算法，来尽可能减少计算量。\n## 对比新旧虚拟 DOM 树的差异\nReact 会对比新旧两棵虚拟 DOM 树，并找出其中的差异。这个过程称为协调（reconciliation）。React 会查找需要添加、更新或移除的 DOM 节点，并生成一组操作指令，以最小的代价来实现新旧状态之间的变化。\n## 应用差异到 DOM 上\n根据协调阶段的操作指令，React 会将变化应用到实际的 DOM 上。通过 DOM 操作，更新那些需要改变的元素，使页面显示出最新的状态。\n\n重新渲染的触发机制确保了 React 的响应性和数据驱动的特性。当组件的状态发生改变时，React 会自动管理和更新组件的渲染结果，以确保 UI 的正确展示。\n",
      "properties": {
        "title": "react状态改变，为何触发函数组件重新渲染？",
        "urlname": "tvze4ptzu906v7mh",
        "date": "2023-08-31 22:58:26",
        "updated": "2023-09-09 17:01:03"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "tvze4ptzu906v7mh"
        }
      ],
      "body": "",
      "realName": "tvze4ptzu906v7mh",
      "relativePath": "\\tvze4ptzu906v7mh.md"
    },
    {
      "id": 138348491,
      "doc_id": "qazym151efb8eucb",
      "title": "qazym151efb8eucb",
      "updated": 1694249942000,
      "body_original": "# 什么是tortoiseGit？\nTortoiseGit 是一款window下可视化git管理工具，可以不使用命令行操作git。\n# 问题场景\n修改 git仓库账号密码后，提交代码失败。\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1694249776534-a7d33d63-78b4-41f4-95c3-488cf695110a.png#averageHue=%23f4f2f1&clientId=uc629d2b5-0020-4&from=paste&height=471&id=ue68c2789&originHeight=942&originWidth=1479&originalType=binary&ratio=2&rotation=0&showTitle=false&size=181326&status=done&style=none&taskId=uda55ec1b-ccf8-4a02-8639-5c8ef0f0a81&title=&width=739.5)\n# 解决步骤\n\n　　1、打开电脑上面的控制面板，右侧查看方式调整为“小图标”，找到其中的“凭据管理器”，并点击进入；\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1693882946248-c302c7b1-bb4c-433c-a05a-7e24bee30c34.png#averageHue=%23edede3&clientId=ua95c5b5e-64ec-4&from=paste&height=531&id=ub3ec1e79&originHeight=1062&originWidth=1510&originalType=binary&ratio=2&rotation=0&showTitle=false&size=962713&status=done&style=none&taskId=u97a3497d-66b7-4fde-956a-c2350197e7a&title=&width=755)\n\n2、进入凭据管理器之后，选择其中的“Windows凭据”，点击进入；然后点击凭据中的要修改密码的git地址；\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1693881328345-d5b00fd8-2201-42a1-a26c-adbc7bd17f50.png#averageHue=%23fbfbfa&clientId=u04f236c0-71a6-4&from=paste&height=595&id=u6666779a&originHeight=1189&originWidth=2256&originalType=binary&ratio=2&rotation=0&showTitle=false&size=156845&status=done&style=none&taskId=uc9339fe3-324d-457f-a8a1-46a23b39450&title=&width=1128)\n\n3、此时，就会出现该git地址的具体信息，包括用户名和密码，点击下面的“编辑”按钮；\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1693883045253-cc6c2784-4517-47a8-a436-6a2b8d80ee81.png#averageHue=%23fbfbfb&clientId=ua95c5b5e-64ec-4&from=paste&height=595&id=ua2133de5&originHeight=1189&originWidth=2256&originalType=binary&ratio=2&rotation=0&showTitle=false&size=159667&status=done&style=none&taskId=ub8171b6c-bad7-4399-a9ac-239c3186ebb&title=&width=1128)\n\n4、然后就可以修改该git地址下对应的账号密码了；账号密码修改完成之后，点击下面的“保存”按钮即可生效，如图所示；\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1693883063279-2709f545-e72b-41e2-a045-c3757bab302c.png#averageHue=%23fdfcfc&clientId=ua95c5b5e-64ec-4&from=paste&height=338&id=ub4129247&originHeight=675&originWidth=1477&originalType=binary&ratio=2&rotation=0&showTitle=false&size=34606&status=done&style=none&taskId=ubdc6bc23-5396-4dc3-bc65-fe3377ce7a3&title=&width=738.5)\n\n5、修改了账号密码之后，使用git命令行或者直接使用TortoiseGit可视化工具进行pull，push等操作时，提示没有权限，均可解决。 \n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1693883486862-b0cf38fa-c482-415f-82d1-538658f8bb35.png#averageHue=%23f2f0f0&clientId=ua95c5b5e-64ec-4&from=paste&height=556&id=u5f29b0bd&originHeight=1112&originWidth=1288&originalType=binary&ratio=2&rotation=0&showTitle=false&size=117668&status=done&style=none&taskId=u0f96b474-c5dc-4594-92fc-2c32768d82f&title=&width=644)\n",
      "properties": {
        "title": "TortoiseGit 账号密码更改失效",
        "urlname": "qazym151efb8eucb",
        "date": "2023-09-05 10:33:43",
        "updated": "2023-09-09 16:59:02"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "qazym151efb8eucb"
        }
      ],
      "body": "",
      "realName": "qazym151efb8eucb",
      "relativePath": "\\qazym151efb8eucb.md"
    },
    {
      "id": 135196146,
      "doc_id": "ziabxi0gm6yoh8gy",
      "title": "ziabxi0gm6yoh8gy",
      "updated": 1694069782000,
      "body_original": "[理解 React 中的 useEffect、useMemo 与 useCallback - guangzan - 博客园](https://www.cnblogs.com/guangzan/p/17329688.html#useeffect-%E7%9A%84%E5%AE%9E%E7%8E%B0)\n",
      "properties": {
        "title": "手写hooks",
        "urlname": "ziabxi0gm6yoh8gy",
        "date": "2023-08-03 15:02:04",
        "updated": "2023-09-07 14:56:22"
      },
      "catalog": [
        {
          "title": "react源码解析",
          "doc_id": "ziabxi0gm6yoh8gy"
        }
      ],
      "body": "",
      "realName": "ziabxi0gm6yoh8gy",
      "relativePath": "\\ziabxi0gm6yoh8gy.md"
    },
    {
      "id": 138579162,
      "doc_id": "ze2ns8tfg1huvi1m",
      "title": "ze2ns8tfg1huvi1m",
      "updated": 1694058803000,
      "body_original": "[深入理解React：懒加载（lazy）实现原理 - OneForCheng - 博客园](https://www.cnblogs.com/forcheng/p/13132582.html)\n[React避免子组件无效刷新的三种解决方案_React_脚本之家](https://m.jb51.net/javascript/293823lsw.htm)\n",
      "properties": {
        "title": "React 深入理解",
        "urlname": "ze2ns8tfg1huvi1m",
        "date": "2023-09-07 11:04:56",
        "updated": "2023-09-07 11:53:23"
      },
      "catalog": [
        {
          "title": "react源码解析",
          "doc_id": "ze2ns8tfg1huvi1m"
        }
      ],
      "body": "",
      "realName": "ze2ns8tfg1huvi1m",
      "relativePath": "\\ze2ns8tfg1huvi1m.md"
    },
    {
      "id": 137967656,
      "doc_id": "yuv23ww09883c08k",
      "title": "yuv23ww09883c08k",
      "updated": 1694052969000,
      "body_original": "useRef 是react中的一个hooks，用于管理函数组件中引用状态，防止组件刷新后重新创建引用对象。\nuseRef方法 返回一个 useRef 对象，包含 current 属性，默认值是null，存储在current属性的数据。发生值改变时不会触发组件渲染。\n# 使用场景\n使用 useRef 可以在以下场景下发挥作用：\n\n1. 获取 DOM 元素的引用：useRef 可以用来获取渲染后的 DOM 元素的引用，类似于类组件中的 ref 属性的作用。\n2. 保存组件的内部状态：由于 useRef 返回的引用在组件重新渲染时保持不变，我们可以使用 useRef 来存储和访问组件的内部状态，而不触发组件的重新渲染。\n3. 与其他 React 特性交互：useRef 可以与其他 React 特性（如动画库、焦点管理库等）进行交互，以便操作 DOM 或组件的状态。\n# 注意\nref和useRef两者都很容易被滥用，会造成使用开销比较大。\n`ref` 和 `useRef`都是 React 提供的用于引用 DOM 元素或其他值的机制。它们的滥用可能会导致性能问题和代码可读性下降。\n# 滥用场景\n\n以下是滥用 `ref` 和 `useRef` 的一些常见情况：\n\n1. 过度使用 `ref`：在 React 中，应该尽量避免直接操作 DOM 元素。如果过度使用 `ref`，可能会导致代码难以维护和理解。应该优先考虑使用 React 的状态和属性来管理组件的行为和状态。\n\n2. 频繁更新 `ref`：如果在每次渲染时都更新 `ref`，可能会导致性能问题。因为每次更新 `ref` 都会触发组件重新渲染，这可能会导致不必要的性能开销。\n\n3. 不正确地使用 `useRef`：`useRef` 返回的是一个可变的引用对象，如果不正确地使用它，可能会导致一些问题。例如，如果将 `useRef` 用于保存组件的状态，而不是使用 `useState`，可能会导致状态不正确地更新。\n\n# 遵循规则\n为了避免滥用 `ref` 和 `useRef`，应该遵循以下准则：\n\n1. 尽量避免直接操作 DOM 元素，而是使用 React 的状态和属性来管理组件的行为和状态。\n\n2. 只在必要时使用 `ref`，并确保在更新 `ref` 时进行优化。\n\n3. 理解 `useRef` 的正确用法，并避免将其用于保存组件的状态。\n\n通过遵循这些准则，可以避免滥用 `ref` 和 `useRef`，从而减少使用开销并提高代码的可读性和可维护性。\n\n# \n\n",
      "properties": {
        "title": "为什么少用 ref 和 useRef 呢？",
        "urlname": "yuv23ww09883c08k",
        "date": "2023-08-31 20:15:38",
        "updated": "2023-09-07 10:16:09"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "yuv23ww09883c08k"
        }
      ],
      "body": "",
      "realName": "yuv23ww09883c08k",
      "relativePath": "\\yuv23ww09883c08k.md"
    },
    {
      "id": 136004688,
      "doc_id": "gixzk15x3uz194ir",
      "title": "gixzk15x3uz194ir",
      "updated": 1693825610000,
      "body_original": "# tsconfig.json (Ts配置文件)\n\n`tsconfig.json` 是ts项目中配置文件。在项目根目录，如果项目中有 `tsconfig.json`, `TypeScript`  则认为这是项目的根目录。\n\n如果项目源码是 `JavaScript`，但是相用 `typescript` 处理，那配置文件的名字是`jsconfig.json` ,和 `tsconfig` 的写法一样。\n\n## 指定 `tsconfig.json` 目录\n\n命令行参数--project或-p可以指定tsconfig.json的位置（目录或文件皆可）。\n\n如果不指定 `tsconfig.json`, `tsc` 会在当前目录搜索 `tsconfig.json` 文件，如果不存在，就到上一级目录搜索，直到找到为止。\n\n`tsconfig.json` 文件格式，是一个 JSON 对象，简单到只可以放一个空对象 `{}`, 示例如下：\n\n```typescript\n{\n    \"compilerOptions\":{\n        \"outDir\":\"./built\",\n        \"allowJs\":true,\n        \"target\":\"es5\"\n    },\n    \"include\":[\"./src/**/*\"]\n}\n```\n\n`tsconfig.json` 文件中有很多属性，这样简单说下上面四个属性的含义\n\n- `outDir` 指定编译文件存放的目录\n- `allowJs` 指定源目录的 `JavaScript` 文件是否原样拷贝到编译后的目录\n- `target` 指定编译产物的js版本\n- `include` 指定那些文件需要编译\n\n`tsconfig.json` 文件可以不必手写，使用 tsc 命令的 `--init` 参数自动生成\n\n```typescript\ntsc --init\n```\n\n# tsconfig 一级属性\n\ntsconfig.json的一级属性并不多，只有很少几个，但是compilerOptions属性有很多二级属性。\n\n先介绍下一级属性\n\n## 1、include\n\n`include` 属性指定所要编译的文件列表，既支持逐一列出文件，也支持通配符。文件位置相对于当前配置文件而定。\n\n```typescript\n{\n  \"include\": [\"src/**/*\", \"tests/**/*\"]\n}\n```\n\ninclude属性支持三种通配符。\n\n- ?：指代单个字符\n- *：指代任意字符，不含路径分隔符\n- **：指定任意目录层级。\n\n如果不指定文件后缀名，默认包括.ts、.tsx和.d.ts文件。如果打开了allowJs，那么还包括.js和.jsx。\n\n## 2、exclude\n`exclude` 属性是一个数组，必须与 `include` 属性一起使用，用来从编译列表中去除指定的文件，同样支持和 `include` 属性相同的通配符。\n```typescript\n{\n    \"include\":[\"**/*\"], // 指定那些文件需要编译\n    \"exclude\":[\"**/*.spec.ts\"] // 从编译列表中去除指定文件\n}\n```\n\n## 3、extends\n如果一个项目有多个配置文件，可以将共同的配置写在 `tsconfig.base.json` `tsconfig.json` 可以继承另一个 `tsconfig.json` 文件的配置,这样方便维护。\n\n```typescript\n{\n    \"extends\":\"../tsconfig.base.json\"\n}\n```\n\n如果 `extends` 属性指定的路径如不是以`./` 或者 `../`开头，那么编译器将在`node_modules` 目录下查找指定的配置文件。\n\n`extends` 属性也可也继承已发布的npm模块里面的tsconfig文件\n\n```typescript\n{\n    \"extends\":\"@tsconfig/node12/tsconfig.json\"\n}\n```\n\n`extends` 指定的 `tsconfig.json` 会先加载，然后加载当前的 `tsconfig.json` 。如果两者有重名的属性，后者会覆盖前者。\n\n## 4、files\n\n`files` 属性指定编译的文件列表，如果其中一个文件不存在，就会报错。\n它是一个数组，排在前面的文件先编译。\n\n```typescript\n{\n    \"files\":[\"a.ts\",\"b.ts\"]\n}\n```\n\n该属性必须逐一列出文件，不支持文件匹配，如果文件比较多建议使用 `include` 和 `exclude` 属性。\n\n## 5、references\n`references` 属性是一个数组，数组成员为对象，适合一个大项目由多个小项目构成的情况，用来设置需要引用的底层项目。\n\n```typescript\n    {\n        \"references\":[\n            {\"path\":\"../pkg1\"},\n            {\"path\":\"../pkg2/tsconfig.json\"}\n        ]\n    }\n```\n# lesson 1实战\n\n1. 1. 使用create-react-app project --template typescript创建脚手架\n```javascript\n create-react-app project --template typescript\n```\n\n2. 2. 正确生成tsConfig.json文件 tsc --init\n```javascript\ntsc --init // 使用上面脚手架创建后，项目中自动生成tsconfig.json 文件\n```\n\n3. 3. 正确配置打包dist命令\n\n 先创建config配置目录，输入以下命令\n```javascript\nnpm eject\n```\n打开config目录，config/paths.js 更改打包目录为 dist\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1691804302211-fdff8b81-fdb5-4ff3-a89e-3b535dc67b41.png#averageHue=%2322201e&clientId=u39cf4c6b-52df-4&from=paste&height=185&id=u84fc4126&originHeight=416&originWidth=2076&originalType=binary&ratio=2.25&rotation=0&showTitle=false&size=119711&status=done&style=none&taskId=u6c9c4041-faf4-45a8-856e-20f490797a7&title=&width=922.6666666666666)\n\n4. 4. 正确配置ts文件监听\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1691804637680-2a21dc1b-7e8f-4db3-8b58-2f81126ef639.png#averageHue=%231f1d1d&clientId=u39cf4c6b-52df-4&from=paste&height=224&id=u9d25b759&originHeight=504&originWidth=2048&originalType=binary&ratio=2.25&rotation=0&showTitle=false&size=93546&status=done&style=none&taskId=uadd2715e-a7d4-4c5e-9e1a-b275e4b88de&title=&width=910.2222222222222)\n\n5. 5. 配置打包出口文件\n```javascript\n// 如上和第三题一样\n```\n\n6. 6. 配置incloude以及excloude\n```javascript\n{\n  \"include\":[\"src/**/*\"], //指定所要编译的文件列表\n  \"exclude\": [\"**/*.spec.ts\"]//从编译列表中去除指定的文件\n}\n```\n\n7. 7. 用ts语法声明一个枚举示例\n```javascript\nenum user{\n  age,\n  name,\n  sex\n}\n```\n\n8. 8. 定义类型不可使用any；\n```javascript\n// 不要用any any any！！！\n```\n\n9. 9. 写出ts的基础类型 以及ts新增类型 写明注释\n```javascript\n// 布尔值\nlet isDone: boolean = false;\n\n// 数字\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\nlet binaryLiteral: number = 0b1010;\nlet octalLiteral: number = 0o744;\n\n// 字符串\nlet name: string = `Gene`;\nlet sentence: string = `Hello, my name is ${ name }.`\n\n// 数组\nlet list: number[] = [1, 2, 3];\nlet list: Array<number> = [1, 2, 3]; // 数组泛型，Array<元素类型>\n\n// 元组 Tuple\nlet x: [string, number];\nx = ['hello', 10];\n```\n\n10. 10. 自行定义ts 的元组类型\n```javascript\n// 定义一个具有固定长度为2的元组类型\ntype MyTuple = [string, number];\n\n// 声明一个变量并指定其类型为自定义的元组类型\nlet myTuple: MyTuple;\n\n// 初始化元组变量\nmyTuple = ['hello', 123]; // 正确\nmyTuple = ['world', 456];\n```\n\n11. 11. 实现元组数据存在多种类型的定义\n```javascript\n//myTuple 是一个包含三个元素的元组。第一个元素的类型是 number，第二个元素的类型是 string，第三个元素的类型是 boolean。\nlet myTuple: [number, string, boolean] = [42, \"Hello\", true];\n\n```\n\n12. 12. 简单实现去重效果[1,1,1,2,2,2,3]=>[1,2,3]\n```javascript\n// 最快速去重 new set() ,注意 set只能去除基本类型，无法去重引用类型，如对象，因为应用类型值相同无法去重\n\nnew Set([1,1,1,2,2,2,3])\n```\n\n13. 13. 正确实现函数调用且正确给出函数返回值的类型\n```javascript\nconst add = (a: number, b: number): number => {\n  return a + b;\n}\n```\n\n14. 14. 正确实现效果无bug；\n```javascript\n不要出bug！！！！！\n```\n\n15. 15. 添加必要的思路注释\n```javascript\n记得写下代码注释，比如声明一个包含xx类型的数据结构\n```\n\n16. 16. 录制效果视频正确讲解并标黄；\n\n",
      "properties": {
        "title": "tsconfig.json 配置文件详解 | 02",
        "urlname": "gixzk15x3uz194ir",
        "date": "2023-08-11 17:10:06",
        "updated": "2023-09-04 19:06:50"
      },
      "catalog": [
        {
          "title": "typescript 入门指南",
          "doc_id": "gixzk15x3uz194ir"
        }
      ],
      "body": "",
      "realName": "gixzk15x3uz194ir",
      "relativePath": "\\gixzk15x3uz194ir.md"
    },
    {
      "id": 137979552,
      "doc_id": "vigtgkots2lu6bb1",
      "title": "vigtgkots2lu6bb1",
      "updated": 1693494304000,
      "body_original": "React 是一个用于构建用户界面的 JavaScript 库，它具有一些核心原理和概念，让开发者可以高效地构建可维护和可扩展的应用程序。下面是 React 中的一些关键原理：\n\n1. 虚拟 DOM（Virtual DOM）: React 使用虚拟 DOM 来描述 UI 的状态和结构。虚拟 DOM 是一个轻量级的抽象，它在内存中以树形结构存在，并与实际的 DOM 元素一一对应。当组件的状态发生变化时，React 会通过比较新旧虚拟 DOM 的差异，来计算最小的 DOM 更新操作，以提高性能。\n2. 组件和组件化: React 通过组件的概念来构建复杂的 UI。组件是 UI 的一部分，可以被独立地定义、组合和复用。组件封装了自己的状态和行为，并通过输入（props）和输出（渲染结果）与其他组件进行交互。组件的组合性使得开发者能够构建可重用和可组合的 UI 界面。\n3. 单向数据流: React 遵循一种单向数据流的数据管理模式。父组件通过传递属性（props）给子组件来进行数据的传递，子组件无法直接修改父组件的数据，而是通过触发事件（事件处理函数）通知父组件去修改数据（通过回调函数）。这种单向数据流确保了数据的可控性和可预测性。\n4. 生命周期方法: 组件在不同的阶段会触发不同的生命周期方法。例如，组件被创建时会触发 componentDidMount 方法，组件被更新时会触发 componentDidUpdate 方法，组件即将被销毁时会触发 componentWillUnmount 方法等。开发者可以通过这些生命周期方法来执行相应的操作，例如数据获取、状态更新等。\n5. 虚拟 DOM 的协调和批量更新: React 使用一种高效的算法来计算虚拟 DOM 树的差异并进行批量更新。这个算法被称为协调（reconciliation），它能够最小化 DOM 操作的次数和范围，以提高性能。\n6. Hooks: 在 React 16.8 版本引入了 Hooks，它是一种能够让函数组件拥有状态和其他特性的解决方案。Hooks 提供了一系列的钩子函数，例如 useState、useEffect、useContext 等，用于在函数组件中管理状态、执行副作用或访问上下文等操作。\n",
      "properties": {
        "title": "react导读",
        "urlname": "vigtgkots2lu6bb1",
        "date": "2023-08-31 23:04:50",
        "updated": "2023-08-31 23:05:04"
      },
      "catalog": [],
      "body": "",
      "realName": "vigtgkots2lu6bb1",
      "relativePath": "\\vigtgkots2lu6bb1.md"
    },
    {
      "id": 135192127,
      "doc_id": "gx7xpdd7oom87eeu",
      "title": "gx7xpdd7oom87eeu",
      "updated": 1693817201000,
      "body_original": "# 本地文件上传\n## 环境安装\n\n1.  Koa \n   - 作用：Koa是一个Node.js的Web框架，用于构建Web应用程序。它提供了一种简洁而灵活的方式来处理HTTP请求和响应。\n   - npm地址：[https://www.npmjs.com/package/koa](https://www.npmjs.com/package/koa)\n2.  Koa-Router \n   - 作用：Koa Router是Koa框架的路由中间件，用于定义和处理路由。\n   - npm地址：[https://www.npmjs.com/package/koa-router](https://www.npmjs.com/package/koa-router)\n3.  @koa/multer \n   - 作用：@koa/multer是一个用于处理文件上传的Koa中间件。它基于Multer库，提供了方便的文件上传功能。\n   - npm地址：[https://www.npmjs.com/package/@koa/multer](https://www.npmjs.com/package/@koa/multer)\n   - Multer\n\nMulter 是一个node.js中间件，用于处理 multipart/form-data类型的表单数据，主要用于上传文件。\n在form表单上要加上 enctype=“multipart/form-data” 的属性。\nMulter 不会处理任何非 multipart/form-data 类型的表单数据。\n不要将 Multer 作为全局中间件使用，因为恶意用户可以上传文件到一个你没有预料到的路由，应该只在你需要处理上传文件的路由上使用。\n\n4.  path \n   - 作用：Node.js的内置模块，用于处理文件路径，提供了一些实用的函数来操作和解析文件路径。\n   - npm地址：这是Node.js的内置模块，不需要通过npm安装，可以直接使用。\n5.  @koa/cors \n   - 作用：@koa/cors是一个Koa中间件，用于处理CORS（跨源资源共享）请求，允许不同域之间的跨域请求。\n   - npm地址：[https://www.npmjs.com/package/@koa/cors](https://www.npmjs.com/package/@koa/cors)\n6.  koa-body \n   - 作用：koa-body是一个Koa中间件，用于解析HTTP请求的请求体，并将解析的数据附加到Koa的上下文中。\n   - npm地址：[https://www.npmjs.com/package/koa-body](https://www.npmjs.com/package/koa-body)\n7.  koa-static \n   - 作用：koa-static是一个Koa中间件，用于提供静态文件服务，可以将指定目录下的静态资源（如HTML、CSS、JavaScript文件）提供给客户端访问。\n   - npm地址：[https://www.npmjs.com/package/koa-static](https://www.npmjs.com/package/koa-static)\n\n\n## 注意事项！！\n文件本地上传环境配置，顺序要求如下：\n```javascript\napp.use(cors()) //1、先配置跨越\napp.use(router);// 2、应用路由（使用koa-Router）\napp.use(koaBody({ //3、解析请求内容请求数据\n    multipart:true,\n  \n}))\n// 4、、\n```\n参考链接\n[https://jelly.jd.com/article/5e734631affa8301490877f1](https://jelly.jd.com/article/5e734631affa8301490877f1)\n[https://segmentfault.com/a/1190000008899001](https://segmentfault.com/a/1190000008899001)\n[https://mp.weixin.qq.com/s/y_UwDtB1TsNNfWs5hJVGdA](https://mp.weixin.qq.com/s/y_UwDtB1TsNNfWs5hJVGdA)\n",
      "properties": {
        "title": "react+node 本地大文件分片上传、断点续传",
        "urlname": "gx7xpdd7oom87eeu",
        "date": "2023-08-03 14:41:19",
        "updated": "2023-09-04 16:46:41"
      },
      "catalog": [
        {
          "title": "案例开发",
          "doc_id": "gx7xpdd7oom87eeu"
        },
        {
          "title": "本地上传+阿里云oss",
          "doc_id": "gx7xpdd7oom87eeu"
        }
      ],
      "body": "",
      "realName": "gx7xpdd7oom87eeu",
      "relativePath": "\\gx7xpdd7oom87eeu.md"
    },
    {
      "id": 137868628,
      "doc_id": "fsntec83rv65ub1e",
      "title": "fsntec83rv65ub1e",
      "updated": 1693445749000,
      "body_original": "[react使用hook——useState的坑](https://segmentfault.com/a/1190000040013137)\n",
      "properties": {
        "title": "hooks使用注意事项",
        "urlname": "fsntec83rv65ub1e",
        "date": "2023-08-31 09:35:13",
        "updated": "2023-08-31 09:35:49"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "fsntec83rv65ub1e"
        }
      ],
      "body": "",
      "realName": "fsntec83rv65ub1e",
      "relativePath": "\\fsntec83rv65ub1e.md"
    },
    {
      "id": 137854318,
      "doc_id": "dtgppmg1dymqgsde",
      "title": "dtgppmg1dymqgsde",
      "updated": 1694250735000,
      "body_original": "# 前言\n多文件上传本质是循环存储的过程，只是在实现方式有所区别，\n实现方式：\n\n- 前端批量上传：前端轮询调用后端单文件上传接口\n- 后端批量存储：一次性接收前端多文件，循环存储\n# 组件 vs 定制化\nantd中的upload组件功能强大，支持文件夹、拖拽、自动上传、ui美观，文档完善，通过简单配置即可开发完功能，以功能为主的开发，建议使用组件完成\n\n如果定制化功能，业务交互复杂，建议手写上传功能，其本质将file类型的数据，以fomdata的格式发送给后端。\n\n如实现多文件上传，建议搭配promise使用，promise.all() 可等待多个异步操性、结合此特性实现批量上传的效果。\n\n# 示例代码\n## antd-upload自动上传\n```tsx\n// 初始化 上传组件的列表数据\nconst [fileList, setFileList] = useState<UploadFile[]>([]);\n// uoload 组件配置项\nconst props = {\n    beforeUpload: (file: File) => {\n      if (file.size > maxFileSize) {\n        message.warning('文件最多上传1m')\n        return Upload.LIST_IGNORE\n      }\n      // console.log(file, 'file')\n      // const isPNG = file.type === 'image/png';\n      // if (!isPNG) {\n      //   message.error(`${file.name} is not a png file`);\n      // }\n      // return isPNG || Upload.LIST_IGNORE;\n      // return true\n    },\n    action: 'http:///localhost:9981/upload_oss',/// 接口地址 oss or 本地\n    onChange: handleChange,\n    multiple: true,\n  };\n// upload 组件change事件\n const handleChange: UploadProps['onChange'] = (info) => {\n\n    console.log('oonchang', info)\n    let newFileList = [...info.fileList];\n \n    newFileList = newFileList.map((file) => {\n      if (file.response) {\n        // Component will show file.url as link\n        file.url = file.response.url;\n      }\n      return file;\n    });\n\n    setFileList(newFileList);\n  };\n// 支持拖拽的上传组件\n<Dragger height={70}   {...props} fileList={fileList} listType=\"picture\">\n  <p>支持拖拽上传</p>\n</Dragger>\n```\n## antd-upload +promise.all 批量上传\n\n```tsx\n  // 封装上传函数\n  const uploadFiles = (file: any) => {\n    console.log('file', file)\n    const formData = new FormData()\n    formData.append('file', file.originFileObj)\n    return new Promise((resolve, rejects) => {\n      request.post('/upload_oss', formData).then((response) => {\n        resolve(response.data.imgUrl)\n        message.success(`${file.name} 以上传成功`)\n        console.log('startFileList', startFileList)\n      }).catch((err) => {\n        rejects(err)\n      })\n    })\n  }\n\n  // 提交上传\n  const multipleUpload = async () => {\n    const uploadPromiess = startFileList.map((file) => uploadFiles(file))\n    let imgs = await Promise.all(uploadPromiess)\n    console.log('全部上传成功', imgs)\n  }\n\t// 上传组件chang事件 \n  const handleChange1: UploadProps['onChange'] = (info) => {\n\n    let newFileList = [...info.fileList]; \n    console.log('触发了')\n    newFileList = newFileList.map((file) => {\n  \n        // Component will show file.url as link \n        try {\n          // file 生成临时的url\n          file.url = URL.createObjectURL(file.originFileObj as RcFile);\n\n        } catch (error) {\n          \n        }\n      \n      return file;\n    });\n    console.log('oonchang', newFileList)\n    // 更新\n    setStrartFileList(newFileList);\n  };\n\n<Upload  {\n  ...{\n    multiple: true,\n    maxCount: 10,\n    fileList: startFileList,\n    onRemove: (file) => {\n      const index = startFileList.indexOf(file);\n      const newFileList = startFileList.slice();\n      newFileList.splice(index, 1);\n      // setStrartFileList([]);\n    },\n    beforeUpload: (file: any) => {\n      console.log('filelist', startFileList);\n      // return Upload.LIST_IGNORE - 文件不进行回显\n      // return false 关闭上传请求\n      return false\n    },\n    listType: 'picture',\n    onChange: handleChange1\n  }\n}>\n</Upload>\n  <Button >  选择文件</Button><br></br>  <div> <p> 以选中{startFileList.length}个文件，已上传</p></div>\n    <Button onClick={multipleUpload}>提交</Button>\n```\n",
      "properties": {
        "title": "antd 实现批量上传",
        "urlname": "dtgppmg1dymqgsde",
        "date": "2023-08-30 23:21:56",
        "updated": "2023-09-09 17:12:15"
      },
      "catalog": [
        {
          "title": "案例开发",
          "doc_id": "dtgppmg1dymqgsde"
        },
        {
          "title": "本地上传+阿里云oss",
          "doc_id": "dtgppmg1dymqgsde"
        }
      ],
      "body": "",
      "realName": "dtgppmg1dymqgsde",
      "relativePath": "\\dtgppmg1dymqgsde.md"
    },
    {
      "id": 137512492,
      "doc_id": "dcdb8p31qp8y4zes",
      "title": "dcdb8p31qp8y4zes",
      "updated": 1693184200000,
      "body_original": "## 环境配置\n### 账号开通\n\n- 开通阿里云oss [阿里云登录 - 欢迎登录阿里云，安全稳定的云计算服务平台](https://oss.console.aliyun.com/bucket)\n- 生成 accessKey 和 secret 用于初始oss [阿里云登录 - 欢迎登录阿里云，安全稳定的云计算服务平台](https://ram.console.aliyun.com/manage/ak?spm=a2c8b.12215393.top-nav.dak.6c12336aYGPYmv)\n### node 安装包\n```tsx\n// 下载 Koa 模块\nnpm install koa\n// 下载 Koa Router 模块 https://www.npmjs.com/package/koa-Router[包含示例代码]\nnpm install koa-router\n// 下载 @koa/cors 模块\nnpm install @koa/cors\n// 下载 ali-oss 模块\nnpm install ali-oss\n// 下载 koa-body 模块\nnpm install koa-body \n```\n## alioss 核心操作接口\n### 上传本地文件\n过put接口将本地文件上传到OSS\n```\nconst OSS = require('ali-oss')\nconst path = require(\"path\")\n\nconst client = new OSS({\n  // yourregion填写Bucket所在地域。以华东1（杭州）为例，Region填写为oss-cn-hangzhou。\n  region: 'yourregion',\n  // 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。\n  accessKeyId: 'yourAccessKeyId',\n  accessKeySecret: 'yourAccessKeySecret',\n  // 填写Bucket名称。\n  bucket: 'examplebucket',\n});\n\nconst headers = {\n  // 指定Object的存储类型。\n  'x-oss-storage-class': 'Standard',\n  // 指定Object的访问权限。\n  'x-oss-object-acl': 'private',\n  // 通过文件URL访问文件时，指定以附件形式下载文件，下载后的文件名称定义为example.jpg。\n  // 'Content-Disposition': 'attachment; filename=\"example.jpg\"'\n  // 设置Object的标签，可同时设置多个标签。\n  'x-oss-tagging': 'Tag1=1&Tag2=2',\n  // 指定PutObject操作时是否覆盖同名目标Object。此处设置为true，表示禁止覆盖同名Object。\n  'x-oss-forbid-overwrite': 'true',\n};\n\nasync function put () {\n  try {\n    // 填写OSS文件完整路径和本地文件的完整路径。OSS文件完整路径中不能包含Bucket名称。\n    // 如果本地文件的完整路径中未指定本地路径，则默认从示例程序所属项目对应本地路径中上传文件。\n    const result = await client.put('exampleobject.txt', path.normalize('D:\\\\localpath\\\\examplefile.txt')\n    // 自定义headers\n    //,{headers}\n    );\n    console.log(result);\n  } catch (e) {\n    console.log(e);\n  }\n}\n\nput();\n```\n### 分片上传\n",
      "properties": {
        "title": "阿里云oss基础使用",
        "urlname": "dcdb8p31qp8y4zes",
        "date": "2023-08-28 08:48:51",
        "updated": "2023-08-28 08:56:40"
      },
      "catalog": [
        {
          "title": "案例开发",
          "doc_id": "dcdb8p31qp8y4zes"
        },
        {
          "title": "本地上传+阿里云oss",
          "doc_id": "dcdb8p31qp8y4zes"
        }
      ],
      "body": "",
      "realName": "dcdb8p31qp8y4zes",
      "relativePath": "\\dcdb8p31qp8y4zes.md"
    },
    {
      "id": 137454519,
      "doc_id": "lhkxca986wzmi9s3",
      "title": "lhkxca986wzmi9s3",
      "updated": 1693183721000,
      "body_original": "## react中使用echarts\n```tsx\nimport { useRef, useEffect } from 'react';\nimport * as echarts from 'echarts/core';\nimport { GridComponent, GridComponentOption } from 'echarts/components';\nimport { LineChart, LineSeriesOption } from 'echarts/charts';\nimport { UniversalTransition } from 'echarts/features';\nimport { CanvasRenderer } from 'echarts/renderers';\n\n// 导入所需要的echarts组件和特性\n\necharts.use([GridComponent, LineChart, CanvasRenderer, UniversalTransition]);\n\n// 定义ECharts的配置类型\ntype EChartsOption = echarts.ComposeOption<\n  GridComponentOption | LineSeriesOption\n>;\n\n// 定义ECharts的配置选项\nconst option: EChartsOption = {\n  xAxis: {\n    type: 'category',\n    boundaryGap: false,\n    data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],\n  },\n  yAxis: {\n    type: 'value',\n  },\n  series: [\n    {\n      data: [820, 932, 901, 934, 1290, 1330, 1320],\n      type: 'line',\n      areaStyle: {},\n    },\n  ],\n};\n\nconst Main = () => {\n  const chartRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    // 避免在同一个 DOM 元素上多次创建 ECharts 实例\n    if (chartRef.current) {\n      const chart = echarts.getInstanceByDom(chartRef.current) || echarts.init(chartRef.current);\n      chart.setOption(option);\n      return () => {\n        chart.dispose();\n      };\n    }\n  }, []);\n\n  return (\n    <div>\n      home 入口文件\n      <div ref={chartRef} style={{ width: '400px', height: '400px' }} />\n    </div>\n  );\n};\n\nexport default Main;\n\n```\n## 封装echart组件\n\n## 封装echart hooks\n",
      "properties": {
        "title": "react+echarts",
        "urlname": "lhkxca986wzmi9s3",
        "date": "2023-08-27 10:03:18",
        "updated": "2023-08-28 08:48:41"
      },
      "catalog": [
        {
          "title": "案例开发",
          "doc_id": "lhkxca986wzmi9s3"
        }
      ],
      "body": "",
      "realName": "lhkxca986wzmi9s3",
      "relativePath": "\\lhkxca986wzmi9s3.md"
    },
    {
      "id": 137465899,
      "doc_id": "gbwx6y5p60i7wv4g",
      "title": "gbwx6y5p60i7wv4g",
      "updated": 1693115174000,
      "body_original": "# 前端\n- react+t、redux、antd、react-router、socket\n# 后端\n\n- koa、alioss、alipay、soketIo\n\n# 核心模块\n![](https://gyg-bawei-gz4-01.oss-cn-beijing.aliyuncs.com/vuepress/image-20230827000506923.png#id=NyCtt&originHeight=1013&originWidth=2100&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n## 项目适配eslint\n### **技术项**\n\n- eslint+prettier+husky+commitizen\n### **提薪点**\n\n1. 项目规范-eslint+prettier+husky+commitizen\n2. 配置使用提高项目代码的准确性、安全性和健壮性\n3. 编写项目中公共方法库的 `d.ts`文件和处理项目中没有声明文件的第三方库【提薪】\n\n### 源码说明\n\n1. 已对整个项目进行环境配置  eslint+prettier+husky+commitizen\n2. 项目根目录中，已配置eslint +prettier 定义 语法风格规范\n3. 公共库`/src/utils/tool.d.ts` 配置全局类型声明\n\n## rbac权限管理\n\n### 技术项\n\n1. react-router、koa\n\n### 提薪点\n\n1. 封装公共hooks\n2. token鉴权\n\n### 源码说明\n\n1. 在项目`\\src\\hooks\\`封装公共hooks\n2. 在项目-前端`\\src\\utils\\Request.ts`请求拦截\n3. 后端封装`verifyToken`校验中间件-可配置指定接口校验token\n\n## 云文件oss\n\n阿里云oos、file 上传 、sokectio、分片上传、断点续传、koa\n\n### 提薪点\n\n- 服务端断点续传\n- socket心跳检测\n\n### 源码说明\n\n`server`\n\n- 阿里云oss进行服务端上传、判断文件大小、过大切片处理\n- 进度实时回显-使用`socketio`\n- 文件上传、暂停、使用koa+sokect+alioss 进行对oss切片操作\n- sokcet心跳检测-可使用sokcetIO进行配置、或者手写定时器查询socket状态\n\n## 充值支付\n\n支付宝sdk、koa\n\n### 微信下单流程\n\n![](https://gyg-bawei-gz4-01.oss-cn-beijing.aliyuncs.com/vuepress/7.png#id=Holqq&originHeight=1246&originWidth=1242&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)\n\n## 用户表格\n\nredux、koa、mock\n\n### 提薪点\n\n- 搭建项目公共组件库【提薪】\n\n### 源码说明\n\n- 前端`src\\components\\my_componet`封装表格、分页、弹框相关公共组件\n",
      "properties": {
        "title": "项目拆分",
        "urlname": "gbwx6y5p60i7wv4g",
        "date": "2023-08-27 13:45:14",
        "updated": "2023-08-27 13:46:14"
      },
      "catalog": [],
      "body": "",
      "realName": "gbwx6y5p60i7wv4g",
      "relativePath": "\\gbwx6y5p60i7wv4g.md"
    },
    {
      "id": 137510842,
      "doc_id": "ekgp9f9qf49vfdg9",
      "title": "ekgp9f9qf49vfdg9",
      "updated": 1693181775000,
      "body_original": "Koa/cros写在koa-router之前，否则配置跨域试错\n\n\n",
      "properties": {
        "title": "解决Koa中跨域问题",
        "urlname": "ekgp9f9qf49vfdg9",
        "date": "2023-08-28 08:13:38",
        "updated": "2023-08-28 08:16:15"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "ekgp9f9qf49vfdg9"
        }
      ],
      "body": "",
      "realName": "ekgp9f9qf49vfdg9",
      "relativePath": "\\ekgp9f9qf49vfdg9.md"
    },
    {
      "id": 137443477,
      "doc_id": "ty0lc4810uno20lx",
      "title": "ty0lc4810uno20lx",
      "updated": 1693066995000,
      "body_original": "以下是一个简单的示例代码，用于在前后端之间进行基本的心跳检测。\n前端代码（使用JavaScript）：\n```javascript\n// 创建WebSocket连接\nconst socket = new WebSocket('ws://localhost:8000');\n\n// 定时发送心跳消息\nsetInterval(() => {\n  if (socket.readyState === WebSocket.OPEN) {\n    socket.send('heartbeat');\n  }\n}, 5000);\n\n// 监听服务器发送的消息\nsocket.onmessage = function (event) {\n  // 处理服务器返回的消息\n  console.log('Received message from server:', event.data);\n};\n\n// 检测WebSocket连接状态\nsocket.onclose = function () {\n  console.log('Socket connection closed');\n};\n\nsocket.onerror = function (error) {\n  console.error('Socket error:', error);\n};\n```\n\n后端代码（使用Node.js和WebSockets库）：\n\n```javascript\nconst WebSocket = require('ws');\n\n// 创建WebSocket服务器\nconst wss = new WebSocket.Server({ port: 8000 });\n\n// 监听WebSocket连接事件\nwss.on('connection', function connection(ws) {\n  console.log('New client connected');\n\n  // 监听客户端发送的消息\n  ws.on('message', function (message) {\n    // 处理客户端发送的消息\n    console.log('Received message from client:', message);\n\n    // 回复心跳消息\n    if (message === 'heartbeat') {\n      ws.send('heartbeat');\n    }\n  });\n\n  // 监听WebSocket关闭事件\n  ws.on('close', function () {\n    console.log('Client disconnected');\n  });\n\n  // 监听WebSocket错误事件\n  ws.on('error', function (error) {\n    console.error('WebSocket error:', error);\n  });\n});\n```\n\n这个示例使用了WebSocket进行通信，并通过定时发送心跳消息来检测连接是否正常。\n\n前端代码创建了一个WebSocket连接，并每隔5秒发送一条心跳消息。后端代码创建了一个WebSocket服务器，监听客户端连接事件，并处理客户端发送的消息，如果收到心跳消息，就回复心跳消息。\n",
      "properties": {
        "title": "socket心跳检测",
        "urlname": "ty0lc4810uno20lx",
        "date": "2023-08-27 00:21:04",
        "updated": "2023-08-27 00:23:15"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "ty0lc4810uno20lx"
        }
      ],
      "body": "",
      "realName": "ty0lc4810uno20lx",
      "relativePath": "\\ty0lc4810uno20lx.md"
    },
    {
      "id": 134613703,
      "doc_id": "qai06nw793lx62hm",
      "title": "qai06nw793lx62hm",
      "updated": 1693014051000,
      "body_original": "# 前言\n这两天在学习阿里云oss上传。踩了不少坑，![092318F5.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1690860983073-8a10ff00-5637-460e-a7d1-a5307952ba88.png#averageHue=%23836628&clientId=uf159a306-0a1d-4&from=paste&height=27&id=u26c12489&originHeight=48&originWidth=48&originalType=binary&ratio=1.7999999523162842&rotation=0&showTitle=false&size=4368&status=done&style=none&taskId=ueddd57a3-900b-4a76-b0d3-4d0dc82694c&title=&width=26.666667373092103) 终于实现了大文件分片、断点续传的功能。这篇文章主要分享学习笔记，希望能给大家一些帮助。\n\n先看效果 ↓\n![oss断点 -original-original.gif](https://cdn.nlark.com/yuque/0/2023/gif/1450835/1690860840419-ec65a85f-778d-4685-88ab-0d42239c57d5.gif#averageHue=%23fbfbfe&clientId=uf159a306-0a1d-4&from=ui&id=ude2a73f0&originHeight=1316&originWidth=2552&originalType=binary&ratio=1.7999999523162842&rotation=0&showTitle=false&size=3446697&status=done&style=none&taskId=udd5ab611-7e96-4e2b-a3b1-afc4daebc5f&title=)\n**技术栈**\n\n1. 前端： react+Ts + axios 上传文件\n2. Node部分：定义接口、阿里云 oss\n3. socket.io ：实时同步上传进度\n> 特别说明 axios 中 onUploadProgress 只是上传本地文件的进度，不是上传服务器存入的进度，需要socket.io 从服务端实时返回上传进度 \n\n# 环境安装 \n![08E1CE2D.gif](https://cdn.nlark.com/yuque/0/2023/gif/1450835/1690856704913-f659f64c-1ba5-43a8-b6b0-f3920bd2f04b.gif#averageHue=%2353461b&clientId=ufdc2b5ae-cfe1-4&from=paste&height=35&id=u616cbe42&originHeight=220&originWidth=220&originalType=binary&ratio=2&rotation=0&showTitle=false&size=42931&status=done&style=none&taskId=ue02b9ae7-38fb-4df8-a680-823270abf78&title=&width=35.21354293823242)需进行阿里云oss配置，获取appid、密钥等参数 ↓[阿里云登录 - 欢迎登录阿里云，安全稳定的云计算服务平台](https://ram.console.aliyun.com/manage/ak?spm=a2c8b.12215393.top-nav.dak.6c12336aYGPYmv)\n以下是创建node服务所需依赖包\n```javascript\n// 下载 Koa 模块\nnpm install koa\n// 下载 Koa Router 模块 https://www.npmjs.com/package/koa-Router[包含示例代码]\nnpm install koa-router\n// 下载 @koa/cors 模块\nnpm install @koa/cors\n// 下载 ali-oss 模块\nnpm install ali-oss\n// 下载 koa-body 模块\nnpm install koa-body\n// 下载 socket.io \nnpm install socket.io\n```\n\n# 前端部分\n前端使用react+Ts，但无论哪种框架，其实业务逻辑是一样的\n### 初始化socket\n```javascript\n\n\t\t\t\t\t\tlet userId = localStorage.getItem('userId');\n            if (!userId) {\n                userId = new Date().getTime() + '';\n                localStorage.setItem('userId', userId);\n            }   \n               let host = 'http://127.0.0.1:3000'\n\n                const soket = io(host); \n                soket.on('connect', function(){\n                    console.log('链接了 Connected to server');  \n                 }); \n      \t// 模拟用户登录\n                 soket.emit('login',{\n                    userId\n                })\n                \n                soket.on('success', data => {\n                    console.log('success',data)\n                })\n                \n```\n### 文件上传\n```jsx\nconst upload = async () => {\n  // FileList 内置接口\n  const file = (inputRef.current?.files as FileList)[0];\n  console.log('inputRef', file);\n  if (!file) {\n    message.error('没有选择文件');\n    return;\n  }\n  let formData = new FormData();\n  formData.append('file', file);\n  let userId = localStorage.getItem('userId') as string\n  formData.append('userId',userId)\n  await axios.post(host+'/upload', formData, {\n    // onUploadProgress 监听的是客户端发送数据的进度，而不是存储服务器的进度。\n    onUploadProgress: (progressEvent: any) => {\n      const percentage = Math.round((progressEvent.loaded * 100) / progressEvent.total);\n      console.log(`Upload progress: ${percentage}%`, progressEvent);\n    }\n  });\n};\n```\n### 进度回显\n```jsx\nconst [progress,setProgress] = useState<number>(0)\nsoket.on('uploadding', data => {\n         console.log('uploadding',data)\n        setProgress(data)\n  })    \n\n```\n# node部分\n后台使用koa创建node服务，主要分为api接口、阿里云业务函数、socket.io 实时发送上传进度\n### socket.io\n```javascript\nconst { createServer } = require(\"http\"); // 导出创建服务的模块函数\nconst { Server } = require(\"socket.io\"); // 创建socket.io 服务的函数\nconst httpServer = createServer(app.callback());  // 创建一个http服务实例，app.callback() 作为服务器的请求处理函数\nconst io = new Server(httpServer, {\n    cors: {\n        origin: \"*\" // 配置socket允许跨越\n    }\n});\n```\n### 上传接口\n```javascript\n// 上传接口\nrouter.post('/upload', async (ctx, next) => {\n    let file = ctx.request.files.file;\n    // 用户id \n    let userId = ctx.request.body.userId\n    try {\n        let result = null;\n        await next();\n        // 判断文件大小，超过partSize进行分片上传\n        if (file.size < partSize) {\n            console.log('直连操作');\n            result = await commonUpload(file, userId);\n        } else {\n            console.log('分片上传');\n            result = await multipartUpload(file, userId);\n        }\n        ctx.body = {\n            code: 200,\n            message: 'success',\n            data: result\n        };\n    } catch (error) {\n        console.log('error', error);\n        ctx.body = {\n            message: '上传失败',\n            code: 401\n        };\n    }\n});\n```\n### 暂停接口\n```javascript\nrouter.post('/break', async (ctx) => {\n\n    let userId = ctx.request.body.userId\n    // 取出 当前用户的阿里云实例，用于仅关闭当前上传\n    let itemClient = userList[userId]['client']\n    if (itemClient) {\n        itemClient.cancel();\n        ctx.body = {\n            code: 200,\n            message: \"暂停成功\"\n        }\n    } else {\n        ctx.body = {\n            code: 401,\n            message: \"暂停失败\"\n        }\n    }\n\n});\n```\n### 继续上传接口\n```javascript\n// 继续上传 \nrouter.post('/continue', async (ctx) => {\n    let userId = ctx.request.body.userId\n    ctx.body = {\n        code: 200,\n        message: '已继续上传',\n\n    };\n    try {\n        resumeMultiparUpload(userId)\n    } catch (error) {\n        console.log('继续上传报错')\n    }\n\n});\n```\n### 分片上传\n```javascript\n// 分片上传\nconst multipartUpload = async (file, userId) => {\n\n    try {\n        let result = await userList[userId].client.multipartUpload(file.originalFilename, file.filepath, {\n            parallel,\n            partSize,\n            progress: (p, checkpoint) => {\n                onProgress(p, checkpoint, userId)\n            }\n        });\n        return result;\n    } catch (error) {\n        console.log('multipartUpload', error)\n    }\n};\n```\n### 断点续传\n```javascript\n// 断点续传\nconst resumeMultiparUpload = async (userId) => {\n    // 获取当前用户分片缓存 \n    try {\n        let checkpoint = checkpoints[userId]\n        const { uploadId, file } = checkpoint;\n        let result = await userList[userId].client.multipartUpload(uploadId, file, {\n            parallel,// 分片数量\n            partSize,//分片大小\n            progress: (p, checkpoint) => {\n                onProgress(p, checkpoint, userId)\n            },// 上传进度回调函数\n            checkpoint // 断点续传缓存目录\n        });\n        //上传后，删除切片数据\n        delete checkpoints[userId]\n        console.log('result', result)\n        return result;\n    } catch (error) {\n        console.log('error 获取当前用户分片缓存')\n    }\n\n}\n```\n### 进度回显\n```javascript\n// 上传进度\nconst onProgress = async (p, checkpoint, userId) => { // p 进度，checkpoint 当前分片上传数据\n    let step = Math.floor(p * 100); // 转换为百分比\n    io.to(userList[userId].socketId).emit('uploadding', step) // 发给当前客户端\n    // io.emit('uploadding',step) 群发\n    // 存储分片数据，用户续传\n    console.log('上传进度', step)\n    checkpoints[userId] = checkpoint\n};\n```\n### socket.io私聊\n```javascript\nconst userList = {}  // 用户数据\nconst partSize = 1024 * 100; // 每个分片大小(byte) 100kb\nconst parallel = 3; // 同时上传的分片数\nlet checkpoints = {}; // 记录上传分片数据，用于断点续传\n// oss客户端实例   \n\n// socket.io系统事件，监听链接状态\nio.on(\"connection\", (socket) => {\n    // 监听客户端信息数据，存储用户信息\n\n    socket.on('login', (data) => { \n        // 用户未链接oss，进行创建oss实例\n        if (!userList[data.userId]) {\n\n            let client = new OSS({\n                // yourRegion填写Bucket所在地域。以华东1（杭州）为例，Region填写为oss-cn-hangzhou。\n                region: 'oss-cn-beijing',\n                // 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控W制台创建RAM用户。\n                accessKeyId: 'xxx',\n                accessKeySecret: 'xx',\n                bucket: 'xxx\n            });\n\n            // 将socket.id 与用户信息关联存储，方便私聊发送\n            userList[data.userId] = {\n                ...data,\n                socketId: socket.id,\n                client: client\n            }\n            console.log('socket.id', socket.id)\n            console.log('获取到用户数据')\n        } else { // 已链接oss，进行只更新socket.id\n            userList[data.userId].socketId = socket.id\n        }\n    })\n    socket.emit('success', '服务端链接成功了')\n    // socket.io 系统事件-客户端断开监听\n    socket.on('disconnect', () => {\n        console.log('客户端断开了')\n        // io.emit('quit', socket.id)\n    })\n});\n```\n# 纯前端操作部分\n如无服务端业务要求，建议客户端调用阿里云sdk，实现上传oss功能，操作如node一致，阿里云sdk同样支持分片上传等，最方便的是无需再创建socket获取进度。\n兄弟们，点赞收藏过20，下篇文章更新呀\n# Socket 相关api\n\n在 Socket.IO 中，客户端和服务端都有一些系统事件。\n#### 服务端系统事件：\n\n1. `connection`：当客户端与服务器建立连接时触发。可以在此事件中执行与连接相关的操作。\n\n```javascript\nio.on(\"connection\", (socket) => {\n  // 处理连接事件\n});\n```\n\n2. `disconnect`：当客户端与服务器断开连接时触发。可以在此事件中执行与断开连接相关的操作。\n\n```javascript\nsocket.on(\"disconnect\", () => {\n  // 处理断开连接事件\n});\n```\n\n3. `error`：当在连接过程中发生错误时触发。可以在此事件中处理连接错误。\n\n```javascript\nsocket.on(\"error\", (err) => {\n  // 处理连接错误事件\n});\n```\n\n4. `to` 在 Socket.IO 中，`to` 方法用于向特定房间或客户端发送消息。它允许你将消息发送给指定的接收者。\n\n`to` 方法的使用方法如下：\n```javascript\nio.on('connection', (socket) => {\n\n  // 建议 将socket.id 与用户信息关联存储，方便私聊发送\n  // 向指定客户端发送消息\n  io.to(socket.id).emit('message', 'Hello from server!');\n});\n```\n\n使用 `io.to(socket.id).emit('message', 'Hello from server!')` 向特定客户端发送消息，其中 `socket.id` 表示当前客户端的唯一标识符。\n#### 客户端系统事件：\n\n1. `connect`：当客户端成功连接到服务器时触发。该事件仅发生在客户端连接成功时。\n\n```javascript\nsocket.on(\"connect\", () => {\n  // 处理连接成功事件\n});\n```\n\n2. `disconnect`：当客户端与服务器断开连接时触发。可以在此事件中执行与断开连接相关的操作。\n\n```javascript\nsocket.on(\"disconnect\", () => {\n  // 处理断开连接事件\n});\n```\n\n3. `error`：当在连接过程中发生错误时触发。可以在此事件中处理连接错误。\n\n```javascript\nsocket.on(\"error\", (err) => {\n  // 处理连接错误事件\n});\n```\n\n\n# 注意![08E1CE2D.gif](https://cdn.nlark.com/yuque/0/2023/gif/1450835/1690856704913-f659f64c-1ba5-43a8-b6b0-f3920bd2f04b.gif#averageHue=%2353461b&clientId=ufdc2b5ae-cfe1-4&from=paste&height=26&id=we6iZ&originHeight=220&originWidth=220&originalType=binary&ratio=2&rotation=0&showTitle=false&size=42931&status=done&style=none&taskId=ue02b9ae7-38fb-4df8-a680-823270abf78&title=&width=26.206600189208984)\n**socket 开启跨越**\n:::warning\nsocket.io 需配置跨越，否则无法链接，参考 [https://socket.io/zh-CN/docs/v4/handling-cors/](https://socket.io/zh-CN/docs/v4/handling-cors/)\n:::\n```javascript\nconst io = new Server(httpServer, {\n  cors: {\n    origin: \"http://localhost:8080\" // 前端访问地址 、\"*\" 允许所有跨越\n  }\n});\n\nhttpServer.listen(3000);\n```\n**koa+socket使用事项**\n:::warning\n接口后台和socket端口一致情况下，需使用包含socket的服务实例来创建监听，否则socket无法链接\n:::\n在koa中使用socket.io 需要创建一个包含socket.io的服务实例，代码示例如下：\n```javascript\nconst app = new (require(\"koa\"))();\nconst router = require(\"koa-Router\")();\nconst { createServer } = require(\"http\");\nconst { koaBody } = require(\"koa-body\");\nconst {Server} = require('socket.io')\napp.use(cors()); // 允许接口跨域\napp.use(router.routes());\n// 创建socket服务  \nconst httpServer = createServer(app.callback());\nconst io = new Server(httpServer,{\n    cors:{\n        origin:\"*\" // 允许socket跨域\n    }\n}) \nio.on('connection', () => { \n  console.log('服务链接了')\n  /* … */ });  \n// 使用包含socket的服务示例，如果使用koa中的app实例，则无法监听socket服务\nhttpServer.listen(9000, () => {\n  console.log(\"koa server listening on port 9000\");\n});\n\n```\n\n# 待做功能\nsts临时授权\noss上传应设置会话时长，超时进行重新获取，业务步骤类似token鉴权，阿里云oss操作也应该进行鉴权\n\nkoa+socket\n[https://www.cnblogs.com/qiaomucreate/p/16653265.html](https://www.cnblogs.com/qiaomucreate/p/16653265.html)\n",
      "properties": {
        "title": "阿里云oss开发实践：大文件分片、断点续传、实时进度 React+Node+Socket.IO",
        "urlname": "qai06nw793lx62hm",
        "date": "2023-07-28 11:49:53",
        "updated": "2023-08-26 09:40:51"
      },
      "catalog": [
        {
          "title": "案例开发",
          "doc_id": "qai06nw793lx62hm"
        },
        {
          "title": "本地上传+阿里云oss",
          "doc_id": "qai06nw793lx62hm"
        }
      ],
      "body": "",
      "realName": "qai06nw793lx62hm",
      "relativePath": "\\qai06nw793lx62hm.md"
    },
    {
      "id": 135196228,
      "doc_id": "szzvahg5dd1409ts",
      "title": "szzvahg5dd1409ts",
      "updated": 1693033086000,
      "body_original": "JSX 本质上是 React.createElement 的语法糖，返回 VDOM。在运行的时候，需要通过 babel 编译\n\n在react17之前，jsx转换都会转换为React.createElement调用， 所以我们必须在第一行加上：\n```\njs\n复制代码import React from \"react\"\n```\n本质上，react中的jsx会转化为createElement 或者 jsx函数调用。\n看几个栗子\n**1. 单一元素**\njsx:\n```\nhtml\n复制代码<div data-id='test-id'>\n  hello world\n</div>\n```\n结果：\n**2. 嵌套标签**\njsx:\n结果： \n```javascript\nReact.createElement(\n  \"div\",\n  {\n    \"data-id\": \"test-id\"\n  },\n  \"hello world\",\n  React.createElement(\n    \"span\",\n    {\n      className: \"span\"\n    },\n    \"hello span\"\n  )\n);\n\n```\n\nReact17之后的版本 React 已经不需要引入 createElement ，这种模式来源于 **Automatic Runtime**，看一下是如何编译的。\n```javascript\nfunction App(){\n  return <div>\n    <h1>hello,world</h1>\n  </div>\n}\n\n```\n编译后\n```javascript\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nfunction App() {\n  return  _jsxs(\"div\", {\n            children: [\n                _jsx(\"h1\", {\n                   children: \"hello,world\"\n                }),\n            ],\n        });\n}\n\n```\n",
      "properties": {
        "title": "手写jsx",
        "urlname": "szzvahg5dd1409ts",
        "date": "2023-08-03 15:02:35",
        "updated": "2023-08-26 14:58:06"
      },
      "catalog": [
        {
          "title": "react源码解析",
          "doc_id": "szzvahg5dd1409ts"
        }
      ],
      "body": "",
      "realName": "szzvahg5dd1409ts",
      "relativePath": "\\szzvahg5dd1409ts.md"
    },
    {
      "id": 136759556,
      "doc_id": "ueopfvai6y6du4ac",
      "title": "ueopfvai6y6du4ac",
      "updated": 1692977007000,
      "body_original": "当我们访问一个需要身份验证的网站或应用时，通常需要提供用户名和密码来验证身份。然而，这种方式存在一些问题，比如密码可能会被泄露或被猜测出来。为了解决这些问题，引入了一种称为\"token鉴权\"的身份验证机制。\n\nToken鉴权是一种基于令牌的身份验证方式。用户登录成功后，服务器生成唯一令牌返回给客户端。客户端在后续请求中携带令牌作为身份凭证。\n\n服务器验证令牌，确定用户身份和权限。令牌不存储在服务器，减轻负担。令牌可设置有效期，增加安全性。令牌可包含额外信息，方便权限控制。\n\n优势在于简单、安全、可扩展。不依赖用户名密码，减少密码泄露风险。可实现单点登录和跨系统身份验证。可通过加密和签名增加安全性。\n\n## token 和 jsonwebtoken 流程图\ntoken -接口访问凭证![](https://cdn.nlark.com/yuque/0/2023/webp/1450835/1692522872990-1f597e4c-8090-4b40-9bb0-153f0674c451.webp#averageHue=%23e6ebef&clientId=u1cd3a10a-1b9d-4&from=paste&height=281&id=u99a00231&originHeight=784&originWidth=1059&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u1a40d3f7-5e70-4ac0-91b8-64523ed5c28&title=&width=380)\n💡jwt（鉴权常用方案）\n![IMG_4169.JPG](https://cdn.nlark.com/yuque/0/2023/jpeg/1450835/1692456537558-33b3c0b0-b731-40a3-81f3-ec3d1d9917b0.jpeg#averageHue=%23e9eef2&from=url&height=272&id=OeZRt&originHeight=659&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&size=80777&status=done&style=none&title=&width=330)\n## 无感刷新token处理方案\n### 定义两个token\n单点登录\n> 主站维护自己的refresh-token，有效期较长，每次token过期后可以用refresh-token给自己续命请求新的token，从主站跳转到子站，或者主站授权去其他页面，都是给其他页面token，token的有效期较短，过期了就得重新授权，所以通过token和refresh-token就可以做到相对安全的单点登陆或者授权，因为他们两个的失效完全不同。\n\n- token_refresh( 刷新业务token的访问凭证) \n- access（业务token）\n\n为了安全期间，每个access token有效时间通常不能设太长，而refresh token就是为了延长access token的有效时间的，一开始就refresh token，那明显不符合\n![](https://cdn.nlark.com/yuque/0/2023/webp/1450835/1692500976713-3572f4df-7dbc-47b5-b45c-06f4d793db6e.webp#averageHue=%23e5ecef&clientId=u1cd3a10a-1b9d-4&from=paste&id=ud1dea8aa&originHeight=1084&originWidth=1410&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u4698c191-ef27-4d95-b065-5a0c58c1189&title=)\n\n### 定义一个token\n在请求响应拦截器中拦截，判断token 返回过期后，调用刷新token接口\n参考链接\n[https://juejin.cn/post/6854573219119104014](https://juejin.cn/post/6854573219119104014)\n[https://juejin.cn/post/6983582201690456071#heading-5](https://juejin.cn/post/6983582201690456071#heading-5)\n### 问题\n\n- [问题一：如何防止多次刷新token](https://juejin.cn/post/6983582201690456071#heading-4)\n- [问题二：同时发起两个或者两个以上的请](https://juejin.cn/post/6983582201690456071#heading-5)\n## cookie-ssetion vs token\n\n- sestionId需要存储在数据库中，增加了查询的开销\n- token是个无状态的，无需存储，缺陷token有效期内销毁\n\n## 接口-超时未操作登出\n在token鉴权的功能基础上，实现接口超时未交互，则账号退出。\n**防踩坑无用版**以下思路是我在**未接触无感刷新方案的意淫版，图一乐就行啦**\n**前端实现（有风险-容易被篡改）**\n在前端请求拦截中实现\n\n1. 首次请求成功后本地存储时间，下次请求响应前进行时间校验。\n2. 当前时间与本地时间校验，未超时继续请求，超时则跳转登录页。\n\n**后端node实现**\n用户操作任意一个接口时，后台进行校验。\n\n1. 在用户登录成功时，将用户的最后操作时间记录在会话中或存储在数据库中。\n2. 对于每个请求，都更新用户的最后操作时间。\n3. 设置一个定时器或定时任务，在一定时间间隔内检查用户最后操作时间与当前时间的差值。如果超过了设定的时间阈值，则执行退出操作。\n### 第二版（通用方案💡）\n使用双token实现无感刷新登录🔄，无需再检测接口超时未访问、实现系统登出功能。\n\n因为在请求拦截器中，监听接口401状态（token失效）去调用刷新token接口，如果refash_toke也失效，说明在规定时间内未访问、则登出系统\n## 前端-超时未操作登出\n用户长时间未操作页面，返回登录\n每隔30s去检查一下用户是否过了30分钟未操作页面。\n注意事项：！需要考虑及时销毁定时器\n```typescript\n// 引入路由和storage工具函数\nimport storage from '@/utils/storage'\nimport router from \"@/common/router\"\n\nlet lastTime = new Date().getTime()\nlet currentTime = new Date().getTime()\nlet timeOut = 30 * 60 * 1000  //设置超时时间: 30分钟\n\nwindow.onload = function () {\n  window.document.onmousedown = function () {\n    stroage.setItem(\"lastTime\", new Date().getTime())\n  }\n};\n\nfunction checkTimeout() {\n  currentTime = new Date().getTime()\t\t//更新当前时间\n  lastTime = stroage.getItem(\"lastTime\");\n\n  if (currentTime - lastTime > timeOut) { //判断是否超时\n\n    // 清除storage的数据(登陆信息和token)\n    storage.clear()\n    // 跳到登陆页\n    if(router.currentRouter.name == 'login') return // 当前已经是登陆页时不做跳转\n    router.push({ name: 'login' })\n  }\n}\n\nexport default function () {\n  /* 定时器 间隔30秒检测是否长时间未操作页面 */\n  window.setInterval(checkTimeout, 30000);\n}\n\n```\n\n",
      "properties": {
        "title": "「token方案指南」前后端鉴权-超时未操作登出",
        "urlname": "ueopfvai6y6du4ac",
        "date": "2023-08-19 14:59:11",
        "updated": "2023-08-25 23:23:27"
      },
      "catalog": [
        {
          "title": "案例开发",
          "doc_id": "ueopfvai6y6du4ac"
        }
      ],
      "body": "",
      "realName": "ueopfvai6y6du4ac",
      "relativePath": "\\ueopfvai6y6du4ac.md"
    },
    {
      "id": 137277743,
      "doc_id": "pq90e0didogi2as4",
      "title": "pq90e0didogi2as4",
      "updated": 1692884137000,
      "body_original": "# 场景\n\n在reducer中使用 object.assign(state,{data:xxx}) 合并了状态，控制台打印state 数据已更新，但是页面未重新渲染\n# 原因\nredux会通过引用来判断前后两次state有没有变化。return原来的state的话redux会认为你的state没有变化。\n\n咱们用Object.assign(state,xx)是直接修改了state对象，然后返回的还是原来的state对象（被修改过的数据）但是引用未更改，还是同一引用源。\n\n# 解决\n使用而扩展符则是创建了一个新的对象，相当于Object.assign({},state,...)\n\n**注意**：不要在reducer里面做以下操作\n1、修改传入参数；\n2、执行有副作用的操作，如 API 请求和路由跳转；\n3、调用非纯函数，如 Date.now() 或 Math.random()。\n",
      "properties": {
        "title": "更改redux 数据，页面未重新渲染",
        "urlname": "pq90e0didogi2as4",
        "date": "2023-08-24 20:00:47",
        "updated": "2023-08-24 21:35:37"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "pq90e0didogi2as4"
        }
      ],
      "body": "",
      "realName": "pq90e0didogi2as4",
      "relativePath": "\\pq90e0didogi2as4.md"
    },
    {
      "id": 137379557,
      "doc_id": "md028ruhw1kkzydv",
      "title": "md028ruhw1kkzydv",
      "updated": 1692967269000,
      "body_original": "# 场景\n使用`koa-router` 和`koa-multer` 存储本地照片报错：`Error: Unexpected end of format Multipart._final` 改为使用 `koa-Router` 就没问题啦\n# 原因\n使用`koa-router`处理路由时，如果请求中缺少必要的表单数据，就会抛出\"Unexpected end of form\"错误。\n使用koa-Router处理请求时，koa-Router本身并不处理文件上传，并不关心请求中是否包含文件数据。它只负责路由的匹配和处理。因此，当你使用koa-Router时，不会出现\"Unexpected end of form\"错误\n# 解决\n1、弃坑koa-router 改为koa-Router【高效快捷】\n2、如果你精力充沛，继续使用koa-router ，建议查看前端请求的表单数据 、是否合格，调整修改。具体如何修改，我搜了俩小时都没找到解决方案。\n如果有大神以第二种方式修改成功，记得留言v我呀\n\n",
      "properties": {
        "title": "koa-Router 和koa-router 傻傻分不清",
        "urlname": "md028ruhw1kkzydv",
        "date": "2023-08-25 20:16:20",
        "updated": "2023-08-25 20:41:09"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "md028ruhw1kkzydv"
        }
      ],
      "body": "",
      "realName": "md028ruhw1kkzydv",
      "relativePath": "\\md028ruhw1kkzydv.md"
    },
    {
      "id": 137034928,
      "doc_id": "uyhgxnhx5izuzaiu",
      "title": "uyhgxnhx5izuzaiu",
      "updated": 1692687523000,
      "body_original": "",
      "properties": {
        "title": "react 高阶组件",
        "urlname": "uyhgxnhx5izuzaiu",
        "date": "2023-08-22 14:58:33",
        "updated": "2023-08-22 14:58:43"
      },
      "catalog": [
        {
          "title": "react高阶使用",
          "doc_id": "uyhgxnhx5izuzaiu"
        }
      ],
      "body": "",
      "realName": "uyhgxnhx5izuzaiu",
      "relativePath": "\\uyhgxnhx5izuzaiu.md"
    },
    {
      "id": 137087662,
      "doc_id": "dv8t85khggaglosv",
      "title": "dv8t85khggaglosv",
      "updated": 1692801591000,
      "body_original": "文章首发公众号  👉[程序员王天](https://img-cdn.dslcv.com/wt_gzh.png)👈 欢迎关注\n# 前言\nImmer 是一个用于简化 JavaScript 状态管理的库，以更方便地更新和操作不可变数据\n\n可以解决以下问题：\n\n1.  `不可变状态更新`：React 推崇使用不可变（Immutable）的数据来管理组件的状态。\n:::tips\n【Immutable 不可变对象】\n不直接修改状态或属性对象，而是创建新的对象来代表改变后的状态。\n:::\n\nImmer 使得在 React 中使用不可变数据更加容易，通过提供简洁的 API 和直观的语法，以可变的方式更新不可变数据。\n\n2.  `状态更新的简洁性`：React 的传统方式是通过使用 `setState` 方法更新状态，需要手动创建新的状态对象或数组，并进行深度克隆。而使用 Immer，可以通过直接在原始状态上进行修改，以一种可变的方式更新状态。\n\n React 中使用 Immer ，可以避免手动编写深度克隆、合并对象或数组的代码，同时还能保持数据的不可变性，方便进行状态管理和追踪变更。\n\n# react组件使用immer\n以下是一个使用 Immer 的 React 组件示例：\n\n```jsx\nimport React from 'react';\nimport { produce } from 'immer';\n\nclass Counter extends React.Component {\n  state = {\n    count: 0\n  };\n\n  increment = () => {\n    this.setState(produce((draft) => {\n      draft.count += 1;\n    }));\n  };\n\n  render() {\n    return (\n      <div>\n        <p>Count: {this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n\nexport default Counter;\n```\n\n在上面的示例中，我们使用 `produce` 函数将状态更新的逻辑放在一个回调函数中，然后将回调函数传递给 `setState`。Immer 会在回调函数中提供一个名为 `draft` 的草稿对象，\n\n我们可以直接对该对象进行更改，而不用担心原始对象被修改。Immer 会根据我们的更改生成一个新的不可变对象，并将其作为新的状态进行更新。\n# redux中使用immer\n接下来，让我们看一个使用 Immer 结合 Redux 的示例：\n\n```javascript\nimport { createStore } from 'redux';\nimport produce from 'immer';\n\n// 初始状态\nconst initialState = {\n  count: 0\n};\n\n// reducer\nconst reducer = (state = initialState, action) => {\n  return produce(state, (draft) => {\n    switch (action.type) {\n      case 'INCREMENT':\n        draft.count += 1;\n        break;\n      case 'DECREMENT':\n        draft.count -= 1;\n        break;\n      default:\n        break;\n    }\n  });\n};\n\n// 创建 store\nconst store = createStore(reducer);\n\nexport default store;\n```\n\n在上面的示例中，我们在 Redux 的 reducer 中使用 `produce` 函数来更改状态。它接收当前状态 `state` 和表示要进行的更改操作的回调函数。我们可以在回调函数中对 `draft` 对象进行更改，Immer 会自动处理状态的更新。\n\n# 总结\n\n在使用 React 组件时，可以使用 `produce` 函数来更新状态，而在使用 Redux 时，可以在 reducer 中使用 `produce` 函数来进行状态更改操作。这样可以避免手动编写不必要的克隆和合并代码，并且使我们的代码更容易理解和维护。\n",
      "properties": {
        "title": "immer：优雅操作react数据状态，告别繁琐克隆拷贝",
        "urlname": "dv8t85khggaglosv",
        "date": "2023-08-23 05:19:55",
        "updated": "2023-08-23 22:39:51"
      },
      "catalog": [
        {
          "title": "react高阶使用",
          "doc_id": "dv8t85khggaglosv"
        }
      ],
      "body": "",
      "realName": "dv8t85khggaglosv",
      "relativePath": "\\dv8t85khggaglosv.md"
    },
    {
      "id": 136833356,
      "doc_id": "mz8m056g258v9c9w",
      "title": "mz8m056g258v9c9w",
      "updated": 1692606619000,
      "body_original": "# rbac 模块拆分\n## 前置\n\n- [x] 项目基础搭建、目录划分\n- [x] 封装axios\n- [x] 创建公共库\n## 功能\n\n- [x] 注册+ webpackDevSever\n- [x] 登录+webpackDevSever \n- [x] 用户密码检测\n- [x] 获取对应权菜单权限\n- [x] 生成token,返回数据\n- [x] 动态渲染路由\n- [x] 根据后台权限数据，动态渲染路由\n- [x] 动态渲染导航页面菜单\n- [ ] andt 组件模板\n## 技术项\nreact+ts\nreact-router\n## 环境复杂度\n路由守卫-登录鉴权\n## 项目目录\n\n- src\n   - API - 接口管理\n   - componentss - 全局组件\n   - views - 项目所有页面\n   - utils - 工具库\n   - redux - 仓库\n",
      "properties": {
        "title": "RBAC权限管理",
        "urlname": "mz8m056g258v9c9w",
        "date": "2023-08-20 21:32:27",
        "updated": "2023-08-21 16:30:19"
      },
      "catalog": [
        {
          "title": "案例开发",
          "doc_id": "mz8m056g258v9c9w"
        }
      ],
      "body": "",
      "realName": "mz8m056g258v9c9w",
      "relativePath": "\\mz8m056g258v9c9w.md"
    },
    {
      "id": 135703188,
      "doc_id": "mzk95qvgh2ryp3tp",
      "title": "mzk95qvgh2ryp3tp",
      "updated": 1692364994000,
      "body_original": "# 内置Hooks\n## useRoutes\n替代`routes`组件，以JavaScript对象的结构生成`routes`路由模版，省去了嵌套循环。\n### 注意事项：\n1、useRoutes 无法解析异步组件，可以考虑使用 React Router 的 React.lazy 和 React.Suspense 组合来实现。下面是一个示例：\n```jsx\nimport React, { Suspense } from 'react';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\n\nconst AsyncHome = React.lazy(() => import('./components/Home'));\nconst AsyncAbout = React.lazy(() => import('./components/About'));\n\nfunction App() {\n  return (\n    <Router>\n      <Suspense fallback={<div>Loading...</div>}>\n        <Switch>\n          <Route path=\"/\" exact component={AsyncHome} />\n          <Route path=\"/about\" component={AsyncAbout} />\n        </Switch>\n      </Suspense>\n    </Router>\n  );\n}\n\nexport default App;\n\n```\n",
      "properties": {
        "title": "react-RouterV6",
        "urlname": "mzk95qvgh2ryp3tp",
        "date": "2023-08-08 22:52:39",
        "updated": "2023-08-18 21:23:14"
      },
      "catalog": [
        {
          "title": "react基础开发",
          "doc_id": "mzk95qvgh2ryp3tp"
        }
      ],
      "body": "",
      "realName": "mzk95qvgh2ryp3tp",
      "relativePath": "\\mzk95qvgh2ryp3tp.md"
    },
    {
      "id": 136732327,
      "doc_id": "qdn2elswtf486gvx",
      "title": "qdn2elswtf486gvx",
      "updated": 1692369118000,
      "body_original": "# Suspense\n- 组件加载时的占位符-用于懒加载\n-  属性 fallback\n\n组件尚未加载完成时，会显示fallback属性中指定的组件内容，用于展示加载状态。一旦数据加载完成,组件会被显示，并以更新后的数据渲染内容\n 一般搭配 lazy() 函数，用suspense 组件包裹住 懒加载组件，在加载过程中展示 suspense 中的占位内容。\n## 场景\n当我们在React中构建应用程序时，有时某些组件的加载可能需要一些时间。为了提供更好的用户体验，我们可以使用Suspense组件。\nSuspense组件的作用是在组件加载过程中显示一些备用内容，例如加载指示器或占位符。它的使用场景包括代码分割和懒加载。\n\n## 使用方法：\n\n1. 导入所需的依赖：`import React, { Suspense } from 'react';`\n2. 使用React.lazy()动态加载需要延迟加载的组件：`const MyComponent = React.lazy(() => import('./MyComponent'));`\n3. 在渲染处使用Suspense组件，并设置fallback属性来指定备用内容：`<Suspense fallback={<div>Loading...</div>}>...</Suspense>`\n4. 将需要延迟加载的组件放置在Suspense组件内部：`<MyComponent />`\n## 示例代码：\n\n```jsx\nimport React, { Suspense } from 'react';\n\nconst MyComponent = React.lazy(() => import('./MyComponent'));\n\nfunction App() {\n  return (\n    <div>\n      <h1>My App</h1>\n      <Suspense fallback={<div>Loading...</div>}>\n        <MyComponent />\n      </Suspense>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n在上述示例中，MyComponent是一个需要延迟加载的组件。使用Suspense组件将MyComponent包裹起来，当组件加载时，会显示指定的备用内容，即`<div>Loading...</div>`。一旦组件加载完成，它将替换备用内容，显示真正的组件内容。\n\n",
      "properties": {
        "title": "react内置组件",
        "urlname": "qdn2elswtf486gvx",
        "date": "2023-08-18 22:10:45",
        "updated": "2023-08-18 22:31:58"
      },
      "catalog": [
        {
          "title": "react基础开发",
          "doc_id": "qdn2elswtf486gvx"
        }
      ],
      "body": "",
      "realName": "qdn2elswtf486gvx",
      "relativePath": "\\qdn2elswtf486gvx.md"
    },
    {
      "id": 135769978,
      "doc_id": "kcb12zwkginqus50",
      "title": "kcb12zwkginqus50",
      "updated": 1692337735000,
      "body_original": "# 组件通信\n \n##  父子 props \n父组件标签内的jsx内容，通过children作为插槽传入子组件 \n##  子向父-回调函数 \n 父组件中通过props向子组件传参函数，子组件触发函数参数，实现子父通信 \n\n### 父子-子父组件通信示例\n子组件\n```jsx\nimport React from 'react';\n\ninterface ChildrenProps {\n  title:string,\n    dbClick?:()=>void,\n      children?:any\n\n}\n\nconst Children: React.FC<ChildrenProps> = ({dbClick,title,children}:ChildrenProps) => {\n  return (\n  <>\n    <h1 onDoubleClick={dbClick}> {title}</h1>\n    {children}\n  </>\n  );\n  };\n\n  export default Children;\n```\n父组件\n```jsx\n{/* 父子传参 props ;父组件标签内的jsx内容，通过children作为插槽传入子组件*/}\n{/* 子向父通信-回调函数 - 父组件中通过props向子组件传参函数，子组件触发函数参数，实现子父通信 */}\n<Children title=\"标题\" dbClick={()=>alert('双击了')}>\n  {<div>{a}</div>}\n</Children>\n```\n## 跨组件\n# redux仓库\n",
      "properties": {
        "title": "React通信",
        "urlname": "kcb12zwkginqus50",
        "date": "2023-08-09 16:01:05",
        "updated": "2023-08-18 13:48:55"
      },
      "catalog": [
        {
          "title": "react高阶使用",
          "doc_id": "kcb12zwkginqus50"
        }
      ],
      "body": "",
      "realName": "kcb12zwkginqus50",
      "relativePath": "\\kcb12zwkginqus50.md"
    },
    {
      "id": 136598282,
      "doc_id": "irgky2a61g0brm1e",
      "title": "irgky2a61g0brm1e",
      "updated": 1692264127000,
      "body_original": "npx cz 执行后，无法弹出交互选择，报错如下：\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1692263999849-26ea086c-6be8-4b8a-9d4f-3f93120a5c2a.png#averageHue=%2342392f&clientId=ubf8fa557-3af9-4&from=paste&height=134&id=Yybe4&originHeight=268&originWidth=998&originalType=binary&ratio=2&rotation=0&showTitle=false&size=112685&status=done&style=none&taskId=u6515ca08-df8d-411f-94d4-8a81b09c11d&title=&width=499)\n解决方法：\n强制安装\n```typescript\nnpx commitizen init cz-conventional-changelog --save-dev --save-exact --force\n```\n",
      "properties": {
        "title": "npx cz 无法执行",
        "urlname": "irgky2a61g0brm1e",
        "date": "2023-08-17 17:19:31",
        "updated": "2023-08-17 17:22:07"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "irgky2a61g0brm1e"
        }
      ],
      "body": "",
      "realName": "irgky2a61g0brm1e",
      "relativePath": "\\irgky2a61g0brm1e.md"
    },
    {
      "id": 135620479,
      "doc_id": "cg2svaaug21hrh90",
      "title": "cg2svaaug21hrh90",
      "updated": 1692322318000,
      "body_original": "# 问题\n在用户未登录时、打开某个需要鉴权的页面，会出现短暂的目标页面闪现，然后跳转到登录页。\n这是因为在页面加载时，会先展示目标页面的内容，然后在进行鉴权检查后才进行跳转的过程导致的。\n# 解决\n\n1. 使用鉴权路由组件：创建一个高阶组件或自定义组件，用于对需要鉴权的路由进行包裹。在该组件中进行鉴权检查，如果用户未登录，则直接跳转到登录页，否则渲染目标页面。这样可以避免目标页面的内容闪现\n\n# 示例代码\n## 封装一个路由守卫高阶组件\n```tsx\nimport { Navigate, useLocation } from 'react-router-dom';\nimport { serachRoutr } from '../utils/utils';\nimport { ListRoute } from '../router/routerConfig';\n\n\nconst AuthRouer = (PROPS: any) => {\n\n  const isLogin = localStorage.getItem('isLogin');\n  // const navigate = useNavigate();\n\n  const { pathname } = useLocation();\n  const res = serachRoutr(pathname, ListRoute) as any;\n  // 完成二级路由重定向  \n  if (res.meta && res.meta.to) {\n    return <Navigate to=\"/home/main\" replace></Navigate>;\n  }\n  if (!isLogin && pathname !== '/login') {\n    console.log('loaclhost', pathname);\n    // 未登录且不是登录页，跳转到登录页\n    return <Navigate to=\"/login\" replace />;\n  } else {\n    return <div>{PROPS.children}</div>;\n  }\n};\n\nexport default AuthRouer;\n```\n使用：\n注意！用封装的路由守卫组件包裹住路由信息\n```tsx\nimport ReactDOM from 'react-dom/clien;\nimport './index.css';\nimport RouterChiled from './router/routerConfig';\nimport {  BrowserRouter } from 'react-router-dom';\nimport AuthRouer from './components/authRouer';\nconst root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);\nroot.render( \n\n  <BrowserRouter>\n    {/* <Suspense fallback={<div>加载中</div>}> */}\n    // 用路由守卫组件包裹住路由信息\n    <AuthRouer>\n      <RouterChiled />\n    </AuthRouer>\n    {/* </Suspense> */}\n  </BrowserRouter>\n);\n```\n",
      "properties": {
        "title": "react-router-鉴权页面闪现",
        "urlname": "cg2svaaug21hrh90",
        "date": "2023-08-08 10:43:23",
        "updated": "2023-08-18 09:31:58"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "cg2svaaug21hrh90"
        }
      ],
      "body": "",
      "realName": "cg2svaaug21hrh90",
      "relativePath": "\\cg2svaaug21hrh90.md"
    },
    {
      "id": 133878147,
      "doc_id": "mqtfvzzp1agddpff",
      "title": "mqtfvzzp1agddpff",
      "updated": 1692107374000,
      "body_original": "在TypeScript中，可选参数和默认参数、剩余参数以及函数重载可以帮助我们更灵活地定义和使用函数。\n## 1、可选参数和默认参数：\n\n可选参数允许我们在调用函数时省略一些参数，而默认参数为函数的参数提供了默认值。\n\n举个例子，假设我们有一个函数`greet`用于问候，接受一个名称参数和一个可选的消息参数：\n\n```typescript\nfunction greet(name: string, message?: string) {\n    if (message) {\n        console.log(`Hello, ${name}! ${message}`);\n    } else {\n        console.log(`Hello, ${name}!`);\n    }\n}\n```\n\n当我们调用这个函数时，可以只传递名称参数，而可选的消息参数可以省略：\n\n```typescript\ngreet(\"Alice\"); // 输出：Hello, Alice!\n```\n\n如果我们想要提供消息参数，可以在调用时传递它：\n\n```typescript\ngreet(\"Bob\", \"How are you?\"); // 输出：Hello, Bob! How are you?\n```\n\n此时，函数内部会打印带有消息的完整问候语。可选参数和默认参数可以使函数使用更加方便和灵活。\n\n## 2、剩余参数：\n\n剩余参数允许我们在函数中接受不定数量的参数，并将它们作为数组在函数内部使用。\n\n举个例子，我们有一个函数`sum`用于计算一组数字的总和：\n\n```typescript\nfunction sum(...numbers: number[]) {\n    let total = 0;\n    for (let number of numbers) {\n        total += number;\n    }\n    return total;\n}\n```\n\n我们可以传递任意数量的参数给函数，并且函数内部会将这些参数相加并返回结果：\n\n```typescript\nconsole.log(sum(1, 2, 3)); // 输出：6\nconsole.log(sum(4, 5, 6, 7, 8)); // 输出：30\n```\n\n剩余参数使用三个点（`...`）前缀来表示，它将多个参数收集到一个数组中，方便在函数内部进行处理。这样，我们可以更便捷地传递和处理不定数量的参数。\n\n## 3、重载：\n我们在js中总是不经意间使用函数重载，根据不同的参数类型或个数来执行不同的逻辑，这就是函数重载。\n\n它在类型检查和类型推断方面提供了更强大的功能。\n\n下面例子，展示了如何使用函数重载来实现一个根据参数的不同选择执行不同逻辑的函数：\n\n```typescript\nfunction formatData(data: string): string;\nfunction formatData(data: number): number;\nfunction formatData(data: string | number): string | number {\n  if (typeof data === 'string') {\n    return data.toUpperCase();\n  } else if (typeof data === 'number') {\n    return data.toFixed(2);\n  }\n}\n\nconst result1 = formatData('hello'); // 返回类型为 string，结果为 \"HELLO\"\nconst result2 = formatData(3.14159); // 返回类型为 number，结果为 3.14\n\n```\n\n上述例子中，我们定义了一个名为 formatData 的函数，它接受一个参数 data，可以是字符串或数字类型。通过函数重载，我们提供了两个函数类型定义：第一个重载接受字符串参数并返回字符串，第二个重载接受数字参数并返回数字。在函数体实现中，根据不同的参数类型执行不同的逻辑操作。\n\n通过使用函数重载，我们可以在类型安全的环境中，根据参数类型提供不同的实现，提高代码的可靠性和可读性。这对于需要根据参数进行不同处理的场景非常有用，比如解析不同类型的输入数据、根据参数类型进行计算等等\n",
      "properties": {
        "title": "函数",
        "urlname": "mqtfvzzp1agddpff",
        "date": "2023-07-21 10:25:24",
        "updated": "2023-08-15 21:49:34"
      },
      "catalog": [
        {
          "title": "typescript 入门指南",
          "doc_id": "mqtfvzzp1agddpff"
        },
        {
          "title": "基础开发",
          "doc_id": "mqtfvzzp1agddpff"
        }
      ],
      "body": "",
      "realName": "mqtfvzzp1agddpff",
      "relativePath": "\\mqtfvzzp1agddpff.md"
    },
    {
      "id": 133878007,
      "doc_id": "iy5mr7og6iora1t1",
      "title": "iy5mr7og6iora1t1",
      "updated": 1692086163000,
      "body_original": "`class` 相当于es5中升级版的构造函数\n> class 中无需用“ ，” 分割 ， 添加会执行报错\n\n\n```typescript\nclass People {\n    name: string = '张三';\n    // 1、属性除了可以定义在constructor中，也可以定义在最顶部\n    age: number = 18; // 年龄\n    sex: boolean = true; // 为true 性别男\n    // 2、static 设置为（静态）私有属性，在class本身的属性，并不是实例对象中的属性\n    static address: string = '北京顺义';\n    // 3、constructor()方法是类的默认方法，\n    // 通过new命令生成对象实例时，自动调用该方法。\n    // 一个类必须有constructor()方法，如果没有显式定义， 一个空的constructor()方法会被默认添加。\n    // 属性是实例对象自身的属性，而不是定义在实例对象的原型上面。\n    constructor(sex, age) {\n        this.sex = sex;\n        this.age = age;\n    }\n    // 4、类的实例属性、方法默认定义在原型class上，使用this.可以定义在对象上\n    hi() {\n        return `你好呀 ${this.name}, 你今年 ${this.age} 岁啦，你是一个 ${this.sex ? '男生' : '女生'}，住在 ${\n            People.address\n        }`;\n    }\n}\n// 5、继承 People ,创建一个新的calss 类\nclass Lisi extends People {\n    constructor(sex, name) {\n        super(true, name);\n        console.log(this.name);\n    }\n    // 在原先基础上，新增一个setName 方法来修改name名称\n    setName(name: string): string {\n        this.name = name;\n        console.log('super-sex', this.sex);\n        // 6、在 ES6 中，super 是一个关键字，用于在子类中调用父类的构造函数和方法。\n        return super.hi();\n    }\n}\n// 7、类必须使用new调用，否则会报错。\n// 这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。\nconst zhangSan = new People(false, 19);\nconst zhangHi = zhangSan.hi();\nconst liHi = new Lisi(false, 29).setName('李四');\nconsole.log('zhangHI', zhangHi);\nconsole.log('liHi', liHi);\n\n// 8、存取器 使用 getter 和 setter 可以改变属性的赋值和读取行为：\n// 和vue中的computed 计算属性异曲同工，用与计算转换等操作\n// vue中的计算属性 有缓存、和数据依赖\nclass Animal {\n    constructor(name) {\n        this.name = name;\n    }\n    get name() {\n        return 'Jack';\n    }\n    set name(value) {\n        console.log('setter: ' + value);\n    }\n}\n\nconst a = new Animal('Kitty'); // setter: Kitty\na.name = 'Tom'; // setter: Tom\nconsole.log('存取器：', a.name); // Jack\n```\n\n# 【typescript 中新特性】\n\n```typescript\n//1、 修饰符\n// public 公共\n// private 私有\n// protected 保护,与private类似，区别在于protected可以在子类访问\nclass TypePeople {\n    public name: string; // 公共\n    private age: number = 19; // 外部不可访问\\\n    protected address: string = '北京顺义区'; // 仅在 子类可用\n    public constructor(name) {\n        this.name = name + this.age;\n    }\n}\nclass childrenPeople extends TypePeople {\n    constructor(name) {\n        super(name + ' 🐂 ');\n    }\n    getAddress() {\n        return `hi ${this.name} 你家在 ${this.address}`;\n    }\n}\nconst newPeople = new TypePeople('谢广坤');\nconst newChildren = new childrenPeople('谢飞机');\nconsole.log(newPeople.name, newChildren.getAddress());\n// 继承 - 看第5序章\n// 抽象类 abstract \n// abstract 用于定义共同的方法和属性，抽离到抽象类, 特性可以被继承，不可被实例化。\n// 使用抽象类的好处是它提供了一种通用的方式来定义父类，以及要求子类遵循规定并提供自己的实现。\n\n// 【案例】\n// 假设你正在写一个动物园管理系统，你有不同类型的动物，例如狗、猫和鸟。每种动物都有一些共同的属性和行为，例如它们都有名字和年龄，它们都可以发出叫声。\n// 在这种情况下，你可以使用抽象类来定义一个叫做 \"Animal\" 的类作为基类。这个抽象类可以包含共同的属性和方法，如下所示：\n\nabstract class AnimalNew {\n  name: string;\n  age: number;\n\n  constructor(name: string, age: number) {\n    this.name = name;\n    this.age = age;\n  }\n\n  abstract makeSound(): void;\n}\n\n// 在这个例子中，\"AnimalNew\" 类是一个抽象类。它定义了两个属性：name 和 age，以及一个抽象方法 makeSound()。\n\n// 现在你可以创建动物的具体子类，例如狗、猫和鸟，并实现它们自己的特殊行为。下面是一个示例：\n\nclass Dog extends AnimalNew {\n  breed: string;\n\n  constructor(name: string, age: number, breed: string) {\n    super(name, age);\n    this.breed = breed;\n  }\n\n  makeSound(): void {\n    console.log(\"Woof!\");\n  }\n}\n\nclass Cat extends AnimalNew {\n  color: string;\n\n  constructor(name: string, age: number, color: string) {\n    super(name, age);\n    this.color = color;\n  }\n\n  makeSound(): void {\n    console.log(\"Meow!\");\n  }\n}\n// 在这个例子中，Dog 类和 Cat 类都继承自 AnimalNew 抽象类，并且实现了 makeSound() 方法。\n\n// 使用抽象类的好处是它提供了一种通用的方式来定义父类，以及要求子类遵循规定并提供自己的实现。在上述例子中，所有的动物都有共同的属性和方法，但每种动物的具体实现是不同的。\n\n// 这样，你可以创建不同类型的动物对象，并调用它们的方法，例如：\n\nconst dog = new Dog(\"旺财\", 3, \"柯基\");\ndog.makeSound(); // 输出：Woof!\n\nconst cat = new Cat(\"小咪\", 2, \"灰色\");\ncat.makeSound(); // 输出：Meow!\n```\n抽象类是 TypeScript 中的一种特殊类，它不能直接被实例化，只能被其他类继承或实现。抽象类主要用于定义一些共享的属性和方法，并且可以声明一些抽象方法，这些抽象方法必须在子类中被实现。\n\n例如，如果我们有多个动物类，它们都需要具备某些共同的属性和方法，但每个动物又有自己独特的行为，这时候可以使用抽象类来定义共享的特征和抽象方法，让各个派生类实现自己的行为\n```typescript\nabstract class Animal {\n  name: string;\n  \n  constructor(name: string) {\n    this.name = name;\n  }\n  \n  abstract makeSound(): void;\n  \n  move(distance: number) {\n    console.log(`${this.name}移动了${distance}米。`);\n  }\n}\n\nclass Dog extends Animal {\n  makeSound() {\n    console.log(`${this.name}汪汪叫。`);\n  }\n}\n\nclass Cat extends Animal {\n  makeSound() {\n    console.log(`${this.name}喵喵叫。`);\n  }\n}\n\nconst dog = new Dog(\"旺财\");\ndog.makeSound(); // 输出：旺财汪汪叫。\ndog.move(10); // 输出：旺财移动了10米。\n\nconst cat = new Cat(\"咪咪\");\ncat.makeSound(); // 输出：咪咪喵喵叫。\ncat.move(5); // 输出：咪咪移动了5米。\n\n```\n",
      "properties": {
        "title": "class 类",
        "urlname": "iy5mr7og6iora1t1",
        "date": "2023-07-21 10:24:43",
        "updated": "2023-08-15 15:56:03"
      },
      "catalog": [
        {
          "title": "typescript 入门指南",
          "doc_id": "iy5mr7og6iora1t1"
        },
        {
          "title": "基础开发",
          "doc_id": "iy5mr7og6iora1t1"
        }
      ],
      "body": "",
      "realName": "iy5mr7og6iora1t1",
      "relativePath": "\\iy5mr7og6iora1t1.md"
    },
    {
      "id": 133441468,
      "doc_id": "pe1n3uneypxse0fq",
      "title": "pe1n3uneypxse0fq",
      "updated": 1697292730000,
      "body_original": "> 本文从两个方向出发：1、git提交规范；2、代码风格统一\n\n\n假如团队中的小伙伴在提交代码时没有遵循规范要求，例如只写了一个\"修改\"或\"更新，这会给团队中其他小伙伴造成困扰呢，不得不花时间查看代码和推测逻辑。\n\n不仅会浪费了时间和精力，可能会导致以下问题：\n\n1. 可读性差\n2. 维护困难\n3. 变更历史不透明\n4. 自动化工具的不兼容\n\n如何统一代码风格，规范提交呢呢？ 推荐使用 ESLint + Prettier + husky + lint-staged\n\n1、eslint ([https://www.npmjs.com/package/eslint)](https://www.npmjs.com/package/eslint))\n 代码检测工具，检测并提示错误或警告信息\n2、 husky ([https://www.npmjs.com/package/husky)](https://www.npmjs.com/package/husky))\nGit hooks 工具, 可以在执行 git 命令时，执行自定义的脚本程序\n3 、 lint-staged ([https://www.npmjs.com/package/lint-staged)](https://www.npmjs.com/package/lint-staged))\n对暂存区 (git add) 文件执行脚本 检测 校验\n4、  prettier ([https://www.npmjs.com/package/prettier)](https://www.npmjs.com/package/prettier))\n代码自动化格式化工具，更好的代码风格效果 \n建议安装 -prettierc  [https://www.npmjs.com/package/prettierrc](https://www.npmjs.com/package/prettierrc)\n快速生成pretter配置文件模板\n 【eslint和prettier冲突解决】eslint-config-prettier ([https://www.npmjs.com/package/eslint-config-prettier)](https://www.npmjs.com/package/eslint-config-prettier))\n5、 Commitizen ([https://github.com/commitizen-tools/commitizen)](https://github.com/commitizen-tools/commitizen))\n生成符合规范化提交信息的工具\n6、commitlint（[https://www.npmjs.com/package/@commitlint/config-conventional](https://www.npmjs.com/package/@commitlint/config-conventional)）\n定义提交规则， 并检测内容是否符合定义的规范！\n\n> 如项目中未有.gitgnore文件，建议先创建Git 忽略提交文件：\n\n在项目跟目录创建一个 \".gitignore\" 的文件来指定需要被忽略的文件或目录。\n以下是一个简单的例子\n```javascript\n# git配置文件-忽略提交文件\n# **/xx目录 忽略指定目录下的所有文件\n**/node_modules\n**/package-lock.json\n```\n# ESlint \neslint 是一个代码检测工具，用于检测代码中潜在的问题和错误，作用提高代码质量和规范。\n## 安装步骤：\n1、安装eslint\n```javascript\nnpm install eslint\n```\n2、快速构建 eslint 配置文件\n```javascript\nnpm init @eslint/config\n```\n参考如下gif操作：\n![](https://cdn.nlark.com/yuque/0/2023/gif/1450835/1689588272917-d952c578-3cf4-40e3-a1cb-2262b689a4db.gif#averageHue=%23f4edda&clientId=u848d7499-031f-4&from=paste&id=JCvaW&originHeight=541&originWidth=909&originalType=url&ratio=1.600000023841858&rotation=0&showTitle=false&status=done&style=none&taskId=u39a89fa8-a5a7-4928-a4c9-750feed5ef9&title=)\n执行完成后，自动生成 eslint 配置文件`.eslintrc.js` \n可在 `.eslintrc.js` 中配置 rules 定义校验规则\n```javascript\n    rules: {\n         indent: ['error', 4], // 用于指定代码缩进的方式，这里配置为使用四个空格进行缩进。\n        'linebreak-style': [0, 'error', 'windows'], // 用于指定换行符的风格，这里配置为使用 Windows 风格的换行符（\\r\\n）。\n        quotes: ['error', 'single'], // 用于指定字符串的引号风格，这里配置为使用单引号作为字符串的引号。\n        semi: ['error', 'always'], //用于指定是否需要在语句末尾添加分号，这里配置为必须始终添加分号。\n        '@typescript-eslint/no-explicit-any': ['off'] // 用于配置 TypeScript 中的 \"any\" 类型的使用规则，这里配置为关闭禁止显式使用 \"any\" 类型的检查。\n    }\n```\n# husky： \nhusky 是一个 Git 钩子（Git hooks）工具，它可以让你在 Git 事件发生时执行脚本，进行代码格式化、测试等操作。\n\n常见的钩子\n\n1. pre-commit：在执行提交操作之前触发。适合用于在提交代码之前运行代码检查、格式化等操作。\n2. commit-msg：在提交消息（Commit Message）编写完成后触发。可用于验证提交消息的格式、添加自定义规范等。\n3. pre-push：在执行推送操作之前触发。适合用于在推送代码前运行测试、构建或其他自动化流程。\n4. pre-receive：在接收到推送操作之前触发。通常可用于在推送到远程仓库之前进行更严格的代码检查和验证。\n5. prepare-commit-msg：在打开提交消息编辑器之前触发。可以用于自动生成提交消息、添加代码相关的信息等。\n6. post-commit：在提交操作完成后触发。适合用于执行提交后的自动化流程、生成文档等。\n\n具体的使用步骤如下： \n## 安装\n> 注意！husky 是git项目的钩子函数，确保当前项目有 .git 配置文件，如没有 建议 git init 初始化\n\n1. 在项目根目录下运行以下命令安装 husky：\n```\nnpm install husky --save-dev\n```\n\n2. 启用git 钩子 输入以下命令\n```javascript\nnpm pkg set scripts.prepare=\"husky install\"\n```\n安装成功后会在 package.json 文件中 script 中生成命令\n> 注意！如为自动生成需手动添加，将以下内容粘贴到 package.json 文件中\n\n```javascript\n// package.json\n{\n  \"scripts\": {\n    \"prepare\": \"husky install\"\n  }\n}\n\n```\n\n3. 创建`.husky`目录，执行如下代码\n```javascript\nnpm run prepare \n```\n如图，执行成功后，项目中生成一个 .husky 目录 \n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1689685463200-12dd2228-6741-4c33-86dd-97fc460c0a9e.png#averageHue=%23191818&clientId=u36f0cc43-ec1b-4&from=paste&height=229&id=u545add2f&originHeight=366&originWidth=696&originalType=binary&ratio=1.600000023841858&rotation=0&showTitle=false&size=25079&status=done&style=none&taskId=u4d19e05f-9a58-41c2-a19c-cff8c4f529d&title=&width=434.999993517995)\n> 注意！如未生成 .husky 目录，推荐使用命令 ` npx husky install `\n\n## 创建 Git 挂钩\n### pre-commit\n在 Git 提交之前做`eslint` 语法校验 。\n#### 1、创建钩子脚本文件\n```javascript\nnpx husky add .husky/pre-commit \"npm test\"\n```\n执执行成功，.husky 目录多出一个 pre-commit 文件\n![1G4XQYMS(L9[LGM9_NG}2)M.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1689656584308-6efa0de6-04fc-4354-a3e1-8175eeabd93a.png#averageHue=%231d1919&clientId=u01a7df34-1284-4&from=paste&height=87&id=u1a48f748&originHeight=173&originWidth=483&originalType=binary&ratio=2&rotation=0&showTitle=false&size=8428&status=done&style=none&taskId=u64189f42-36a7-4618-b082-ec9884d02df&title=&width=241.5)\n> 注意！`window`电脑输入后，可能会报错如下\n\n```javascript\nUsage:\n  husky install [dir] (default: .husky)\n  husky uninstall\n  husky set|add <file> [cmd]\n```\n解决方式，删除 \"npm test\" 重新执行\n```javascript\nnpx husky add .husky/commit-msg\n```\n#### 2、配置代码检测\ngit 提交前，执行 pre-commit  钩子脚本，进行校验代码语法、格式修复等操作。\n\n1、打开 pre-commit 文件，内容如下：\n```javascript\n#!/usr/bin/env sh\n. \"$(dirname -- \"$0\")/_/husky.sh\"\n```\n2、下方代码添加到 pre-commit 文件中。`lint-staged`模块， 用于对 git 暂存区检测\n```javascript\nnpx --no-install lint-staged\n```\n> `npx --no-install lint-staged` 是一个命令，用于在不安装 lint-staged 的情况下运行该工具。`npx --no-install`  命令用于从远程下载并执行指定的命令。\n\n\n下一个章节会详细介绍 `lint-staged`的作用和使用步骤\n# lint-staged\n\n- 作用：lint-staged 可以让你在 Git 暂存（staged）区域中的文件上运行脚本，通常用于在提交前对代码进行格式化、静态检查等操作。\n- 使用方式：你可以在项目中使用 lint-staged 配合 husky 钩子来执行针对暂存文件的脚本。具体的使用步骤如下： \n\n在项目根目录下运行以下命令安装 lint-staged：\n```\nnpm install lint-staged --save-dev\n```\n在 `package.json` 文件中添加以下配置：\n```json\n{\n  \"lint-staged\": {\n    // src/**/*.{js,jsx,ts,tsx} 校验暂存区、指定目录下的文件类型\n    // 校验命令，执行 eslint 、prettier \n    \"src/**/*.{js,jsx,ts,tsx}\": [\n      \"prettier --write\",\n      \"eslint --fix\"\n    ]\n  }\n}\n```\n\n- `\"src/**/*.{js,jsx,ts,tsx}\"` 是指定要针对的暂存文件模式，你可以根据自己的项目需求来配置。\n- `[\"prettier --write\",\"eslint --fix\"]`为校验命令，可执行 eslint 、prettier 等规则\n# prettier\nprettier 是一个代码格式化工具。prettier 与上述 husky 和 lint-staged 搭配使用，可以在提交代码之前自动格式化代码。具体的使用步骤如下： \n\n在项目根目录下运行以下命令安装 prettier：\n```\nnpm install prettier --save-dev\n```\n \n创建 `.prettierrc.js` 文件，并定义你想要的代码样式，例如：\n```javascript\nmodule.exports = {\n    semi: true,//强制在语句末尾使用分号。\n    trailingComma: 'none',//不允许在多行结构的最后一个元素或属性后添加逗号。\n    singleQuote: true,//使用单引号而不是双引号来定义字符串。\n    printWidth: 120,//指定每行代码的最大字符宽度，超过这个宽度的代码将被换行\n    tabWidth: 4//指定一个制表符（Tab）等于多少个空格。\n};\n\n```\n 这里的配置选项根据你的需求定义，具体选项可以参考 [prettier 文档](https://prettier.io/docs/en/options.html)。\n在 lint-staged 的配置中添加 `\"prettier --write\"`，例如：\n```json\n{\n  \"lint-staged\": {\n    // src/**/*.{js,jsx,ts,tsx} 校验暂存区、指定目录下的文件类型\n    // 校验命令，执行 eslint 、prettier \n    \"src/**/*.{js,jsx,ts,tsx}\": [\n      \"prettier --write\",\n      \"eslint --fix\"\n    ]\n  }\n}\n```\n 这样当你进行 GIT 提交操作时，lint-staged 将自动运行 prettier 来格式化符合规则的文件。\n\n> prettier 如不集成lint-staged中，可单独执行重新校验 \n>  `prettier --write [文件路径/模式]`\n> 1. 格式化单个文件：指定文件的完整路径，例如 prettier --write src/index.js。\n> 2. 格式化特定文件类型：使用文件模式匹配需要格式化的文件。例如，prettier --write \"src/**/*.js\"会格式化 src 目录下的所有 JavaScript 文件。\n\n### 配置 ctrl + s ，自动保存功能\n第一种，在vscode 设置里面配置\n点击Vscode的设置=>工作区=>文本编辑器\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1689589388600-64a45e9b-c35f-4b57-af36-a05ef62125fc.png#averageHue=%23282625&clientId=u848d7499-031f-4&from=paste&height=429&id=u6acdc42d&originHeight=686&originWidth=1649&originalType=binary&ratio=1.600000023841858&rotation=0&showTitle=false&size=139044&status=done&style=none&taskId=ud6048d66-884e-458b-98cf-a533e2e3f15&title=&width=1030.624984642491)\n# Commitizen \n是一个命令行工具，用于以一致的方式编写规范的提交消息。在使用Commitizen之前，你需要安装Commitizen及其适配器。\n## cz-conventional-changelog \n是Commitizen的一个适配器，它实现了符合约定式提交（Conventional Commits）规范的提交消息。该规范定义了提交消息的格式和结构，并推荐了一些常用的提交类型和范围。\n## 安装和使用步骤：\n1、确保你的项目已经初始化并安装了 npm 或 yarn。 \n2、打开命令行终端，并在项目根目录下运行以下命令来安装 `commitizen` 和 `cz-conventional-changelog`：\n使用 npm： \n```\nnpm install --save-dev commitizen cz-conventional-changelog\n```\n\n使用 yarn：  \n```javascript\nyarn add --dev commitizen cz-conventional-changelog\n```\n 3、安装完成后，在 `package.json` 中添加一个 `config.commitizen` 的字段，并设置它的值为 `cz-conventional-changelog`。\n示例如下： \n```json\n\"config\": {\n  \"commitizen\": {\n    \"path\": \"cz-conventional-changelog\"\n  }\n}\n```\n \n 在 `package.json` 中的 `scripts` 字段中添加一个 `commit` 的命令。\n示例如下： \n```json\n\"scripts\": {\n  \"commit\": \"git-cz\"\n}\n```\n\n4、这将允许你使用 `npm run commit` 或 `yarn commit` 命令来进行交互式的提交。\n \n现在，你可以使用 `npm run commit` 或 `yarn commit` 命令来进行提交。这将打开一个交互式的界面，引导你填写提交消息。\n\n**案例如下：**\n1、提交修改文件\n```javascript\ngit add . \n```\n 2、开始交互式提交，填写规范信息\n```javascript\nnpm run commit\n```\n3、选择提交类型\n```javascript\n? Select the type of change that you're committing: (Use arrow keys)\n> feat:     A new feature //新功能\n  fix:      A bug fix //错误修复\n  docs:     Documentation only changes //仅文档更改\n  style:    [样式]Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)\n  refactor: [重构] A code change that neither fixes a bug nor adds a feature\n  perf:     A code change that improves performance\n  test:     Adding missing tests or correcting existing tests\n```\n4、根据提示填写内容，可选择空格跳过\n```javascript\n? What is the scope of this change // 此更改的范围是什么\n? Write a short, imperative tense description of the change//【必填】 简短的描述这个变化\n? Provide a longer description of the change//提供变更的详细说明：\n? Are there any breaking changes? //有什么突破性的变化吗？【y/n】\n? Does this change affect any open issues? (y/N) //此更改是否会影响任何悬而未决的问题（是/否）\n\n// 完成提交，输出打印日志：\n[master 2cf55e0] docs: 修改commitzen文档\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\n\n```\n\n当你完成提交消息后，Commitizen 会自动生成符合规范的提交消息，并将其添加到 Git commit 中。\n根据 `cz-conventional-changelog` 的规范，提交消息需要包括类型（type）、范围（scope）、简短的描述（subject）和可选的详细描述（body）。 \n参考\n[https://blog.csdn.net/fightingLKP/article/details/126695679](https://blog.csdn.net/fightingLKP/article/details/126695679)\n## commitlint（可忽略）\n作用：Commitlint 是一个用于校验提交信息格式的工具。它通过定义一组规则来检查提交信息是否符合指定的约定，比如要求提交信息的首行必须以特定类型开头，自定义字符长度限制等。\n使用方式：在项目中配置 Commitlint 规则，然后在提交代码时，Commitlint 会自动校验提交信息是否符合规定的格式。\n\nCommitlint 提供了一些常用的规则，用于检查和约束提交信息的格式和内容。以下是一些常用的 Commitlint 规则示例：\n先安装依赖\n```javascript\nnpm i @commitlint/cli\n```\n在项目根目录创建， commitlint.config.js 文件\n\n1.  `type-enum`: 检查提交消息的类型是否在预定义的列表中选择。 \n```javascript\nmodule.exports = {\n  extends: ['@commitlint/config-conventional'],\n  rules: {\n    'type-enum': [\n      2,\n      'always',\n      ['feat', 'fix', 'docs', 'chore', 'style', 'refactor', 'test', 'revert'],\n    ],\n  },\n};\n```\n\n在上面的示例中，规定了允许的提交类型为 `feat`, `fix`, `docs`, `chore`, `style`, `refactor`, `test`, `revert`。 \n\n2.  `scope-enum`: 检查提交消息的作用域（scope）是否在预定义的列表中选择。 \n```javascript\nmodule.exports = {\n  extends: ['@commitlint/config-conventional'],\n  rules: {\n    'scope-enum': [2, 'always', ['frontend', 'backend', 'database']],\n  },\n};\n```\n\n在这个示例中，规定了允许的作用域为 `frontend`, `backend`, `database`。 \n\n3.  `subject-max-length`: 检查提交消息的主题部分（subject）的最大长度。 \n```javascript\nmodule.exports = {\n  extends: ['@commitlint/config-conventional'],\n  rules: {\n    'subject-max-length': [2, 'always', 100],\n  },\n};\n```\n\n在这个示例中，规定了提交消息主题的最大长度为 100 个字符。 \n\n以上只是一些常用的 Commitlint 规则示例，你可以根据项目的需求进行自定义设置。在配置文件中，使用 `rules` 属性来定义规则，并根据需要设置规则的级别（0、1、2）、决策逻辑（'always'、'never'）和参数值（例如类型、最大长度等）。\n\n# 解决 eslint 和prettier 冲突\n有时，ESLint 的规则和 Prettier 的规则可能存在冲突，导致代码格式化不一致。使用 eslint-config-prettier 可以关闭 ESLint 中与 Prettier 冲突的规则。\n\n```javascript\nnpm i  eslint-config-prettier eslint-plugin-prettier -D\n```\n\n- eslint-config-prettier ：关闭eslint中与prettier相互冲突的规则。\n- eslint-plugin-prettier  : 允许eslint用prettier格式化代码的能力。 安装依赖并修改.eslintrc文件\n\n在 `.eslintrc.js` 文件中，在`extends`配置基础上，追加内容\n```javascript\n// .eslintrc\n{\n   //  \n - \"extends\": [\"eslint:recommended\"] // 原先配置\n + \"extends\": [\"eslint:recommended\",  \"prettier\"] // 添加配置\n  // 其余的配置\n}\n```\n同理，`plugins` 配置基础上，追加 `prettier`\n```javascript\n\"plugins\": [\n        \"@typescript-eslint\",\n        \"react\",\"prettier\" // 添加prettier插件\n    ],\n```\n# 常见报错\n## @typescript-eslint/dot-notation\n### 错误日志：\nError: Error while loading rule '@typescript-eslint/dot-notation':\nYou have used a rule which requires parserServices to be generated. You must therefore provide a value for the \"parserOptions.project\" property for @typescript-eslint/parser.\n\n### 错误原因：\n这个错误是由于在使用 @typescript-eslint/dot-notation 规则时，没有为 @typescript-eslint/parser 提供正确的 parserOptions.project 属性值引起的。\n### 解决方式：\neslint 配置文件中，设置一个有效的 parserOptions.project ，指向你的 TypeScript 配置文件（tsconfig.json）。\n```javascript\nparserOptions: {\n    project: './tsconfig.json',\n  },\n```\n\n## @typescript-eslint\" uniquely.\n### 错误日志：\nESLint couldn't determine the plugin \"@typescript-eslint\" uniquely.\n### 解决方式:\n1、重新安装 eslint相关依赖\n```javascript\nnpm cache clean --force //先清除缓存依赖\n```\n```javascript\nnpm install --save-dev eslint @typescript-eslint/eslint-plugin @typescript-eslint/parser prettier eslint-config-prettier eslint-plugin-prettier\n```\n2、`.eslintrc.js` 文件，配置 root：true\n> root 被设置为 true 时，ESLint 使用当前配置文件作为根配，将停止在父级目录中查找其他配置文件。![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1689694020441-1646bb75-7033-4fa9-9a1e-d123b458cfc3.png#averageHue=%23232020&clientId=u36f0cc43-ec1b-4&from=paste&height=199&id=u4bad5947&originHeight=318&originWidth=1345&originalType=binary&ratio=1.600000023841858&rotation=0&showTitle=false&size=27025&status=done&style=none&taskId=u3c991343-23f2-4419-9b03-4fd076be9e0&title=&width=840.6249874737116)\n\n\n## Warning: React version not specified\n使用了 eslint-plugin-react 插件，未在配置文件中指定 React 版本，会遇到下述警告信息。\nWarning: React version not specified in eslint-plugin-react settings. See [https://github.com/jsx-eslint/eslint-plugin-react#configuration](https://github.com/jsx-eslint/eslint-plugin-react#configuration) .\n在 `.eslintrc.js`添加声明\n```javascript\n\"settings\": {\n        \"react\": {\n          \"version\": \"detect\" //detect 自动检测react版本\n        }\n      },\n```\n\n",
      "properties": {
        "title": "前端规范指南，让团队代码如出一辙！ESLint + Prettier + husky + lint-staged",
        "urlname": "pe1n3uneypxse0fq",
        "date": "2023-07-17 15:39:46",
        "updated": "2023-10-14 22:12:10"
      },
      "catalog": [
        {
          "title": "环境搭建",
          "doc_id": "pe1n3uneypxse0fq"
        }
      ],
      "body": "",
      "realName": "pe1n3uneypxse0fq",
      "relativePath": "\\pe1n3uneypxse0fq.md"
    },
    {
      "id": 136256113,
      "doc_id": "veagx91gr9qnb585",
      "title": "veagx91gr9qnb585",
      "updated": 1692012595000,
      "body_original": "# 场景\n执行后git add . 、git commit 也设置了远端仓库地址，最后推送远端仓库报错，如下：\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1692012449859-b24e9932-51dc-4794-b6b9-83f4d975c51b.png#averageHue=%231e1b10&clientId=u8f16b9ad-634f-4&from=paste&height=179&id=ZEhjb&originHeight=358&originWidth=1629&originalType=binary&ratio=2&rotation=0&showTitle=false&size=66661&status=done&style=none&taskId=uf5db4a28-fce2-4b16-870c-be9e149103c&title=&width=814.5)\n# 问题原因：\n云端仓库已存在内容，当前分支的最新提交落后于远程仓库的提交历史。\n# 如何解决？\n强制推送，使用 `--force`\n```javascript\ngit push -force -u origin \"master\"\n```\n",
      "properties": {
        "title": "git 首次提交远端仓库报错",
        "urlname": "veagx91gr9qnb585",
        "date": "2023-08-14 19:27:14",
        "updated": "2023-08-14 19:29:55"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "veagx91gr9qnb585"
        }
      ],
      "body": "",
      "realName": "veagx91gr9qnb585",
      "relativePath": "\\veagx91gr9qnb585.md"
    },
    {
      "id": 136157960,
      "doc_id": "qg566fr0qxrmwzod",
      "title": "qg566fr0qxrmwzod",
      "updated": 1691938055000,
      "body_original": "![_581060003__93b1eb285ae2f8e9602ac69e55220c57_310464966_IMG20230813224201_0_xg_0.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/1450835/1691937999945-a58f5a41-c8ab-4ca1-8814-8dd3749638a0.jpeg#averageHue=%23333c3c&clientId=u2ad29bb7-63ce-4&from=paste&height=429&id=u83743322&originHeight=857&originWidth=1920&originalType=binary&ratio=2&rotation=0&showTitle=false&size=222116&status=done&style=none&taskId=u494a082f-2d5f-400d-9caf-85581df769e&title=&width=960)\n ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1691938050568-c81ec9fe-13e0-490f-b36f-16a4e410c1e9.png#averageHue=%23f6f5e8&clientId=u2ad29bb7-63ce-4&from=paste&height=105&id=ub9f0e38b&originHeight=209&originWidth=816&originalType=binary&ratio=2&rotation=0&showTitle=false&size=9935&status=done&style=none&taskId=u89196124-1c4e-430c-b87c-db8a3713272&title=&width=408)\n",
      "properties": {
        "title": "下包报错",
        "urlname": "qg566fr0qxrmwzod",
        "date": "2023-08-13 22:46:32",
        "updated": "2023-08-13 22:47:35"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "qg566fr0qxrmwzod"
        }
      ],
      "body": "",
      "realName": "qg566fr0qxrmwzod",
      "relativePath": "\\qg566fr0qxrmwzod.md"
    },
    {
      "id": 136148992,
      "doc_id": "an8dle1vg88kkprx",
      "title": "an8dle1vg88kkprx",
      "updated": 1691929166000,
      "body_original": "如下图，vsode中安装 插件，输入缩写\n![%S9F74Z%4{LI$(AR~JR)Y0O.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1691929144915-ed804524-b1d0-4b48-a847-fc57c74337ea.png#averageHue=%23222121&clientId=uede0c094-0910-4&from=paste&height=521&id=lgUJ4&originHeight=1042&originWidth=1725&originalType=binary&ratio=2&rotation=0&showTitle=false&size=297504&status=done&style=none&taskId=uefd79d7a-d4b3-41ae-bf89-ae7d66f9782&title=&width=862.5)\n",
      "properties": {
        "title": "vscode中生成ts函数组件",
        "urlname": "an8dle1vg88kkprx",
        "date": "2023-08-13 20:18:50",
        "updated": "2023-08-13 20:19:26"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "an8dle1vg88kkprx"
        }
      ],
      "body": "",
      "realName": "an8dle1vg88kkprx",
      "relativePath": "\\an8dle1vg88kkprx.md"
    },
    {
      "id": 136145796,
      "doc_id": "fer2ogyut4tmc926",
      "title": "fer2ogyut4tmc926",
      "updated": 1694250317000,
      "body_original": "> 执行git add .的时候出现的警告\n\n这个警告是由于 Git 在处理 .husky/pre-commit 文件时注意到了行尾标识符（end-of-line）的差异导致的。警告的意思是 Git 将会替换行尾的 LF（Line Feed）标识符为 CRLF（Carriage Return Line Feed）标识符。\n\n这个警告通常在跨平台开发中出现，因为不同操作系统对于换行符的表示方式不同。Unix 和 Linux 系统使用 LF 作为行尾标识符，而 Windows 系统使用 CRLF。\n\n虽然这个警告不会导致脚本无法运行，但建议按以下方式修改\n\n在当前项目目录下，打开命令行，输入\n```javascript\n// Linux/macOS系统下在提交代码时自动将CRLF转换为LF\ngit config --global core.autocrlf input\n\n// Windows系统下在提交代码时自动将LF转换为CRLF\ngit config --global core.autocrlf true\n \n```\n",
      "properties": {
        "title": "Git add. 控制台警告",
        "urlname": "fer2ogyut4tmc926",
        "date": "2023-08-13 18:59:29",
        "updated": "2023-09-09 17:05:17"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "fer2ogyut4tmc926"
        }
      ],
      "body": "",
      "realName": "fer2ogyut4tmc926",
      "relativePath": "\\fer2ogyut4tmc926.md"
    },
    {
      "id": 136056260,
      "doc_id": "rdgk090rs7uh9bwd",
      "title": "rdgk090rs7uh9bwd",
      "updated": 1691829026000,
      "body_original": "如下图，以管理员运行 windows PowerSell \n输入以下命令\n```javascript\nset-executionpolicy remotesigned\n```\n![L}SSDZ}5V44~)0JF_7EC7DP.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1691809794461-c5b952ab-ac74-4830-878c-88c876d67dff.png#averageHue=%23c8c7c7&clientId=ucb74910e-dba5-4&from=paste&height=588&id=iACaB&originHeight=1324&originWidth=1718&originalType=binary&ratio=2.25&rotation=0&showTitle=false&size=183956&status=done&style=none&taskId=ud9a1eac5-8d8b-4ed0-918c-a58a5ca2144&title=&width=763.5555555555555)\n\n\n",
      "properties": {
        "title": "tsc 无法运行",
        "urlname": "rdgk090rs7uh9bwd",
        "date": "2023-08-12 11:09:30",
        "updated": "2023-08-12 16:30:26"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "rdgk090rs7uh9bwd"
        }
      ],
      "body": "",
      "realName": "rdgk090rs7uh9bwd",
      "relativePath": "\\rdgk090rs7uh9bwd.md"
    },
    {
      "id": 135898591,
      "doc_id": "kufwxvhfwtsvth7o",
      "title": "kufwxvhfwtsvth7o",
      "updated": 1691659331000,
      "body_original": "",
      "properties": {
        "title": "TS不能将类型“any[]”分配给类型“never[]”",
        "urlname": "kufwxvhfwtsvth7o",
        "date": "2023-08-10 17:22:06",
        "updated": "2023-08-10 17:22:11"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "kufwxvhfwtsvth7o"
        }
      ],
      "body": "",
      "realName": "kufwxvhfwtsvth7o",
      "relativePath": "\\kufwxvhfwtsvth7o.md"
    },
    {
      "id": 135707663,
      "doc_id": "qlo4yi98lu48nycz",
      "title": "qlo4yi98lu48nycz",
      "updated": 1691568057000,
      "body_original": "# 路由配置项：\n按系统模块的拆分子路由，创建文件夹，最终在RouterConfig.ts 进行合并为总路由。\n# 路由守卫组件：\n检测token、预加载\n\n- \n\n",
      "properties": {
        "title": "如何设计react路由系统",
        "urlname": "qlo4yi98lu48nycz",
        "date": "2023-08-09 00:53:53",
        "updated": "2023-08-09 16:00:57"
      },
      "catalog": [
        {
          "title": "react高阶使用",
          "doc_id": "qlo4yi98lu48nycz"
        }
      ],
      "body": "",
      "realName": "qlo4yi98lu48nycz",
      "relativePath": "\\qlo4yi98lu48nycz.md"
    },
    {
      "id": 135703430,
      "doc_id": "afmy86kvqwltgq5c",
      "title": "afmy86kvqwltgq5c",
      "updated": 1691506715000,
      "body_original": "参考\n[react-router-鉴权页面闪现](https://www.yuque.com/itwangtian/ycsiao/cg2svaaug21hrh90?view=doc_embed)\n",
      "properties": {
        "title": "封装路由守卫组件",
        "urlname": "afmy86kvqwltgq5c",
        "date": "2023-08-08 22:57:32",
        "updated": "2023-08-08 22:58:35"
      },
      "catalog": [
        {
          "title": "案例开发",
          "doc_id": "afmy86kvqwltgq5c"
        }
      ],
      "body": "",
      "realName": "afmy86kvqwltgq5c",
      "relativePath": "\\afmy86kvqwltgq5c.md"
    },
    {
      "id": 135196179,
      "doc_id": "pgk56d22hdw601yr",
      "title": "pgk56d22hdw601yr",
      "updated": 1691046152000,
      "body_original": "",
      "properties": {
        "title": "手写useState",
        "urlname": "pgk56d22hdw601yr",
        "date": "2023-08-03 15:02:19",
        "updated": "2023-08-03 15:02:32"
      },
      "catalog": [
        {
          "title": "react源码解析",
          "doc_id": "pgk56d22hdw601yr"
        }
      ],
      "body": "",
      "realName": "pgk56d22hdw601yr",
      "relativePath": "\\pgk56d22hdw601yr.md"
    },
    {
      "id": 135206541,
      "doc_id": "nhv8wotm3138tar0",
      "title": "nhv8wotm3138tar0",
      "updated": 1694250850000,
      "body_original": "以一种对象结构的方式描述页面。通过比对虚拟dom的数据结构差异，来更新实际dom，避免了传统dom中的重绘问题。\n# 1. 原生DOM所带来的问题\n\n使用原生DOM进行操作时，每次更新界面都需要重新计算整个DOM树的结构和样式，然后进行重新渲染，这样的操作会带来性能上的开销。\n\n举一个例子，假设我们需要向一个列表中添加 1000 个列表项。如果使用原生 DOM 进行操作，每次添加列表项都需直接对实际 DOM 进行插入操作，这样做会导致页面渲染变慢，用户体验下降。\n# 2. 虚拟DOM是什么\n\n虚拟DOM是一个轻量级的JavaScript对象，它是对真实DOM的一种抽象表示。React通过使用虚拟DOM来跟踪和记录对真实DOM的修改，然后批量高效地更新真实DOM。\n\n## 虚拟dom vs 真实dom\n\n### 结构对比\n原生js中的 doucment.createEelment和 react.reacteElement 创建元素，打印出来看下数据结构\n```javascript\n    const VDOM = React.createElement('div', {}, '小杜杜')\n    const DOM = document.createElement(\"div\");\n    DOM.innerHTML = '真帅呀'\n    console.log(`虚拟DOM：`, VDOM)\n    console.log(`真实DOM：`, DOM)\n\n```\n### 流程对比\n在传统的Web应用中，数据的变化会实时地更新到用户界面中，于是每次数据微小的变化都会引起DOM的渲染。\n\n而虚拟DOM的目：是将所有的操作聚集到一块，计算出所有的变化后，统一更新一次虚拟DOM\n\n举一个例子，假设我们需要向一个列表中添加 1000 个列表项。如果使用原生 DOM 进行操作，渲染1000次，而使用虚拟dom只需要要渲染一次。\n\n## react中组件名为什么大写？\n用于区分react组件和原生标签，在react中渲染组件是使用bebal来解析jsx内容，大写命名组件，是告诉jsx将组件渲染真实dom\n# 3. 虚拟DOM大致工作流程\n\n- React首次渲染时，会构建整个组件树的虚拟DOM。\n- 当状态发生变化时，React会生成新的虚拟DOM树。\n- React会将新旧虚拟DOM树进行对比，找出需要更新的部分。\n- 根据对比结果，React会生成一系列DOM操作指令。\n- React将这些指令应用到真实DOM上，实现页面的局部更新。\n\n# 4. 虚拟DOM是如何解决问题的\n\n虚拟DOM通过在JavaScript中使用轻量级的虚拟对象来代替真实DOM，实现了对真实DOM的抽象。通过比较新旧虚拟DOM树的差异，React能够准确计算出需要更新的部分，并只对这些部分进行DOM操作，避免了不必要的DOM操作开销，提高了性能。\n\n# 5. 虚拟DOM真的能带来更好的性能吗？\n\n是的，虚拟DOM能够带来更好的性能。通过对比新旧虚拟DOM树，React可以最小化DOM的操作次数，只对需要更新的部分进行操作，从而减少了浏览器重绘的次数，提升了性能效率。\n\n# 6. 虚拟DOM的价值到底是什么\n\n虚拟DOM的价值主要体现在两个方面：\n\n- 提高性能: 通过最小化DOM操作的次数，优化了页面的渲染性能，提升了用户体验。\n- 更方便的开发: 使用虚拟DOM可以将关注点从底层的DOM操作转移到组件开发上，使得开发者更关注组件的构建和交互逻辑，从而提高开发效率。\n\n# 7. 虚拟DOM用在哪里\n\n虚拟DOM主要被应用于React框架中，用于构建用户界面。React使用虚拟DOM作为中间层，负责管理组件的状态变化，并高效地更新页面的显示。\n\n# 8. 简单实现虚拟DOM案例\n\n这是一个简单的虚拟DOM案例，用于展示虚拟DOM的基本原理，仅供参考：\n\n```javascript\n// 定义虚拟DOM元素的构造函数\nfunction VNode(tagName, props, children) {\n  this.tagName = tagName;\n  this.props = props;\n  this.children = children;\n}\n\n// 渲染虚拟DOM\nfunction render(element) {\n  if (typeof element === 'string') {\n    // 如果是字符串类型，直接返回文本节点\n    return document.createTextNode(element);\n  }\n  \n  // 创建对应的真实DOM\n  const dom = document.createElement(element.tagName);\n  \n  // 设置props中的属性\n  for (let propName in element.props) {\n    dom.setAttribute(propName, element.props[propName]);\n  }\n  \n  // 递归渲染子节点\n  element.children.forEach(child => {\n    dom.appendChild(render(child));\n  });\n  \n  return dom;\n}\n\n// 创建虚拟DOM\nconst element = new VNode('div', { id: 'app' }, [\n  new VNode('h1', null, ['Hello, World!']),\n  new VNode('p', null, ['This is a virtual DOM example.'])\n]);\n\n// 渲染虚拟DOM到真实DOM节点\nconst app = document.getElementById('app');\napp.appendChild(render(element));\n```\n\n这是一个简单的虚拟DOM案例，通过构造虚拟DOM元素，并使用`render`函数将虚拟DOM渲染为真实DOM，从而实现了页面的展示。当需要更新页面时，只需要更新虚拟DOM，然后重新调用`render`函数即可。\n\n",
      "properties": {
        "title": "终于搞懂虚拟Dom啦！",
        "urlname": "nhv8wotm3138tar0",
        "date": "2023-08-03 16:02:50",
        "updated": "2023-09-09 17:14:10"
      },
      "catalog": [
        {
          "title": "react源码解析",
          "doc_id": "nhv8wotm3138tar0"
        }
      ],
      "body": "",
      "realName": "nhv8wotm3138tar0",
      "relativePath": "\\nhv8wotm3138tar0.md"
    },
    {
      "id": 133878116,
      "doc_id": "ozukh6zecsqvagsm",
      "title": "ozukh6zecsqvagsm",
      "updated": 1690875557000,
      "body_original": "## 1. 简介\n\n在 TypeScript 中，枚举（Enum）是一种定义常量的方式，可以用简洁、可读性强的方式，定义一组命固定集合的值（常量）。\n\n在 JavaScript 中，在没有枚举语言特性的情况下，常常使用以下方法来表示一组常量：\n\n1.  使用命名的变量或常量。 \n```javascript\nconst RED = \"red\";\nconst GREEN = \"green\";\nconst BLUE = \"blue\";\n```\n\n这种方式可能容易出错，因为限制了变量的作用域，而且可能会有命名冲突或拼写错误等问题。 \n\n2.  使用简单的对象字面量。 \n```javascript\nconst Colors = {\n  RED: \"red\",\n  GREEN: \"green\",\n  BLUE: \"blue\"\n};\n```\n\n使用对象字面量可以提供一些命名空间的支持，但并不能限制变量值的修改，这意味着你仍然可以通过赋值操作改变枚举值。 \n\n这就是 TypeScript 中枚举的作用所在：它提供了一种更强大、更安全的方式来定义一组有限的常量。\n\n枚举在 TypeScript 中的优势和解决了 JavaScript 中的一些痛点包括：\n\n1.  类型安全性：枚举在 TypeScript 中是具有类型的，编译器可以在编译时进行类型检查，确保只使用枚举中定义的值。 \n2.  命名空间和作用域：枚举在一定程度上提供了命名空间的支持，可以更好地组织和管理常量集合，并且不会发生命名冲突。 \n3.  可读性：通过使用枚举，可以直观地了解代码中某个值的含义，提高了代码的可读性和可维护性。 \n4.  自文档化：枚举可以作为文档的一部分，提供了一个可供其他开发人员查阅的可扩展的集合。 \n\n总之，TypeScript 中的枚举提供了一种更加结构化和类型安全的方式，来表示固定集合的值，并解决了 JavaScript 中使用常量时的一些问题。\n\n## 2. 基本用法\n\n枚举的基本用法是定义一个枚举类型，然后使用它来声明变量或函数参数。下面是一个基本的示例：\n\n```typescript\n// 定义一个表示颜色的枚举\nenum Color {\n  Red,\n  Green,\n  Blue\n}\n\n// 使用枚举类型声明变量\nlet myColor: Color = Color.Green;\nconsole.log(myColor); // 输出: 1\n```\n\n在这个例子中，我们定义了一个枚举类型 `Color`，它包含了三个成员：`Red`、`Green` 和 `Blue`。\n\n默认情况下，枚举成员的值从 `0` 开始自动递增，所以 `Red` 的值是 `0`，`Green` 的值是 `1`，`Blue` 的值是 `2`。\n\n我们可以使用枚举类型来声明变量 `myColor`，并将它的值设置为 `Color.Green`。最后，我们打印了 `myColor` 的值，结果是 `1`。\n\n## 3. 常数项和计算所得项\n\n在枚举中，成员可以是常数项或计算所得项。\n\n常数项是声明枚举时就已经指定好的值，这些值不能被修改。如果没有给常数项赋值，它们将按照从 `0` 开始的顺序递增。\n\n计算所得项是根据表达式在运行时计算出的值，可以用于根据之前定义的常数项进行计算。计算所得项必须在表达式中使用，不能直接赋值给其他成员。\n\n以下是一个示例，演示了常数项和计算所得项的用法：\n\n```typescript\nenum Direction {\n  Up, // 常数项，默认值为 0\n  Down, // 常数项，默认值为 1\n  Left = 10, // 常数项指定具体值为 10\n  Right = Left + 1 // 计算所得项，值为 11（Left 的值加 1）\n}\n\nconsole.log(Direction.Up); // 输出: 0\nconsole.log(Direction.Left); // 输出: 10\nconsole.log(Direction.Right); // 输出: 11\n```\n\n这个例子中，`Direction` 枚举包含了四个成员。\n\n`Up` 和 `Down` 是常数项，默认情况下它们的值分别是 `0` 和 `1`。`Left` 是一个常数项，我们明确地将它的值设置为 `10`。`Right` 是一个计算所得项，它的值是 `Left + 1`，即 `10 + 1`，结果是 `11`。\n\n## 4. 常数枚举\n\n常数枚举是一种特殊类型的枚举，在编译时会被删除，并且对枚举成员的引用会被替换为具体的值。常数枚举可以在一些性能优化和减少代码量的情况下使用。\n\n下面是一个示例，展示了常数枚举的用法：\n\n```typescript\nconst enum Size {\n  Small,\n  Medium,\n  Large\n}\n\nfunction printSize(size: Size): void {\n  console.log(size);\n}\n\nprintSize(Size.Small); // 编译后会直接替换为具体的值\n```\n\n在这个例子中，我们使用 `const enum` 关键字定义了一个常数枚举 `Size`，它包含三个成员。\n\n`printSize` 函数接受一个参数 `size`，类型为 `Size` 枚举。在函数体内，我们打印了 `size` 的值。由于 `Size` 是一个常数枚举，在编译时会被直接替换为具体的值。\n\n所以，当我们调用 `printSize(Size.Small)` 时，编译后的代码将直接打印 `0`。\n\n## 5. 实战开发案例\n\n让我们以一个实战开发案例来综合应用学到的 TypeScript 枚举知识。\n\n假设你正在开发一个游戏，游戏中有不同种类的怪物，每个怪物都有不同的属性。我们可以使用枚举来表示不同种类的怪物以及它们的属性。\n\n以下是一个示例代码：\n\n```typescript\nenum MonsterType {\n  Goblin,\n  Orc,\n  Troll\n}\n\ninterface Monster {\n  type: MonsterType;\n  name: string;\n  health: number;\n  attack: number;\n}\n\nfunction createMonster(monsterType: MonsterType, name: string): Monster {\n  let monster: Monster;\n\n  switch (monsterType) {\n    case MonsterType.Goblin:\n      monster = { type: monsterType, name, health: 10, attack: 5 };\n      break;\n    case MonsterType.Orc:\n      monster = { type: monsterType, name, health: 20, attack: 10 };\n      break;\n    case MonsterType.Troll:\n      monster = { type: monsterType, name, health: 30, attack: 15 };\n      break;\n    default:\n      throw new Error(\"未知的怪物类型\");\n  }\n\n  return monster;\n}\n\nconst goblin = createMonster(MonsterType.Goblin, \"格鲁皮\");\nconsole.log(goblin);\n```\n\n在这个案例中，我们定义了一个枚举类型 `MonsterType` 来表示不同种类的怪物。\n\n\n",
      "properties": {
        "title": "枚举",
        "urlname": "ozukh6zecsqvagsm",
        "date": "2023-07-21 10:25:16",
        "updated": "2023-08-01 15:39:17"
      },
      "catalog": [
        {
          "title": "typescript 入门指南",
          "doc_id": "ozukh6zecsqvagsm"
        },
        {
          "title": "基础开发",
          "doc_id": "ozukh6zecsqvagsm"
        }
      ],
      "body": "",
      "realName": "ozukh6zecsqvagsm",
      "relativePath": "\\ozukh6zecsqvagsm.md"
    },
    {
      "id": 134613718,
      "doc_id": "rai6wzr3c4mefzyg",
      "title": "rai6wzr3c4mefzyg",
      "updated": 1690516208000,
      "body_original": "",
      "properties": {
        "title": "支付宝支付",
        "urlname": "rai6wzr3c4mefzyg",
        "date": "2023-07-28 11:50:03",
        "updated": "2023-07-28 11:50:08"
      },
      "catalog": [
        {
          "title": "案例开发",
          "doc_id": "rai6wzr3c4mefzyg"
        }
      ],
      "body": "",
      "realName": "rai6wzr3c4mefzyg",
      "relativePath": "\\rai6wzr3c4mefzyg.md"
    },
    {
      "id": 134435499,
      "doc_id": "ftvzk74gnak2g6w8",
      "title": "ftvzk74gnak2g6w8",
      "updated": 1694250362000,
      "body_original": "正确安装了 `redux-thunk`    模块，但仍然出现此错误，可能是由于缺少类型声明文件的原因。在 TypeScript 项目中，为了获得类型检查的支持，通常需要安装相应的类型声明文件。\n\n对于 'redux-thunk'，它的类型声明文件为 '@types/redux-thunk'。你可以检查你的项目中是否已经安装了这个类型声明文件。如果尚未安装，请运行以下命令来安装它：\n使用 npm：\n```jsx\nnpm install --save-dev @types/redux-thunk\n```\n",
      "properties": {
        "title": "ts安装模块总是报错！原因竟然是这个！",
        "urlname": "ftvzk74gnak2g6w8",
        "date": "2023-07-26 16:23:29",
        "updated": "2023-09-09 17:06:02"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "ftvzk74gnak2g6w8"
        }
      ],
      "body": "",
      "realName": "ftvzk74gnak2g6w8",
      "relativePath": "\\ftvzk74gnak2g6w8.md"
    },
    {
      "id": 134340096,
      "doc_id": "vhino37ev8g0zcvs",
      "title": "vhino37ev8g0zcvs",
      "updated": 1690288212000,
      "body_original": "在 React 函数组件中，可以通过 `props` 对象来接收传递给组件的属性（props）。以下是一些常见的 `props`：\n\n1. 自定义属性：\n你可以根据需要在组件上定义任意数量的自定义属性，并在父组件中传递给子组件。子组件可以通过 `props` 对象来访问这些属性。\n\n```jsx\nfunction MyComponent(props) {\n  return <div>{props.name}</div>;\n}\n\n// 在父组件中使用 MyComponent，并传递 name 属性\n<MyComponent name=\"John\" />\n```\n\n2. 子组件：\n在组件的内容中可以包含一个或多个子组件。这些子组件可以通过 `props.children` 属性来访问。\n\n```jsx\nfunction ParentComponent(props) {\n  return <div>{props.children}</div>;\n}\n\n// 在父组件中使用 ParentComponent，并传递子组件作为其内容\n<ParentComponent>\n  <ChildComponent1 />\n  <ChildComponent2 />\n</ParentComponent>\n```\n\n3. 回调函数：\n你可以将函数作为属性传递给子组件，以便子组件在需要时调用该函数。这通常用于实现交互和事件处理。\n\n```jsx\nfunction ParentComponent(props) {\n  const handleChildEvent = () => {\n    // 处理子组件事件\n  };\n\n  return <ChildComponent onClick={handleChildEvent} />;\n}\n\nfunction ChildComponent(props) {\n  return <button onClick={props.onClick}>Click</button>;\n}\n```\n\n这些只是一些基本的示例，实际上你可以根据需要在组件中使用各种不同的属性。在函数组件中，`props` 对象是一个包含传递给组件的属性的 JavaScript 对象。你可以根据具体情况来决定如何在组件中使用这些属性。\n",
      "properties": {
        "title": "react 函数组件中 props应用",
        "urlname": "vhino37ev8g0zcvs",
        "date": "2023-07-25 20:29:41",
        "updated": "2023-07-25 20:30:12"
      },
      "catalog": [
        {
          "title": "react基础开发",
          "doc_id": "vhino37ev8g0zcvs"
        }
      ],
      "body": "",
      "realName": "vhino37ev8g0zcvs",
      "relativePath": "\\vhino37ev8g0zcvs.md"
    },
    {
      "id": 134337678,
      "doc_id": "bgd0siymr5kortqz",
      "title": "bgd0siymr5kortqz",
      "updated": 1690286939000,
      "body_original": "# 函数名称\n按照惯例，通常将事件处理程序命名为 handle，后接事件名。你会经常看到 onClick={handleClick}，onMouseEnter={handleMouseEnter} 等。\n\n| 传递一个函数（正确） | 调用一个函数（错误） |\n| --- | --- |\n| <button onClick={() => alert('...')}> | <button onClick={alert('...')}> |\n\n如果按如下方式传递内联代码，并不会在点击时触发，而是会在每次组件渲染时触发：\n```\n// 这个 alert 在组件渲染时触发，而不是点击时触发！\n\n<button onClick={alert('你点击了我！')}>\n```\n如果你想要定义内联事件处理函数，请将其包装在匿名函数中，如下所示：\n```\n<button onClick={() => alert('你点击了我！')}>\n```\n## 参数传参：\n### 1、箭头函数中执行\n```typescript\n\nfunction handeClick(data){\n  alert(data)\n}\n<button onClick={()=>handeClick('点我')}> 点我 </butotn>\n```\n箭头函数，都会创建一个新的函数实例，因此容易引起性能问题。但是在大多数情况下，性能影响并不显著。\n### 2、推荐写法：`bind`方法\n在这种情况下，我们使用 Function.prototype.bind 方法来绑定 handleClick 函数的上下文为 null，并传递参数 param\n```typescript\n\nfunction handeClick(data){\n  alert(data)\n}\n<button onClick={handeClick.bind(null,'点我\t')}>点我</button>\n```\n### 3、错误写法\n以下代码中handleClick 会在渲染时立即执行\n```typescript\n<button onClick={handeClick('韩庆元')>点我</button>\n```\n这种行为与 React 的事件处理机制不一致。\n**在 React 中，事件处理函数应该是一个函数引用，而不是一个函数的调用结果**。当你使用 button onClick={handeClick('韩庆元')} 这样的方式时，实际上会立即执行 handeClick('韩庆元') 函数，并将其返回值作为事件处理函数，而不是绑定函数本身。\n",
      "properties": {
        "title": "react 编码规范",
        "urlname": "bgd0siymr5kortqz",
        "date": "2023-07-25 19:49:51",
        "updated": "2023-07-25 20:08:59"
      },
      "catalog": [
        {
          "title": "环境搭建",
          "doc_id": "bgd0siymr5kortqz"
        }
      ],
      "body": "",
      "realName": "bgd0siymr5kortqz",
      "relativePath": "\\bgd0siymr5kortqz.md"
    },
    {
      "id": 134194866,
      "doc_id": "tf47asaynxwhubk1",
      "title": "tf47asaynxwhubk1",
      "updated": 1690197544000,
      "body_original": "Node.js 的 `fs` 模块是用于处理文件系统操作的核心模块，它提供了一组功能丰富的方法，可以对文件和目录进行读取、写入、修改、删除等操作。\n\n以下是 `fs` 模块的一些常见用法和使用场景的详细案例：\n> 使用前，先 npm i fs 下载模块哦\n\n\n1. 读取文件\n\n```javascript\nconst fs = require('fs');\n\nfs.readFile('file.txt', 'utf8', (err, data) => {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  console.log(data);\n});\n```\n\n使用 `readFile` 方法读取文件的内容。参数 `'utf8'` 指定文件内容编码为 UTF-8，回调函数中的 `data` 参数包含了读取到的文件内容。\n\n2. 写入文件\n\n```javascript\nconst fs = require('fs');\n\nconst content = 'Hello, World!';\n\nfs.writeFile('file.txt', content, (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log('文件写入成功');\n  }\n});\n```\n\n使用 `writeFile` 方法写入文件内容。指定要写入的文件名和内容，回调函数中的 `err` 参数用于检查是否发生错误。\n\n3. 创建目录\n\n```javascript\nconst fs = require('fs');\n\nfs.mkdir('myFolder', (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log('目录创建成功');\n  }\n});\n```\n\n使用 `mkdir` 方法创建一个新目录。指定目录名，并在回调函数中检查是否发生错误。\n\n4. 读取目录内容\n\n```javascript\nconst fs = require('fs');\n\nfs.readdir('myFolder', (err, files) => {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  console.log(files);\n});\n```\n\n使用 `readdir` 方法读取目录中的文件列表。回调函数中的 `files` 参数包含了目录中的文件名数组。\n\n5. 重命名文件或目录\n\n```javascript\nconst fs = require('fs');\n\nfs.rename('oldFile.txt', 'newFile.txt', (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log('重命名成功');\n  }\n});\n```\n\n使用 `rename` 方法重命名文件或目录。指定原始名称和新名称，检查回调函数中的 `err` 是否发生错误。\n\n6. 删除文件\n\n```javascript\nconst fs = require('fs');\n\nfs.unlink('file.txt', (err) => {\n  if (err) {\n    console.error(err);\n  } else {\n    console.log('文件删除成功');\n  }\n});\n```\n\n使用 `unlink` 方法删除指定的文件。检查回调函数中的 `err` 是否发生错误。\n\n这只是 `fs` 模块的一小部分功能示例，还有更多方法可用于处理文件系统操作。`fs` 模块提供了强大的功能，可用于读取、写入和管理文件和目录。根据应用程序的需求，你可以根据需要组合和使用这些方法。\n",
      "properties": {
        "title": "node.js - fs模块原来还能这样用？",
        "urlname": "tf47asaynxwhubk1",
        "date": "2023-07-24 19:17:59",
        "updated": "2023-07-24 19:19:04"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "tf47asaynxwhubk1"
        }
      ],
      "body": "",
      "realName": "tf47asaynxwhubk1",
      "relativePath": "\\tf47asaynxwhubk1.md"
    },
    {
      "id": 134102466,
      "doc_id": "qpitxccddbg9owse",
      "title": "qpitxccddbg9owse",
      "updated": 1690159472000,
      "body_original": "",
      "properties": {
        "title": "react 组件设计模式",
        "urlname": "qpitxccddbg9owse",
        "date": "2023-07-24 08:44:21",
        "updated": "2023-07-24 08:44:32"
      },
      "catalog": [
        {
          "title": "react高阶使用",
          "doc_id": "qpitxccddbg9owse"
        }
      ],
      "body": "",
      "realName": "qpitxccddbg9owse",
      "relativePath": "\\qpitxccddbg9owse.md"
    },
    {
      "id": 133877648,
      "doc_id": "fv5wevxoynyzz5gf",
      "title": "fv5wevxoynyzz5gf",
      "updated": 1692156501000,
      "body_original": "### 1、介绍：\n\nTypeScript中的接口（Interface）用于定义对象的结构和类型。接口类似于制定一份合同或规范，描述了对象应该具有的属性、方法等特征，但并不提供具体的实现。\n\n### 2、接口初探：\n\n接口定义了对象应该具备的属性和方法。例如，我们可以定义一个`Person`接口来描述一个人的基本信息：\n\n```typescript\ninterface Person {\n  name: string;\n  age: number;\n}\n```\n\n示例代码：\n\n```typescript\nlet person: Person = {\n  name: \"Alice\",\n  age: 25\n};\n```\n\n### 3、可选属性：\n\n接口的属性可以是可选的，即在对象中可以存在也可以不存在。使用`?`来标记可选属性。例如，我们可以将年龄属性改为可选：\n\n```typescript\ninterface Person {\n  name: string;\n  age?: number;\n}\n```\n\n示例代码：\n\n```typescript\nlet person1: Person = {\n  name: \"Alice\"\n};\n\nlet person2: Person = {\n  name: \"Bob\",\n  age: 30\n};\n```\n\n### 4、只读属性：\n\n接口的属性可以设置为只读，即在对象创建后不可修改。使用`readonly`关键字来标记只读属性。例如，我们可以将姓名属性设置为只读：\n\n```typescript\ninterface Person {\n  readonly name: string;\n  age?: number;\n}\n```\n\n示例代码：\n\n```typescript\nlet person: Person = {\n  name: \"Alice\",\n  age: 25\n};\n\nperson.name = \"Bob\"; // 错误，只读属性不可修改\n```\n\n### 5、额外的检查属性：\n\n当我们将一个对象赋值给接口类型的变量时，TypeScript会对该对象进行额外的检查，确保对象中没有未定义的属性。如果我们确实需要将额外的属性赋给对象，可以使用索引签名。例如：\n\n```typescript\ninterface Person {\n  name: string;\n  age?: number;\n  [propName: string]: any;\n}\n```\n\n示例代码：\n\n```typescript\nlet person: Person = {\n  name: \"Alice\",\n  age: 25,\n  gender: \"female\" // 额外的属性，使用索引签名允许赋值\n};\n```\n\n### 6、函数类型：\n\n接口不仅可以描述对象的结构，还可以描述函数的类型。例如，我们可以定义一个接口来描述一个求和函数：\n\n```typescript\ninterface Calculator {\n  (a: number, b: number): number;\n}\n```\n\n示例代码：\n\n```typescript\nlet add: Calculator = function(a, b) {\n  return a + b;\n};\n```\n\n### 7、可索引的类型：\n\n接口可以描述具有索引签名的对象，例如数组或字典。索引签名允许我们使用不同的索引类型来访问对象的属性。例如，我们可以定义一个字符串数组的接口：\n\n```typescript\ninterface StringArray {\n  [index: number]: string;\n}\n```\n\n示例代码：\n\n```typescript\nlet colors: StringArray = [\"red\", \"green\", \"blue\"];\nlet color: string = colors[0];\n```\n\n### 8、类类型：\n\n接口可以用来描述类的结构和实现，类可以实现（implement）接口并满足接口的要求。例如，我们可以定义一个接口描述一个时钟类：\n\n```typescript\ninterface Clock {\n  currentTime: Date;\n  setTime(date: Date): void;\n}\n\nclass DigitalClock implements Clock {\n  currentTime: Date;\n\n  constructor(date: Date) {\n    this.currentTime = date;\n  }\n\n  setTime(date: Date) {\n    this.currentTime = date;\n  }\n}\n\nclass AnalogClock implements Clock {\n  currentTime: Date;\n\n  constructor(date: Date) {\n    this.currentTime = date;\n  }\n\n  setTime(date: Date) {\n    this.currentTime = date;\n  }\n}\n```\n\n示例代码：\n\n```typescript\nlet digitalClock = new DigitalClock(new Date());\nlet analogClock = new AnalogClock(new Date());\n```\n\n### 9、继承接口：\n\n接口可以继承其他接口，从而组合多个接口的特性。继承可以帮助我们更好地组织和重用代码。例如：\n\n```typescript\ninterface Shape {\n  color: string;\n}\n\ninterface Square extends Shape {\n  sideLength: number;\n}\n```\n\n示例代码：\n\n```typescript\nlet square: Square = {\n  color: \"red\",\n  sideLength: 10\n};\n```\n\n### 10、混合类型：\n\n接口可以描述具有多种类型的对象，这些对象可以同时具备函数、属性等特征。这样的接口被称为混合类型接口。例如，我们可以定义一个具有倒计时功能和属性的接口：\n\n```typescript\ninterface Counter {\n  (): void;\n  count: number;\n}\n```\n\n示例代码：\n\n```typescript\nfunction createCounter(): Counter {\n  let count = 0;\n  const counter = () => {\n    count++;\n    console.log(\"Count: \", count);\n  };\n  counter.count = count;\n  return counter;\n}\n\nlet counter = createCounter();\ncounter(); // 输出：Count: 1\ncounter(); // 输出：Count: 2\nconsole.log(counter.count); // 输出：2\n```\n\n### 11、接口继承类：\n\n接口可以继承类的成员，但不继承其实现。这样可以使用接口来约束类的结构，使其他类可以通过实现该接口来满足特定的要求。例如：\n\n```typescript\nclass Control {\n  private state: any;\n}\n\ninterface SelectableControl extends Control {\n  select(): void;\n}\n```\n\n示例代码：\n\n```typescript\nclass Button extends Control implements SelectableControl {\n  select() {\n    console.log(\"Button selected.\");\n  }\n}\n```\n\n总之，接口在TypeScript中起到了约束和规范的作用，使代码更加可靠、可维护。通过使用接口，我们可以明确定义对象的结构、类的实现以及函数的类型，从而提高代码的可读性和可靠性。\n",
      "properties": {
        "title": "接口",
        "urlname": "fv5wevxoynyzz5gf",
        "date": "2023-07-21 10:22:57",
        "updated": "2023-08-16 11:28:21"
      },
      "catalog": [
        {
          "title": "typescript 入门指南",
          "doc_id": "fv5wevxoynyzz5gf"
        },
        {
          "title": "基础开发",
          "doc_id": "fv5wevxoynyzz5gf"
        }
      ],
      "body": "",
      "realName": "fv5wevxoynyzz5gf",
      "relativePath": "\\fv5wevxoynyzz5gf.md"
    },
    {
      "id": 133887806,
      "doc_id": "fbi9dqgqq17h84ag",
      "title": "fbi9dqgqq17h84ag",
      "updated": 1689909659000,
      "body_original": "## 一. 项目目录规范\n文件目录组织现在常用的有两种方式，后面公司采用的第二种，更方便一些。两种方式没有最好的，只有更适合自己公司的，只要公司内部达成一致了，用哪一种都会很方便。\n**1.1 按功能类型来划分**\n按文件的功能类型来分，**比如api**，**组件**，**页面**，**路由**，**hooks**，**store**，不管是全局使用到的，还是单独页面局部使用到的，都按照功能类型放在**src**下面对应的目录里面统一管理。\n```\n├─src               #  项目目录\n│  ├─api                #  数据请求\n│  │  └─Home            #  首页页面api\n│  │  └─Kind            #  分类页面api\n│  ├─assets             #  资源\n│  │  ├─css             #  css资源\n│  │  └─images          #  图片资源\n│  ├─config             #  配置\n│  ├─components         #  组件\n│  │  ├─common            #  公共组件\n│  │  └─Home              #  首页页面组件\n│  │  └─Kind              #  分类页面组件\n│  ├─layout             #  布局\n│  ├─hooks              #  自定义hooks组件\n│  ├─routes             #  路由\n│  ├─store              #  状态管理\n│  │  └─Home              #  首页页面公共的状态\n│  │  └─Kind              #  分类页面公共的状态\n│  ├─pages              #  页面\n│  │  └─Home              #  首页页面\n│  │  └─Kind              #  分类页面\n│  ├─utils              #  工具\n│  └─main.ts            #  入口文件\n```\n**1.2 按领域模型划分**\n按照页面功能划分，全局会用到的**组件**，**api**等还是放到**src**下面全局管理，页面内部单独使用的**api**和**组件**放到对应页面的文件夹里面，使用的时候不用上下查找文件，在当前页面文件夹下就能找到，比较方便，功能也内聚一些。\n```\n├─src               #  项目目录\n│  ├─assets             #  资源\n│  │  ├─css             #  css资源\n│  │  └─images          #  图片资源\n│  ├─config             #  配置\n│  ├─components         #  公共组件\n│  ├─layout             #  布局\n│  ├─hooks              #  自定义hooks组件\n│  ├─routes             #  路由\n│  ├─store              #  全局状态管理\n│  ├─pages              #  页面\n│  │  └─Home              #  首页页面\n│  │    └─components      #  Home页面组件文件夹\n│  │    ├─api             #  Home页面api文件夹\n│  │    ├─store           #  Home页面状态\n│  │    ├─index.tsx       #  Home页面\n│  │  └─Kind              #  分类页面\n│  ├─utils              #  工具\n│  └─main.ts            #  入口文件\n```\n## 二. 代码书写规范\n规范比较多，这里只简单列举一下基本的规范约束和使用工具来自动化规范代码。\n**2.1 组件结构**\n**react组件**\n```\nimport React, { memo, useMemo } from 'react'\n\ninterface ITitleProps {\n  title: string\n}\n\nconst Title: React.FC<ITitleProps> = props => {\n  const { title } = props\n\n  return (\n    <h2>{title}</h2>\n  )\n}\n\nexport default memo(Title)\n```\n**ITitleProps** 以**I**为开头代表**类型**，中间为语义化**Title**，后面**Props**为类型，代表是组件参数。\n**2.2 定义接口**\n例1: 登录接口，定义好参数类型和响应数据类型，参数类型直接定义**params**的类型，响应数据放在**范型**里面，需要在封装的时候就处理好这个范型。\n```\nimport { request } from '@/utils/request'\n\n/** 公共的接口响应范型 */\nexport interface HttpSuccessResponse<T> {\n  code: number\n  message: string\n  data: T\n}\n\n/** 登录接口参数 */\nexport interface ILoginParams {\n  username: string\n  password: string\n}\n\n/** 登录接口响应 */\nexport interface ILoginData {\n  token: string\n}\n\n/* 用户登录接口 */\nexport const loginApi = (params: ILoginApi) => {\n  return request.post<ILoginData>('/xxx', params)\n}\n```\n**2.3 事件**\n以**on**开头代表事件，这个只是规范，**on**要比**handle**短一点，哈哈。\n```\nconst onChange = () => {\n\n}\n```\n**2.4 工具约束代码规范**\n除了约定俗称的规范，我们也需要借助一些工具和插件来协助我们更好的完成规范这件事情。\n**代码规范**\n\n1. ?vscode：统一前端编辑器。\n2. ?editorconfig: 统一团队**vscode**编辑器默认配置。\n3. ?prettier: 保存文件自动格式化代码。\n4. ?eslint: 检测代码语法规范和错误。\n5. ?stylelint: 检测和格式化样式文件语法\n\n可以看我这篇文章：?【前端工程化】配置React+ts企业级代码规范及样式格式和git提交规范\n**git提交规范**\n\n1. ?husky:可以监听?githooks执行，在对应**hook**执行阶段做一些处理的操作。\n2. ?lint-staged: 只检测暂存区文件代码，优化**eslint**检测速度。\n3. ?pre-commit：**githooks**之一， 在**commit**提交前使用**tsc**和**eslint**对语法进行检测。\n4. ?commit-msg：**githooks**之一，在**commit**提交前对**commit**备注信息进行检测。\n5. ?commitlint：在**githooks**的**pre-commit**阶段对**commit**备注信息进行检测。\n6. ?commitizen：**git**的规范化提交工具，辅助填写**commit**信息。\n\n可以看我这篇文章：?【前端工程化】配置React+ts企业级代码规范及样式格式和git提交规范\n## 三. 状态管理器优化和统一\n### 3.1 优化状态管理\n用**react**的**context**封装了一个简单的状态管理器，有完整的类型提升，支持在组件内和外部使用，也发布到?npm了\n```javascript\nimport React, { createContext,  useContext, ComponentType, ComponentProps } from 'react'\n\n/** 创建context组合useState状态Store */\nfunction createStore<T>(store: () => T) {\n  // eslint-disable-next-line\n  const ModelContext: any = {};\n\n  /** 使用model */\n  function useModel<K extends keyof T>(key: K) {\n    return useContext(ModelContext[key]) as T[K];\n  }\n\n  /** 当前的状态 */\n  let currentStore: T;\n  /** 上一次的状态 */\n  let prevStore: T;\n\n  /** 创建状态注入组件 */\n  function StoreProvider(props: { children: React.ReactNode }) {\n    currentStore = store();\n    /** 如果有上次的context状态，做一下浅对比，\n     * 如果状态没变，就复用上一次context的value指针，避免context重新渲染\n     */\n    if (prevStore) {\n      for (const key in prevStore) {\n        // @ts-ignore\n        if (shallow(prevStore[key], currentStore[key])) {\n          // @ts-ignore\n          currentStore[key] = prevStore[key];\n        }\n      }\n    }\n    prevStore = currentStore;\n    // @ts-ignore\n    let keys: any[] = Object.keys(currentStore);\n    let i = 0;\n    const length = keys.length;\n    /** 遍历状态，递归形成多层级嵌套Context */\n    function getContext<T, K extends keyof T>(\n      key: K,\n      val: T,\n      children: React.ReactNode,\n    ): JSX.Element {\n      const Context =\n        ModelContext[key] || (ModelContext[key] = createContext(val[key]));\n      const currentIndex = ++i;\n      /** 返回嵌套的Context */\n      return React.createElement(\n        Context.Provider,\n        {\n          value: val[key],\n        },\n        currentIndex < length\n        ? getContext(keys[currentIndex], val, children)\n        : children,\n      );\n    }\n    return getContext(keys[i], currentStore, props.children);\n  }\n\n  /** 获取当前状态, 方便在组件外部使用,也不会引起页面更新 */\n  function getModel<K extends keyof T>(key: K): T[K] {\n    return currentStore[key];\n  }\n\n  /** 连接Model注入到组件中 */\n  function connectModel<Selected, K extends keyof T>(\n    key: K,\n    selector: (state: T[K]) => Selected,\n  ) {\n    // eslint-disable-next-line func-names\n    // @ts-ignore\n    return function <P, C extends ComponentType<any>>(\n      WarpComponent: C,\n    ): ComponentType<Omit<ComponentProps<C>, keyof Selected>> {\n      const Connect = (props: P) => {\n        const val = useModel(key);\n        const state = selector(val);\n        // @ts-ignore\n        return React.createElement(WarpComponent, {\n          ...props,\n          ...state,\n        });\n      };\n    return Connect as unknown as ComponentType<\n      Omit<ComponentProps<C>, keyof Selected>\n      >;\n  };\n}\n\nreturn {\n  useModel,\n  connectModel,\n  StoreProvider,\n  getModel,\n};\n}\n\nexport default createStore\n\n/** 浅对比对象 */\nfunction Shallow<T>(obj1: T, obj2: T) {\n  if(obj1 === obj2) return true\n  if(Object.keys(obj1).length !== Object.keys(obj2).length) return false\n  for(let key in obj1) {\n    if(obj1[key] !== obj2[key]) return false\n  }\n  return true\n}\n```\n### 3.2 store目录结构\n```javascript\n├─src               #  项目目录\n│  ├─store              #  全局状态管理\n│  │  └─modules           #  状态modules\n│  │    └─user.ts           #  用户信息状态\n│  │    ├─other.ts          #  其他全局状态\n│  │  ├─createStore.ts          #  封装的状态管理器\n│  │  └─index.ts          #  store入口页面\n```\n### 3.3 定义状态管理器\n**1. 在store/index.ts中引入**\n```typescript\nimport { useState } from 'react'\n\n/** 1. 引入createStore.ts */\nimport createStore from './createStore'\n\n/** 2. 定义各个状态 */\n// user\nconst userModel = () => {\n  const [ userInfo, setUserInfo ] = useState<{ name: string }>({ name: 'name' })\n  return { userInfo, setUserInfo }\n}\n\n// other\nconst otherModel = () => {\n  const [ other, setOther ] = useState<number>(20)\n  return { other, setOther }\n}\n\n/** 3. 组合所有状态 */\nconst store = createStore(() => ({\n  user: userModel(),\n  other: otherModel(),\n}))\n\n/** 向外暴露useModel, StoreProvider, getModel, connectModel */\nexport const { useModel, StoreProvider, getModel, connectModel } = store\n```\n**2. 在顶层通过StoreProvider注入状态**\n```typescript\n// src/main.ts\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from '@/App'\n// 1. 引入StoreProvider\nimport { StoreProvider } from '@/store'\n\n// 2. 使用StoreProvider包裹App组件\nReactDOM.render(\n  <StoreProvider>\n  <App />\n  </StoreProvider>,\n  document.getElementById('root')\n)\n```\n### 3.4 使用状态管理器\n**1. 在函数组件中使用，借助useModel**\n```\nimport React from 'react'\nimport { useModel } from '@/store'\n\nfunction FunctionDemo() {\n\n  /** 通过useModel取出user状态 */\n  const { userInfo, setUserInfo } = useModel('user')\n\n  /** 在点击事件中调用setUserInfo改变状态 */\n  const onChangeUser = () => {\n    setUserInfo({\n      name: userInfo.name + '1',\n    })\n  }\n\n  // 展示userInfo.name\n  return (\n    <button onClick={onChangeUser}>{userInfo.name}--改变user中的状态</button>\n  )\n}\n\nexport default FunctionDemo\n```\n**2. 在class组件中使用,借助connectModel**\n```\nimport React, { Component } from 'react'\nimport { connectModel } from '@/store'\n\n// 定义class组件props\ninterface IClassDemoProps {\n  setOther: React.Dispatch<React.SetStateAction<string>>\n  other: number\n}\n\nclass ClassDemo extends Component<IClassDemoProps> {\n  // 通过this.props获取到方法修改状态\n  onChange = () => {\n    this.props.setOther(this.props.other + 1)\n  }\n  render() {\n    // 通过this.props获取到状态进行展示\n    return <button onClick={this.onChange}>{this.props.other}</button>\n  }\n}\n\n// 通过高阶组件connectModel把other状态中的属性和方法注入到类组件中\nexport default connectModel('other',state => ({\n  other: state.other,\n  setOther: state.setOther\n}))(ClassDemo)\n```\n**3. 在组件外使用, 借助getModel**\n也可以在组件内读取修改状态方法，不回引起更新\n```\nimport { getModel } from '@/store'\n\nexport const onChangeUser = () => {\n  // 通过getModel读取usel状态，进行操作\n  const user = getModel('user')\n  user.setUserInfo({\n    name: user.userInfo.name + '1'\n  })\n}\n\n// 1秒后执行onChangeUser方法\nsetTimeout(onChangeUser, 1000)\n```\n## 四. 本地存储统一管理\n可以对**localStorage**和**sessionStorage**还有**cookie**简单封装一下，封装后使用的好处：\n\n1. 自动序列化，存储的时候转字符串，取得时候再转回来。\n2. 类型自动推断，在实例化的时候传入类型，在设置和获取值的时候都会自动类型推断。\n3. 可以统一管理，把本地存储都放在一个文件里面，避免后期本地存储混乱不好维护问题。\n4. 抹平平台差异，这个思路**web**，小程序，移动端，桌面端都适合。\n```\n// src/utils/storage.ts\nconst prefix = 'xxx.'\n\ninterface IStorage<T> {\n  key: string\n  defaultValue: T\n}\nexport class LocalStorage<T> implements IStorage<T> {\n  key: string\n  defaultValue: T\n  constructor(key, defaultValue) {\n    this.key = prefix + key\n    this.defaultValue = defaultValue\n  }\n  /** 设置值 */\n  setItem(value: T) {\n    localStorage.setItem(this.key, JSON.stringify(value))\n  }\n  /** 获取值 */\n  getItem(): T {\n    const value = localStorage[this.key] && localStorage.getItem(this.key)\n    if (value === undefined) return this.defaultValue\n    try {\n      return value && value !== 'null' && value !== 'undefined'\n        ? (JSON.parse(value) as T)\n        : this.defaultValue\n    } catch (error) {\n      return value && value !== 'null' && value !== 'undefined'\n        ? (value as unknown as T)\n        : this.defaultValue\n    }\n  }\n  /** 删除值 */\n  removeItem() {\n    localStorage.removeItem(this.key)\n  }\n}\n```\n**实例化封装的本地存储**\n```\n// src/common/storage.ts\nimport { LocalStorage } from '@/utils/storage'\n\n/** 管理token */\nexport const tokenStorage = new LocalStorage<string>('token', '')\n\n/** 用户信息类型 */\nexport interface IUser {\n    name?: string\n    age?: num\n}\n\n/** 管理用户信息 */\nexport const userStorage = new Storage<IUser>('user', {})\n```\n**页面内使用**\n```\nimport React, { memo, useMemo } from 'react'\nimport { userStorage } from '@/common/storage'\n\ninterface ITitleProps {\n  title: string\n}\n\nconst Title: React.FC<ITitleProps> = props => {\n  const { title } = props\n    \n  useEffect(() => {\n    userStorage.setItem({ name: '姓名', age: 18 })\n    const user = userStorage.getItem()\n    console.log(user) // { name: '姓名', age: 18 }\n  }, [])\n\n  return (\n    <h2>{title}</h2>\n  )\n}\n\nexport default memo(Title)\n```\n## 五. 封装请求统一和项目解耦\n**5.1 现有的封装**\n项目现用的请求封装和项目业务逻辑耦合在一块，不方便直接复用，使用上比较麻烦，每次需要传**GET**和**POST**类型，**GET**参数要每次单独做处理，参数类型限制弱。\n**5.2 推荐使用**\n推荐直接使用**fetch**封装或**axios**，项目中基于次做二次封装，只关注和项目有关的逻辑，不关注请求的实现逻辑。在请求异常的时候不返回**Promise.reject()，而是返回一个对象，只是code**改为异常状态的**code**，这样在页面中使用时，不用用**try/catch**包裹，只用**if**判断**code**是否正确就可以。\n```\nimport axios, { AxiosInstance, AxiosRequestConfig } from 'axios'\nimport { tokenStorage } from '@/common/storage'\n/** 封装axios的实例，方便多个url时的封装 */\nexport const createAxiosIntance = (baseURL: string): AxiosInstance => {\n  const request = axios.create({ baseURL })\n  // 请求拦截器器\n  request.interceptors.request.use((config: AxiosRequestConfig) => {\n    config.headers['Authorization'] = tokenStorage.getItem()\n    return config\n  })\n  // 响应拦截器\n  request.interceptors.response.use(\n    response => {\n      const code = response.data.code\n      switch (code) {\n        case 0:\n          return response.data\n        case 401:\n          // 登录失效逻辑\n          return response.data || {}\n        default:\n          return response.data || {}\n      }\n    },\n    error => {\n      // 接口请求报错时，也返回对象，这样使用async/await就不需要加try/catch\n      // code为0为请求正常，不为0为请求异常,使用message提示\n      return { message: onErrorReason(error.message) }\n    }\n  )\n  return request\n}\n\n/** 解析http层面请求异常原因 */\nfunction onErrorReason(message: string): string {\n  if (message.includes('Network Error')) {\n    return '网络异常，请检查网络情况!'\n  }\n  if (message.includes('timeout')) {\n    return '请求超时，请重试!'\n  }\n  return '服务异常,请重试!'\n}\n\nexport const request = createAxiosIntance('https://xxx')\n```\n**5.3 使用**\n使用上面代码命名定义接口类型的**loginApi**例子\n```\n/** 登录 */\nconst onLogin = async () => {\n  const res = await loginApi(params)\n  if(res.code === 0) {\n    // 处理登录正常逻辑\n  } else {\n    message.error(res.message) // 错误提示也可以在封装时统一添加\n  }\n}\n```\n## 六.  api接口管理统一\n**文件夹路径**\n```\n├─pages                 #  页面\n│  ├─Login              #  登录页面\n│  │  └─api             #  api文件夹\n│  │    └─index.ts      #  api函数封装\n│  │    ├─types.ts      #  api的参数和响应类型\n```\n**定义类型**\n```\n// api/types.ts\n\n/** 登录接口参数 */\nexport interface ILoginParams {\n  username: string\n  password: string\n}\n\n/** 登录接口响应 */\nexport interface ILoginData {\n  token: string\n}\n```\n**定义请求接口**\n```\nimport { request } from '@/utils/request'\nimport { ILoginParams, ILoginData } from './types'\n\n/* 用户登录接口 */\nexport const loginApi = (params: ILoginParams) => {\n  return request.post<ILoginData>('/distribute/school/login', params)\n}\n```\n**使用请求接口**\n使用上面代码命名定义接口类型的**loginApi**例子\n```\n/** 登录 */\nconst onLogin = async () => {\n  const res = await loginApi(params)\n  if(res.code === 0) {\n    // 处理登录正常逻辑\n  } else {\n    message.error(res.message) // 错误提示也可以在封装时统一添加\n  }\n}\n```\n## 七. 函数库-通用方法抽离复用\n把公司项目中常用的**方法**和**hooks**抽离出来组成**函数库**，方便在各个项目中使用，通过编写函数方法，写jest单元测试，也可以提升组内成员的整体水平。当时组内前端不管是实习生还是正式成员都在参与函数库的建设，很多就有了 **30+** 的函数和hooks，还在不断的增加。\n是用了**dumi2**来开发的函数库，可以看我的这篇文章?【前端工程化】使用dumi2搭建React组件库和函数库详细教程\n## 八. 组件库-通用组件抽离复用\n公司项目多了会有很多公共的组件，可以抽离出来，方便其他项目复用，一般可以分为以下几种组件：\n\n1. UI组件\n2. 业务组件\n3. 功能组件：上拉刷新，滚动到底部加载更多，虚拟滚动，拖拽排序，图片懒加载..\n\n由于公司技术栈主要是**react**，组件库也是采用了**dumi2**的方案，可以看我的这篇文章?【前端工程化】使用dumi2搭建React组件库和函数库详细教程\n## 九. css超集和css模块化方案统一\n**css超集**\n使用**less**或者**scss**，看项目具体情况，能全项目统一就统一。\n**css模块化**\n**vue**使用自带的**style scoped**, **react**使用**css-module**方案。\n开启也简单，以**vite**为例，默认支持，可以修改**vite.config.ts**配置：\n```\n// vite.config.ts\nexport default defineConfig({\n  css: {\n    // 配置 css-module\n    modules: {\n      // 开启 camelCase 格式变量名转换\n      localsConvention: 'camelCase',\n      // 类名格式，[local]是自己原本的类名，[hash:base64:5]是5位的hash值\n      generateScopedName: '[local]-[hash:base64:5]',\n    }\n  },\n})\n```\n使用的时候，样式文件命名后缀需要加上 **.module**，例如index.module.less：\n```\n// index.module.less\n.title {\n\tfont-size: 18px;\n  color: yellow;\n}\n```\n组件里面使用:\n```\nimport React, { memo, useMemo } from 'react'\nimport styles from './index.module.less'\n\ninterface ITitleProps {\n  title: string\n}\n\nconst Title: React.FC<ITitleProps> = props => {\n  const { title } = props\n\n  return (\n    <h2 className={styles.title}>{title}</h2>\n  )\n}\n\nexport default memo(Title)\n```\n编译后类名会变成**title-[hash:5]**，可以有效避免样式冲突，减少起类名的痛苦。\n## 十. 引入immer来优化性能和简化写法\n?Immer 是 **mobx** 的作者写的一个 **immutable** 库，核心实现是利用 **ES6** 的 **Proxy**(不支持**Proxy**的环境会自动使用**Object.defineProperty**来实现)，几乎以最小的成本实现了 **js** 的不可变数据结构，简单易用、体量小巧、设计巧妙，满足了我们对**js**不可变数据结构的需求。\n**1. 优化性能**\n修改用户信息\n```\nconst [ userInfo, setUserInfo ] = useState({ name: 'immer', info: { age: 6 } })\nconst onChange = (age: number) => {\n  setUserInfo({...userInfo, info: {\n    ...userinfo.info,\n    age: age\n  }})\n}\n```\n上面某次修改**age**没有变，但**setUserInfo**时每次都生成了一个新对象，更新前后引用变化了，组件就会刷新。\n使用**immer**后,**age**没变时不会生成新的引用，同时语法也更简洁，可以优化性能。\n```\nimport produce from 'immer'\n\nconst [ userInfo, setUserInfo ] = useState({ name: 'immer', age: 5 })\nconst onChange = (age: number) => {\n  setUserInfo(darft => {\n    darft.age = age\n  })\n}\n```\n**2.简化写法**\n**react**遵循不可变数据流的理念，每次修改状态都要新生成一个引用，不能在原先的引用上进行修改，所以在对引用类型对象或者数组做操作时，总要浅拷贝一下，再来做处理，当修改的状态层级比较深的时候，写法会更复杂。\n以数组为例，修改购物车某个商品的数量：\n```\nimport produce from 'immer'\n\nconst [ list, setList ] = useState([{ price: 100, num: 1 }, { price: 200, num: 1 }])\n\n// 不使用用immer\nconst onAdd = (index: number) => {\n  /** 不使用immer */\n  // const item = { ...list[index] }\n  // item.num++\n  // list[index] = item\n  // setList([...list])\n\n  /** 使用immer */\n  setList(\n    produce(darft => {\n      darft[index].num++\n    }),\n  )\n}\n```\n**3. 可以用?use-immer简化写法**:\n```\nimport useImmer from 'use-immer'\n\nconst [ list, setList ] = useImmer([{ price: 100, num: 1 }, { price: 200, num: 1 }])\n\nconst onAdd = (index: number) => {\n  setList(darft => {\n      darft[index].num++\n  })\n}\n```\n## 十一. 搭建npm私服\n公司前端项目不推荐使用太多第三方包，可以自己搭建公司**npm**私服，来托管公司自己封装的状态管理库，请求库，组件库，以及脚手架**cli**，**sdk**等**npm**包，方便复用和管理。\n可以看我这两篇文章，都可以搭建**npm**私服：\n?【前端工程化】巧用阿里云oss服务打造前端npm私有仓库\n?【前端工程化】使用verdaccio搭建公司npm私有库完整流程和踩坑记录\n## 十二. 各类型项目通用模版封装\n可以提前根据公司的业务需求，封装出各个端对应通用开发模版，封装好项目目录结构，接口请求，状态管理，代码规范，git规范钩子，页面适配，权限，本地存储管理等等，来减少开发新项目时前期准备工作时间，也能更好的统一公司整体的代码规范。\n\n1. 通用后台管理系统基础模版封装\n2. 通用小程序基础模版封装\n3. 通用**h5**端基础模版封装\n4. 通用**node**端基础模版封装\n5. 其他类型的项目默认模版封装，减少重复工作。\n## 十三. 搭建cli脚手架下载模版。\n搭建类似**vue-cli**, **vite**, **create-react-app**类的**cli命令行**脚手架来快速选择和下载封装好的模版，比**git**拉代码要方便。\n具体**cli**脚手架的实现可以看我这篇文章：?【前端工程化】从入门到精通，100行代码构建你的前端CLI脚手架之路\n## 十四. git操作规范\n**git**操作规范也很重要，流程不规范很容易出现比较复杂的问题，要根据公司现有情况和业界比较好的实践方案制定一套适合自己公司的**git flow**开发规范，用各种限制方案来避免出现问题，这个具体流规范后面会总结一篇文章出来。\n## 十五. 规范和使用文档输出文档站点\n代码规范和git提交规范以及各个封装的库使用说明要输出成文档部署到线上，方便新同事快速熟悉和使用。\n这个是很重要的，做了再多的基建和规范，如果没有一个公共的文文档来查阅，就没办法快速熟悉，所以要一个线上的规范文档，把所有的规范都写进去，可以用语雀\n",
      "properties": {
        "title": "前端基建规范参考",
        "urlname": "fbi9dqgqq17h84ag",
        "date": "2023-07-21 11:18:35",
        "updated": "2023-07-21 11:20:59"
      },
      "catalog": [
        {
          "title": "环境搭建",
          "doc_id": "fbi9dqgqq17h84ag"
        }
      ],
      "body": "",
      "realName": "fbi9dqgqq17h84ag",
      "relativePath": "\\fbi9dqgqq17h84ag.md"
    },
    {
      "id": 133877134,
      "doc_id": "rua0g9bcb7vgi0oq",
      "title": "rua0g9bcb7vgi0oq",
      "updated": 1689906068000,
      "body_original": "如果你在 TypeScript 函数中使用了可选参数，但是 ESLint 报错了，你可以通过以下方法进行解决：\n\n1. 在函数定义的地方添加一个注释 `// eslint-disable-next-line @typescript-eslint/no-unused-vars` 来忽略该行的错误提示。这会告诉 ESLint 忽略当前行的未使用变量的警告。\n\n```typescript\nfunction myFunction(param1: string, param2?: number) {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  // 使用了可选参数 `param2`，但是未在代码中使用\n  console.log(param1);\n}\n```\n\n2. 在 ESLint 配置文件中禁用 `@typescript-eslint/no-unused-vars` 规则。在你的项目根目录下的 `.eslintrc.js` 或 `.eslintrc.json` 文件中，找到相关的规则配置并将其禁用。\n\n```json\n{\n  \"rules\": {\n    \"@typescript-eslint/no-unused-vars\": \"off\"\n  }\n}\n```\n\n3. 如果你需要在代码中使用可选参数，但是 ESLint 的规则认为它是未使用的，你可以确保在代码中使用该参数，以避免报错。\n\n```typescript\nfunction myFunction(param1: string, param2?: number) {\n  if (param2) {\n    console.log(param2); // 使用了可选参数 `param2`\n  }\n  console.log(param1);\n}\n```\n\n通过采取上述方法，你可以解决 ESLint 报错的问题，并根据你的实际需求来处理 TypeScript 函数中的可选参数。\n",
      "properties": {
        "title": "ts函数可选参数-未使用—ESlint 校验",
        "urlname": "rua0g9bcb7vgi0oq",
        "date": "2023-07-21 10:20:15",
        "updated": "2023-07-21 10:21:08"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "rua0g9bcb7vgi0oq"
        }
      ],
      "body": "",
      "realName": "rua0g9bcb7vgi0oq",
      "relativePath": "\\rua0g9bcb7vgi0oq.md"
    },
    {
      "id": 133257703,
      "doc_id": "nfknzexbccraar99",
      "title": "nfknzexbccraar99",
      "updated": 1690472917000,
      "body_original": "\nJavaScript被称为动态类型语言，是因为它的类型在运行时决定，并且可以在运行时动态改变变量的类型。以下是一些示例来说明JavaScript的动态类型特性：\n\n1. 变量类型的弱化：\n\n```javascript\nlet x = 10; // x被推断为number类型\nx = \"Hello\"; // 现在x的类型变为string\nx = true; // 这里x的类型变为boolean\n```\n\n在JavaScript中，变量的类型可以根据赋值的值自动推断，并且可以在运行时改变变量的类型。\n\n2. 动态属性：\n\n```javascript\nlet person = {\n  name: \"John\",\n  age: 30,\n};\n\nconsole.log(person.name); // 输出 \"John\"\n\nperson.name = \"Jane\";\nconsole.log(person.name); // 输出 \"Jane\"\n\nperson.address = \"New York\";\nconsole.log(person.address); // 输出 \"New York\"\n```\n\n在JavaScript中，对象的属性可以在运行时动态地添加或修改。\n\n3. 动态函数参数：\n\n```javascript\nfunction add(a, b) {\n  return a + b;\n}\n\nconsole.log(add(2, 3)); // 输出 5\nconsole.log(add(\"Hello\", \"World\")); // 输出 \"HelloWorld\"\nconsole.log(add(2, \"Hello\")); // 输出 \"2Hello\"\n```\n\n在JavaScript中，函数的参数类型并没有在定义时指定，可以接受不同类型的参数并执行不同的操作。\n\n这些示例展示了JavaScript的动态类型特性，变量可以根据赋值动态改变类型，对象的属性可以在运行时动态添加或修改，函数的参数可以接受不同类型的值。这种动态性赋予了JavaScript更大的灵活性，在某些情况下也增加了一些开发的挑战。\n\n# ts VS js （动态vs静态）\n\n`动态类型语言`直接运行时对变量检测，无需声明变量类型\n`静态类型语言`需声明变量类型，在编译时对变量类型检测\n\nJavaScript被称为动态类型语言，因为它在运行时对变量的类型进行推断和处理。这意味着你可以在运行时改变变量的类型，而不需要提前进行类型声明。以下是一些JavaScript的动态类型示例：\n\n```javascript\nlet variable = 10; // 变量可以被赋予一个数字类型的值\nconsole.log(variable); // 输出: 10\n\nvariable = \"Hello\"; // 变量可以被赋予一个字符串类型的值\nconsole.log(variable); // 输出: Hello\n\nvariable = true; // 变量可以被赋予一个布尔类型的值\nconsole.log(variable); // 输出: true\n```\n\n相比之下，TypeScript是静态类型语言，它在编译时就会对变量的类型进行检查，并在代码中明确声明变量的类型。这使得在开发阶段可以发现潜在的类型错误。以下是一些TypeScript的静态类型示例：\n\n```typescript\nlet variable: number = 10; // 变量被声明为数字类型\nconsole.log(variable); // 输出: 10\n\nvariable = \"Hello\"; // 错误：不能将字符串类型赋给数字类型的变量\n\nlet greeting: string = \"Hello\";\nconsole.log(greeting); // 输出: Hello\n\ngreeting = true; // 错误：不能将布尔类型赋给字符串类型的变量\n```\n\n在这些示例中，你可以看到TypeScript代码中的变量需要在声明时指定类型，并且在编译过程中会对类型错误进行检查。如果违反了类型规定，TypeScript编译器会发出错误提示。\n\n这种类型检查能够在开发阶段捕获潜在的错误，帮助提高代码的健壮性和可靠性，减少运行时错误。\n\n# typeScript  强是型语言还是弱类型语言？\n\n类型系统按照「是否允许隐式类型转换」来分类，可以分为强类型和弱类型。\n\nTypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性，所以**它们都是弱类型**。\n\n如下在typescript中运行：\n```\nconsole.log(1 + '1');\n// 打印出字符串 '11'\n```\n\npython 是强类型语言，如下分别执行 1+1 、1+\"1\"，1+1 相同类型计算正常运行，当运行 number 类型 1 + string 1 时，报错。\n\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1689488014842-0ecc2649-4b3c-4e72-9ed6-fa110f3bd651.png#averageHue=%231b1616&clientId=u042009fa-e032-4&from=paste&height=250&id=sZJM4&originHeight=400&originWidth=1635&originalType=binary&ratio=1.600000023841858&rotation=0&showTitle=false&size=43775&status=done&style=none&taskId=uebc29dbe-2135-48ac-8bd4-1884965ef15&title=&width=1021.8749847728761) \n强制类型转换后 可正常输入\n![image.png](https://cdn.nlark.com/yuque/0/2023/png/1450835/1689488431037-7671739d-0f50-4b49-85ed-bfb1b0535c61.png#averageHue=%230f0f0f&clientId=u042009fa-e032-4&from=paste&height=99&id=u67bb2fd4&originHeight=121&originWidth=1073&originalType=binary&ratio=1.600000023841858&rotation=0&showTitle=false&size=4387&status=done&style=none&taskId=u3491a1b3-2b0e-421c-a45f-ff2323faf80&title=&width=879.005859375)\ntypescript 可以借助自身类型系统， 配合 eslint 的代码检查能力，跟进一步向强类型语言靠近。\n\n\n",
      "properties": {
        "title": "为什么说js是动态类型语言呢？",
        "urlname": "nfknzexbccraar99",
        "date": "2023-07-14 23:38:32",
        "updated": "2023-07-27 23:48:37"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "nfknzexbccraar99"
        }
      ],
      "body": "",
      "realName": "nfknzexbccraar99",
      "relativePath": "\\nfknzexbccraar99.md"
    },
    {
      "id": 133258810,
      "doc_id": "bf2pmua2hv1623o9",
      "title": "bf2pmua2hv1623o9",
      "updated": 1689486191000,
      "body_original": "当我们说TypeScript是JavaScript的超集时，意味着TypeScript拥有比JavaScript更多的功能和特性。这些特性包括：\n\n1.  静态类型检查：TypeScript引入了静态类型系统，允许在代码编写阶段发现潜在的类型错误。你可以为变量、函数参数、返回值等添加类型注解，编译器会检查代码是否符合类型规定，并给出错误提示。这有助于减少在运行时出现的意外错误，提高代码质量和可维护性。 \n2.  类和模块：TypeScript支持ECMAScript 6及以上版本的 JavaScript，包括类和模块。通过类，你可以使用面向对象的编程方法来组织和封装代码。模块机制则用于将代码分割成可重用的部分，使得代码更加清晰、易读和可维护。 \n3.  高级类型系统：TypeScript提供了一系列高级类型系统特性，如联合类型、交叉类型、类型推断、泛型等。这些特性使得你可以更精确地定义和操作数据类型，提供更多代码表达能力和灵活性。 \n4.  工具支持：TypeScript拥有强大的开发工具支持。编译器会提供智能感知、代码补全、代码重构等功能，帮助你编写更高效、更准确的代码。此外，许多流行的文本编辑器和集成开发环境（IDE）都具备对TypeScript的良好支持，提供了更好的开发体验。 \n\n虽然TypeScript扩展了JavaScript的功能，但它仍然完全兼容JavaScript。这意味着你可以把现有的JavaScript代码直接重命名为`.ts`文件，然后逐步添加类型注解和其他TypeScript特性，驱动你的代码向TypeScript迁移。这使得使用TypeScript的过程非常渐进，你无需放弃已有的JavaScript知识和代码，而是可以在逐步学习和应用TypeScript的过程中，享受到更好的开发体验和优势。\n\n**typeScript可以运行所有的js代码**\n\nTypeScript 可以运行所有的 JavaScript 代码。由于 TypeScript 是 JavaScript 的超集，任何有效的 JavaScript 代码都可以被视为有效的 TypeScript 代码。\n当你创建一个以 .ts 后缀的 TypeScript 文件时，你可以直接将其中的 JavaScript 代码复制过来，然后进行一些逐步的迁移工作。TypeScript 编译器会将 TypeScript 代码转换为与原始 JavaScript 等效的代码，并能够在任何支持 JavaScript 的环境中运行。\n换句话说，**TypeScript 代码在编译过程中被转换为 JavaScript**，而最终执行的是生成的 JavaScript 代码。这意味着你可以使用所有标准的 JavaScript 功能和语法，并无需额外考虑 TypeScript 的特性。\n不过，当你使用 TypeScript 的时候，你也可以逐步采用 TypeScript 提供的类型检查和其他特性，以增强代码的质量、可读性和可维护性。这是 TypeScript 的一个优势，它允许你在不改变运行结果的前提下，逐步将 JavaScript 代码迁移到 TypeScript，并获得额外的开发工具支持和类型安全检查等好处。\n",
      "properties": {
        "title": "typeScript是js的超集",
        "urlname": "bf2pmua2hv1623o9",
        "date": "2023-07-14 23:54:10",
        "updated": "2023-07-16 13:43:11"
      },
      "catalog": [
        {
          "title": "常见问题",
          "doc_id": "bf2pmua2hv1623o9"
        }
      ],
      "body": "",
      "realName": "bf2pmua2hv1623o9",
      "relativePath": "\\bf2pmua2hv1623o9.md"
    }
  ],
  "catalog": [
    {
      "type": "DOC",
      "title": "💡问题登记",
      "uuid": "bIsGunAQ1SI2Lddd",
      "url": "el2150t8n7tdkgcp",
      "prev_uuid": "",
      "sibling_uuid": "qBfg9R-nibjoGxQa",
      "child_uuid": "",
      "parent_uuid": "",
      "doc_id": 138951223,
      "level": 0,
      "id": 138951223,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "react导读",
      "uuid": "qBfg9R-nibjoGxQa",
      "url": "vigtgkots2lu6bb1",
      "prev_uuid": "bIsGunAQ1SI2Lddd",
      "sibling_uuid": "ibVJZhss55ktxDxw",
      "child_uuid": "",
      "parent_uuid": "",
      "doc_id": 137979552,
      "level": 0,
      "id": 137979552,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "项目拆分",
      "uuid": "ibVJZhss55ktxDxw",
      "url": "gbwx6y5p60i7wv4g",
      "prev_uuid": "qBfg9R-nibjoGxQa",
      "sibling_uuid": "M9wkhlzWFQy-jgDn",
      "child_uuid": "",
      "parent_uuid": "",
      "doc_id": 137465899,
      "level": 0,
      "id": 137465899,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "专高4功能模块+复杂度提薪点",
      "uuid": "M9wkhlzWFQy-jgDn",
      "url": "kxlfse72fgcggs7a",
      "prev_uuid": "ibVJZhss55ktxDxw",
      "sibling_uuid": "-hh6uXDk8KrxUCRI",
      "child_uuid": "",
      "parent_uuid": "",
      "doc_id": 135768675,
      "level": 0,
      "id": 135768675,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "TITLE",
      "title": "环境搭建",
      "uuid": "-hh6uXDk8KrxUCRI",
      "url": "",
      "prev_uuid": "M9wkhlzWFQy-jgDn",
      "sibling_uuid": "j-ATW-gMjxhNTLIj",
      "child_uuid": "wsLkb_ZIZFo9si79",
      "parent_uuid": "",
      "doc_id": "",
      "level": 0,
      "id": "",
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "git常用的六个命令",
      "uuid": "wsLkb_ZIZFo9si79",
      "url": "dczr2vfhgu4n2cft",
      "prev_uuid": "-hh6uXDk8KrxUCRI",
      "sibling_uuid": "NDUAAAvzJ9HAmr37",
      "child_uuid": "",
      "parent_uuid": "-hh6uXDk8KrxUCRI",
      "doc_id": 142261036,
      "level": 1,
      "id": 142261036,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "vscode 插件合集",
      "uuid": "NDUAAAvzJ9HAmr37",
      "url": "clggvok4l4xn2ftt",
      "prev_uuid": "wsLkb_ZIZFo9si79",
      "sibling_uuid": "8hfYeEig7IDIlNVx",
      "child_uuid": "",
      "parent_uuid": "-hh6uXDk8KrxUCRI",
      "doc_id": 137091307,
      "level": 1,
      "id": 137091307,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "前端规范指南，让团队代码如出一辙！ESLint + Prettier + husky + lint-staged",
      "uuid": "8hfYeEig7IDIlNVx",
      "url": "pe1n3uneypxse0fq",
      "prev_uuid": "NDUAAAvzJ9HAmr37",
      "sibling_uuid": "-rULpKix9wIfOFgA",
      "child_uuid": "",
      "parent_uuid": "-hh6uXDk8KrxUCRI",
      "doc_id": 133441468,
      "level": 1,
      "id": 133441468,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "react 编码规范",
      "uuid": "-rULpKix9wIfOFgA",
      "url": "bgd0siymr5kortqz",
      "prev_uuid": "8hfYeEig7IDIlNVx",
      "sibling_uuid": "PNzroZghRuP0hRGT",
      "child_uuid": "",
      "parent_uuid": "-hh6uXDk8KrxUCRI",
      "doc_id": 134337678,
      "level": 1,
      "id": 134337678,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "前端基建规范参考",
      "uuid": "PNzroZghRuP0hRGT",
      "url": "fbi9dqgqq17h84ag",
      "prev_uuid": "-rULpKix9wIfOFgA",
      "sibling_uuid": "",
      "child_uuid": "",
      "parent_uuid": "-hh6uXDk8KrxUCRI",
      "doc_id": 133887806,
      "level": 1,
      "id": 133887806,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "TITLE",
      "title": "常见问题",
      "uuid": "j-ATW-gMjxhNTLIj",
      "url": "",
      "prev_uuid": "-hh6uXDk8KrxUCRI",
      "sibling_uuid": "oht-Yfyv2VVLuo6R",
      "child_uuid": "R4XQbJryI36i4D52",
      "parent_uuid": "",
      "doc_id": "",
      "level": 0,
      "id": "",
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "解决eslint和prettier冲突",
      "uuid": "R4XQbJryI36i4D52",
      "url": "bp437kq13uf9ch6d",
      "prev_uuid": "j-ATW-gMjxhNTLIj",
      "sibling_uuid": "56asYz7aobEs5nlf",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 141767061,
      "level": 1,
      "id": 141767061,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "vscode新建代码片段",
      "uuid": "56asYz7aobEs5nlf",
      "url": "hxorr1qcrd6l69h5",
      "prev_uuid": "R4XQbJryI36i4D52",
      "sibling_uuid": "itQO8lb0mZ6-7WEl",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 140367126,
      "level": 1,
      "id": 140367126,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "npx run eject 异常",
      "uuid": "itQO8lb0mZ6-7WEl",
      "url": "pfyhe9lm7o95vz3r",
      "prev_uuid": "56asYz7aobEs5nlf",
      "sibling_uuid": "dv-dYGUpcT4ZF_-m",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 138956175,
      "level": 1,
      "id": 138956175,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "🚫系统禁止cnpm运行",
      "uuid": "dv-dYGUpcT4ZF_-m",
      "url": "xgy8xa51aumswod7",
      "prev_uuid": "itQO8lb0mZ6-7WEl",
      "sibling_uuid": "aERioLXIgq78QkT6",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 138953526,
      "level": 1,
      "id": 138953526,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "git 常见报错",
      "uuid": "aERioLXIgq78QkT6",
      "url": "wr68nublwv2vdtch",
      "prev_uuid": "dv-dYGUpcT4ZF_-m",
      "sibling_uuid": "TP7vQA-HwpmlNo-3",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 138945863,
      "level": 1,
      "id": 138945863,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "TortoiseGit 账号密码更改失效",
      "uuid": "TP7vQA-HwpmlNo-3",
      "url": "qazym151efb8eucb",
      "prev_uuid": "aERioLXIgq78QkT6",
      "sibling_uuid": "3JigUCnuSloFva6M",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 138348491,
      "level": 1,
      "id": 138348491,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "react状态改变，为何触发函数组件重新渲染？",
      "uuid": "3JigUCnuSloFva6M",
      "url": "tvze4ptzu906v7mh",
      "prev_uuid": "TP7vQA-HwpmlNo-3",
      "sibling_uuid": "Lyyg2Zt3qbNBCdxv",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 137979191,
      "level": 1,
      "id": 137979191,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "为什么少用 ref 和 useRef 呢？",
      "uuid": "Lyyg2Zt3qbNBCdxv",
      "url": "yuv23ww09883c08k",
      "prev_uuid": "3JigUCnuSloFva6M",
      "sibling_uuid": "kfrhMtnk3mLvlDyM",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 137967656,
      "level": 1,
      "id": 137967656,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "hooks使用注意事项",
      "uuid": "kfrhMtnk3mLvlDyM",
      "url": "fsntec83rv65ub1e",
      "prev_uuid": "Lyyg2Zt3qbNBCdxv",
      "sibling_uuid": "GYHpF9b02Y6euFPU",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 137868628,
      "level": 1,
      "id": 137868628,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "解决Koa中跨域问题",
      "uuid": "GYHpF9b02Y6euFPU",
      "url": "ekgp9f9qf49vfdg9",
      "prev_uuid": "kfrhMtnk3mLvlDyM",
      "sibling_uuid": "35lS-r_2Xg-gVPI5",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 137510842,
      "level": 1,
      "id": 137510842,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "socket心跳检测",
      "uuid": "35lS-r_2Xg-gVPI5",
      "url": "ty0lc4810uno20lx",
      "prev_uuid": "GYHpF9b02Y6euFPU",
      "sibling_uuid": "mpapAdoKSg2y7lk4",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 137443477,
      "level": 1,
      "id": 137443477,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "koa-Router 和koa-router 傻傻分不清",
      "uuid": "mpapAdoKSg2y7lk4",
      "url": "md028ruhw1kkzydv",
      "prev_uuid": "35lS-r_2Xg-gVPI5",
      "sibling_uuid": "U_ue5BT7vKB_baEO",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 137379557,
      "level": 1,
      "id": 137379557,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "为什么react使用单一数据流",
      "uuid": "U_ue5BT7vKB_baEO",
      "url": "kidry53ewgsi52pg",
      "prev_uuid": "mpapAdoKSg2y7lk4",
      "sibling_uuid": "TR_HXoxqpCWHfykX",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 137283324,
      "level": 1,
      "id": 137283324,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "更改redux 数据，页面未重新渲染",
      "uuid": "TR_HXoxqpCWHfykX",
      "url": "pq90e0didogi2as4",
      "prev_uuid": "U_ue5BT7vKB_baEO",
      "sibling_uuid": "kfOO9CkgzhkTTmbF",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 137277743,
      "level": 1,
      "id": 137277743,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "npx cz 无法执行",
      "uuid": "kfOO9CkgzhkTTmbF",
      "url": "irgky2a61g0brm1e",
      "prev_uuid": "TR_HXoxqpCWHfykX",
      "sibling_uuid": "N9-FK944X2UTBUHn",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 136598282,
      "level": 1,
      "id": 136598282,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "git 首次提交远端仓库报错",
      "uuid": "N9-FK944X2UTBUHn",
      "url": "veagx91gr9qnb585",
      "prev_uuid": "kfOO9CkgzhkTTmbF",
      "sibling_uuid": "slyEzn-qzSyUVVsE",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 136256113,
      "level": 1,
      "id": 136256113,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "下包报错",
      "uuid": "slyEzn-qzSyUVVsE",
      "url": "qg566fr0qxrmwzod",
      "prev_uuid": "N9-FK944X2UTBUHn",
      "sibling_uuid": "b4HpRzGBb1gHY6Cq",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 136157960,
      "level": 1,
      "id": 136157960,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "vscode中生成ts函数组件",
      "uuid": "b4HpRzGBb1gHY6Cq",
      "url": "an8dle1vg88kkprx",
      "prev_uuid": "slyEzn-qzSyUVVsE",
      "sibling_uuid": "H6B8ivDug1W_sMT0",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 136148992,
      "level": 1,
      "id": 136148992,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "Git add. 控制台警告",
      "uuid": "H6B8ivDug1W_sMT0",
      "url": "fer2ogyut4tmc926",
      "prev_uuid": "b4HpRzGBb1gHY6Cq",
      "sibling_uuid": "Pv8vN2w2tDhkZPEg",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 136145796,
      "level": 1,
      "id": 136145796,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "tsc 无法运行",
      "uuid": "Pv8vN2w2tDhkZPEg",
      "url": "rdgk090rs7uh9bwd",
      "prev_uuid": "H6B8ivDug1W_sMT0",
      "sibling_uuid": "GEGE-m8FjAyGkUOV",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 136056260,
      "level": 1,
      "id": 136056260,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "TS不能将类型“any[]”分配给类型“never[]”",
      "uuid": "GEGE-m8FjAyGkUOV",
      "url": "kufwxvhfwtsvth7o",
      "prev_uuid": "Pv8vN2w2tDhkZPEg",
      "sibling_uuid": "6RuTdKkrGdb_f5eF",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 135898591,
      "level": 1,
      "id": 135898591,
      "open_window": 1,
      "visible": 0
    },
    {
      "type": "DOC",
      "title": "react-router-鉴权页面闪现",
      "uuid": "6RuTdKkrGdb_f5eF",
      "url": "cg2svaaug21hrh90",
      "prev_uuid": "GEGE-m8FjAyGkUOV",
      "sibling_uuid": "4acI1tcI2YRW5hbt",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 135620479,
      "level": 1,
      "id": 135620479,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "ts安装模块总是报错！原因竟然是这个！",
      "uuid": "4acI1tcI2YRW5hbt",
      "url": "ftvzk74gnak2g6w8",
      "prev_uuid": "6RuTdKkrGdb_f5eF",
      "sibling_uuid": "BDRsngx10EXL7Vmt",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 134435499,
      "level": 1,
      "id": 134435499,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "node.js - fs模块原来还能这样用？",
      "uuid": "BDRsngx10EXL7Vmt",
      "url": "tf47asaynxwhubk1",
      "prev_uuid": "4acI1tcI2YRW5hbt",
      "sibling_uuid": "nCM5IKP2QiX7nBJd",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 134194866,
      "level": 1,
      "id": 134194866,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "typeScript是js的超集",
      "uuid": "nCM5IKP2QiX7nBJd",
      "url": "bf2pmua2hv1623o9",
      "prev_uuid": "BDRsngx10EXL7Vmt",
      "sibling_uuid": "crp06BMPd8u3roTO",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 133258810,
      "level": 1,
      "id": 133258810,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "ts函数可选参数-未使用—ESlint 校验",
      "uuid": "crp06BMPd8u3roTO",
      "url": "rua0g9bcb7vgi0oq",
      "prev_uuid": "nCM5IKP2QiX7nBJd",
      "sibling_uuid": "Y9-sLcW7BkpuHUhY",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 133877134,
      "level": 1,
      "id": 133877134,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "为什么说js是动态类型语言呢？",
      "uuid": "Y9-sLcW7BkpuHUhY",
      "url": "nfknzexbccraar99",
      "prev_uuid": "crp06BMPd8u3roTO",
      "sibling_uuid": "",
      "child_uuid": "",
      "parent_uuid": "j-ATW-gMjxhNTLIj",
      "doc_id": 133257703,
      "level": 1,
      "id": 133257703,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "TITLE",
      "title": "typescript 入门指南",
      "uuid": "oht-Yfyv2VVLuo6R",
      "url": "",
      "prev_uuid": "j-ATW-gMjxhNTLIj",
      "sibling_uuid": "CIrWga-uifR8K2GM",
      "child_uuid": "OuCcliotUIRw58WV",
      "parent_uuid": "",
      "doc_id": "",
      "level": 0,
      "id": "",
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "Ts vs Js 谁适合前端开发？| 01",
      "uuid": "OuCcliotUIRw58WV",
      "url": "gkpaocb8zzni39bg",
      "prev_uuid": "oht-Yfyv2VVLuo6R",
      "sibling_uuid": "uSUXpzLBKh56x8pG",
      "child_uuid": "",
      "parent_uuid": "oht-Yfyv2VVLuo6R",
      "doc_id": 133257249,
      "level": 1,
      "id": 133257249,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "tsconfig.json 配置文件详解 | 02",
      "uuid": "uSUXpzLBKh56x8pG",
      "url": "gixzk15x3uz194ir",
      "prev_uuid": "OuCcliotUIRw58WV",
      "sibling_uuid": "xefmzJSDd3OAhi0v",
      "child_uuid": "",
      "parent_uuid": "oht-Yfyv2VVLuo6R",
      "doc_id": 136004688,
      "level": 1,
      "id": 136004688,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "TITLE",
      "title": "基础开发",
      "uuid": "xefmzJSDd3OAhi0v",
      "url": "",
      "prev_uuid": "uSUXpzLBKh56x8pG",
      "sibling_uuid": "",
      "child_uuid": "tjvbPMXi3Zc6Bv9Q",
      "parent_uuid": "oht-Yfyv2VVLuo6R",
      "doc_id": "",
      "level": 1,
      "id": "",
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "declare 和 .d.ts",
      "uuid": "tjvbPMXi3Zc6Bv9Q",
      "url": "epc7nta9i3wfbegk",
      "prev_uuid": "xefmzJSDd3OAhi0v",
      "sibling_uuid": "h240PPs1yyExSzXC",
      "child_uuid": "",
      "parent_uuid": "xefmzJSDd3OAhi0v",
      "doc_id": 139959480,
      "level": 2,
      "id": 139959480,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "typescript装饰器：简化代码、增加功能的利器",
      "uuid": "h240PPs1yyExSzXC",
      "url": "lusv5pm2rbl2ygkf",
      "prev_uuid": "tjvbPMXi3Zc6Bv9Q",
      "sibling_uuid": "epxf8K_ZFxcHlFn4",
      "child_uuid": "",
      "parent_uuid": "xefmzJSDd3OAhi0v",
      "doc_id": 136507317,
      "level": 2,
      "id": 136507317,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "语法-类型注解",
      "uuid": "epxf8K_ZFxcHlFn4",
      "url": "uddiy4ty1tfry4vt",
      "prev_uuid": "h240PPs1yyExSzXC",
      "sibling_uuid": "DLwQ95JctPNt7vF2",
      "child_uuid": "",
      "parent_uuid": "xefmzJSDd3OAhi0v",
      "doc_id": 133358097,
      "level": 2,
      "id": 133358097,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "函数",
      "uuid": "DLwQ95JctPNt7vF2",
      "url": "mqtfvzzp1agddpff",
      "prev_uuid": "epxf8K_ZFxcHlFn4",
      "sibling_uuid": "nevGBuVWHRpRUkyd",
      "child_uuid": "",
      "parent_uuid": "xefmzJSDd3OAhi0v",
      "doc_id": 133878147,
      "level": 2,
      "id": 133878147,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "枚举",
      "uuid": "nevGBuVWHRpRUkyd",
      "url": "ozukh6zecsqvagsm",
      "prev_uuid": "DLwQ95JctPNt7vF2",
      "sibling_uuid": "HOsTW0ywpASynyJ7",
      "child_uuid": "",
      "parent_uuid": "xefmzJSDd3OAhi0v",
      "doc_id": 133878116,
      "level": 2,
      "id": 133878116,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "class 类",
      "uuid": "HOsTW0ywpASynyJ7",
      "url": "iy5mr7og6iora1t1",
      "prev_uuid": "nevGBuVWHRpRUkyd",
      "sibling_uuid": "J9JW6L97BIwNXVbU",
      "child_uuid": "",
      "parent_uuid": "xefmzJSDd3OAhi0v",
      "doc_id": 133878007,
      "level": 2,
      "id": 133878007,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "终于搞懂TS中的泛型啦!!",
      "uuid": "J9JW6L97BIwNXVbU",
      "url": "pt3e0i88hm0q8fox",
      "prev_uuid": "HOsTW0ywpASynyJ7",
      "sibling_uuid": "jfvAiMEAQF2VZldZ",
      "child_uuid": "",
      "parent_uuid": "xefmzJSDd3OAhi0v",
      "doc_id": 133877978,
      "level": 2,
      "id": 133877978,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "接口",
      "uuid": "jfvAiMEAQF2VZldZ",
      "url": "fv5wevxoynyzz5gf",
      "prev_uuid": "J9JW6L97BIwNXVbU",
      "sibling_uuid": "fYPIXtlY-O5Z4dLN",
      "child_uuid": "",
      "parent_uuid": "xefmzJSDd3OAhi0v",
      "doc_id": 133877648,
      "level": 2,
      "id": 133877648,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "type 别名",
      "uuid": "fYPIXtlY-O5Z4dLN",
      "url": "hd4ini1ztt013yxo",
      "prev_uuid": "jfvAiMEAQF2VZldZ",
      "sibling_uuid": "",
      "child_uuid": "",
      "parent_uuid": "xefmzJSDd3OAhi0v",
      "doc_id": 136262450,
      "level": 2,
      "id": 136262450,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "TITLE",
      "title": "react基础开发",
      "uuid": "CIrWga-uifR8K2GM",
      "url": "",
      "prev_uuid": "oht-Yfyv2VVLuo6R",
      "sibling_uuid": "O46yg_RRd_2t2TKL",
      "child_uuid": "A0JeEaP-Pg4FSywY",
      "parent_uuid": "",
      "doc_id": "",
      "level": 0,
      "id": "",
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "react-RouterV6",
      "uuid": "A0JeEaP-Pg4FSywY",
      "url": "mzk95qvgh2ryp3tp",
      "prev_uuid": "CIrWga-uifR8K2GM",
      "sibling_uuid": "IMQnZax9TV1jn_9f",
      "child_uuid": "",
      "parent_uuid": "CIrWga-uifR8K2GM",
      "doc_id": 135703188,
      "level": 1,
      "id": 135703188,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "react内置组件",
      "uuid": "IMQnZax9TV1jn_9f",
      "url": "qdn2elswtf486gvx",
      "prev_uuid": "A0JeEaP-Pg4FSywY",
      "sibling_uuid": "kd1zM7J3XZDW-BjA",
      "child_uuid": "",
      "parent_uuid": "CIrWga-uifR8K2GM",
      "doc_id": 136732327,
      "level": 1,
      "id": 136732327,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "react 基础操作-语法、特性 、路由配置",
      "uuid": "kd1zM7J3XZDW-BjA",
      "url": "oqz4cvgu5cqxztwx",
      "prev_uuid": "IMQnZax9TV1jn_9f",
      "sibling_uuid": "aoCBtlks9FSFtvHk",
      "child_uuid": "",
      "parent_uuid": "CIrWga-uifR8K2GM",
      "doc_id": 134371301,
      "level": 1,
      "id": 134371301,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "react 函数组件中 props应用",
      "uuid": "aoCBtlks9FSFtvHk",
      "url": "vhino37ev8g0zcvs",
      "prev_uuid": "kd1zM7J3XZDW-BjA",
      "sibling_uuid": "",
      "child_uuid": "",
      "parent_uuid": "CIrWga-uifR8K2GM",
      "doc_id": 134340096,
      "level": 1,
      "id": 134340096,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "TITLE",
      "title": "react高阶使用",
      "uuid": "O46yg_RRd_2t2TKL",
      "url": "",
      "prev_uuid": "CIrWga-uifR8K2GM",
      "sibling_uuid": "jMaPVbW32vxjfFy7",
      "child_uuid": "RBmTwXlXHyQ1yaeS",
      "parent_uuid": "",
      "doc_id": "",
      "level": 0,
      "id": "",
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "如何提高redux开发效率？当然是redux-tookit啦！",
      "uuid": "RBmTwXlXHyQ1yaeS",
      "url": "sdgpnwvrp82ng4pr",
      "prev_uuid": "O46yg_RRd_2t2TKL",
      "sibling_uuid": "Daaw01jg29KSg88L",
      "child_uuid": "",
      "parent_uuid": "O46yg_RRd_2t2TKL",
      "doc_id": 140313379,
      "level": 1,
      "id": 140313379,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "immer：优雅操作react数据状态，告别繁琐克隆拷贝",
      "uuid": "Daaw01jg29KSg88L",
      "url": "dv8t85khggaglosv",
      "prev_uuid": "RBmTwXlXHyQ1yaeS",
      "sibling_uuid": "0rOkbaEh-s1uwVVm",
      "child_uuid": "",
      "parent_uuid": "O46yg_RRd_2t2TKL",
      "doc_id": 137087662,
      "level": 1,
      "id": 137087662,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "react 高阶组件",
      "uuid": "0rOkbaEh-s1uwVVm",
      "url": "uyhgxnhx5izuzaiu",
      "prev_uuid": "Daaw01jg29KSg88L",
      "sibling_uuid": "ndkaPKdq1fy3OjMq",
      "child_uuid": "",
      "parent_uuid": "O46yg_RRd_2t2TKL",
      "doc_id": 137034928,
      "level": 1,
      "id": 137034928,
      "open_window": 1,
      "visible": 0
    },
    {
      "type": "DOC",
      "title": "React通信",
      "uuid": "ndkaPKdq1fy3OjMq",
      "url": "kcb12zwkginqus50",
      "prev_uuid": "0rOkbaEh-s1uwVVm",
      "sibling_uuid": "MIpY3duOBCYJXOT9",
      "child_uuid": "",
      "parent_uuid": "O46yg_RRd_2t2TKL",
      "doc_id": 135769978,
      "level": 1,
      "id": 135769978,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "如何设计react路由系统",
      "uuid": "MIpY3duOBCYJXOT9",
      "url": "qlo4yi98lu48nycz",
      "prev_uuid": "ndkaPKdq1fy3OjMq",
      "sibling_uuid": "y9Pg9dyIFPe4FthG",
      "child_uuid": "",
      "parent_uuid": "O46yg_RRd_2t2TKL",
      "doc_id": 135707663,
      "level": 1,
      "id": 135707663,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "学习react-redux，看这篇文章就够啦！",
      "uuid": "y9Pg9dyIFPe4FthG",
      "url": "gg9lt52dzff45ecl",
      "prev_uuid": "MIpY3duOBCYJXOT9",
      "sibling_uuid": "j_XcoIuJa1dwB5dU",
      "child_uuid": "",
      "parent_uuid": "O46yg_RRd_2t2TKL",
      "doc_id": 134102506,
      "level": 1,
      "id": 134102506,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "react hooks 全攻略",
      "uuid": "j_XcoIuJa1dwB5dU",
      "url": "slaatvufmrio04vo",
      "prev_uuid": "y9Pg9dyIFPe4FthG",
      "sibling_uuid": "0LbwxVHF4zoGNaNU",
      "child_uuid": "",
      "parent_uuid": "O46yg_RRd_2t2TKL",
      "doc_id": 134102445,
      "level": 1,
      "id": 134102445,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "react 组件设计模式",
      "uuid": "0LbwxVHF4zoGNaNU",
      "url": "qpitxccddbg9owse",
      "prev_uuid": "j_XcoIuJa1dwB5dU",
      "sibling_uuid": "",
      "child_uuid": "",
      "parent_uuid": "O46yg_RRd_2t2TKL",
      "doc_id": 134102466,
      "level": 1,
      "id": 134102466,
      "open_window": 0,
      "visible": 0
    },
    {
      "type": "TITLE",
      "title": "react源码解析",
      "uuid": "jMaPVbW32vxjfFy7",
      "url": "",
      "prev_uuid": "O46yg_RRd_2t2TKL",
      "sibling_uuid": "IDS_ilmT1n5wxqvS",
      "child_uuid": "9x8BXEMeiOwue4Wq",
      "parent_uuid": "",
      "doc_id": "",
      "level": 0,
      "id": "",
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "React 深入理解",
      "uuid": "9x8BXEMeiOwue4Wq",
      "url": "ze2ns8tfg1huvi1m",
      "prev_uuid": "jMaPVbW32vxjfFy7",
      "sibling_uuid": "qx98EFopliFCl8i7",
      "child_uuid": "",
      "parent_uuid": "jMaPVbW32vxjfFy7",
      "doc_id": 138579162,
      "level": 1,
      "id": 138579162,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "终于搞懂虚拟Dom啦！",
      "uuid": "qx98EFopliFCl8i7",
      "url": "nhv8wotm3138tar0",
      "prev_uuid": "9x8BXEMeiOwue4Wq",
      "sibling_uuid": "nnDtCRS2w_Gb9cPD",
      "child_uuid": "",
      "parent_uuid": "jMaPVbW32vxjfFy7",
      "doc_id": 135206541,
      "level": 1,
      "id": 135206541,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "手写jsx",
      "uuid": "nnDtCRS2w_Gb9cPD",
      "url": "szzvahg5dd1409ts",
      "prev_uuid": "qx98EFopliFCl8i7",
      "sibling_uuid": "Er0mj9M2JzDxknt1",
      "child_uuid": "",
      "parent_uuid": "jMaPVbW32vxjfFy7",
      "doc_id": 135196228,
      "level": 1,
      "id": 135196228,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "手写useState",
      "uuid": "Er0mj9M2JzDxknt1",
      "url": "pgk56d22hdw601yr",
      "prev_uuid": "nnDtCRS2w_Gb9cPD",
      "sibling_uuid": "G_rPX5A_86XC05-w",
      "child_uuid": "",
      "parent_uuid": "jMaPVbW32vxjfFy7",
      "doc_id": 135196179,
      "level": 1,
      "id": 135196179,
      "open_window": 0,
      "visible": 0
    },
    {
      "type": "DOC",
      "title": "手写hooks",
      "uuid": "G_rPX5A_86XC05-w",
      "url": "ziabxi0gm6yoh8gy",
      "prev_uuid": "Er0mj9M2JzDxknt1",
      "sibling_uuid": "",
      "child_uuid": "",
      "parent_uuid": "jMaPVbW32vxjfFy7",
      "doc_id": 135196146,
      "level": 1,
      "id": 135196146,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "TITLE",
      "title": "案例开发",
      "uuid": "IDS_ilmT1n5wxqvS",
      "url": "",
      "prev_uuid": "jMaPVbW32vxjfFy7",
      "sibling_uuid": "",
      "child_uuid": "QOeWgH5izm0AGvV8",
      "parent_uuid": "",
      "doc_id": "",
      "level": 0,
      "id": "",
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "一个vuepress配置问题，引发的js递归算法思考",
      "uuid": "QOeWgH5izm0AGvV8",
      "url": "od0ahbmsfgdw3kpm",
      "prev_uuid": "IDS_ilmT1n5wxqvS",
      "sibling_uuid": "AleocWyd94hlSKzt",
      "child_uuid": "",
      "parent_uuid": "IDS_ilmT1n5wxqvS",
      "doc_id": 141225759,
      "level": 1,
      "id": 141225759,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "reactRouter 实现页面级按钮权限",
      "uuid": "AleocWyd94hlSKzt",
      "url": "rh3dq3cwdm2g1cg4",
      "prev_uuid": "QOeWgH5izm0AGvV8",
      "sibling_uuid": "tEWKfyMrmwIlxywJ",
      "child_uuid": "",
      "parent_uuid": "IDS_ilmT1n5wxqvS",
      "doc_id": 141197194,
      "level": 1,
      "id": 141197194,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "TITLE",
      "title": "本地上传+阿里云oss",
      "uuid": "tEWKfyMrmwIlxywJ",
      "url": "",
      "prev_uuid": "AleocWyd94hlSKzt",
      "sibling_uuid": "GpqJCC41Og6_Gcyi",
      "child_uuid": "ip12xxUIw9K8xNYO",
      "parent_uuid": "IDS_ilmT1n5wxqvS",
      "doc_id": "",
      "level": 1,
      "id": "",
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "antd 实现批量上传",
      "uuid": "ip12xxUIw9K8xNYO",
      "url": "dtgppmg1dymqgsde",
      "prev_uuid": "tEWKfyMrmwIlxywJ",
      "sibling_uuid": "v47ZNm2tGlVgpLE6",
      "child_uuid": "",
      "parent_uuid": "tEWKfyMrmwIlxywJ",
      "doc_id": 137854318,
      "level": 2,
      "id": 137854318,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "阿里云oss基础使用",
      "uuid": "v47ZNm2tGlVgpLE6",
      "url": "dcdb8p31qp8y4zes",
      "prev_uuid": "ip12xxUIw9K8xNYO",
      "sibling_uuid": "7Tmj7H8hXz9h5LFF",
      "child_uuid": "",
      "parent_uuid": "tEWKfyMrmwIlxywJ",
      "doc_id": 137512492,
      "level": 2,
      "id": 137512492,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "阿里云oss开发实践：大文件分片、断点续传、实时进度 React+Node+Socket.IO",
      "uuid": "7Tmj7H8hXz9h5LFF",
      "url": "qai06nw793lx62hm",
      "prev_uuid": "v47ZNm2tGlVgpLE6",
      "sibling_uuid": "D5Emesj1p56iBnS8",
      "child_uuid": "",
      "parent_uuid": "tEWKfyMrmwIlxywJ",
      "doc_id": 134613703,
      "level": 2,
      "id": 134613703,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "React+node 图片剪裁上传，集成本地存储和阿里云OSS",
      "uuid": "D5Emesj1p56iBnS8",
      "url": "xtgxqhiyw52hvk3r",
      "prev_uuid": "7Tmj7H8hXz9h5LFF",
      "sibling_uuid": "dmz0JsmsEtJTD2VS",
      "child_uuid": "",
      "parent_uuid": "tEWKfyMrmwIlxywJ",
      "doc_id": 134613743,
      "level": 2,
      "id": 134613743,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "react+node 本地大文件分片上传、断点续传",
      "uuid": "dmz0JsmsEtJTD2VS",
      "url": "gx7xpdd7oom87eeu",
      "prev_uuid": "D5Emesj1p56iBnS8",
      "sibling_uuid": "",
      "child_uuid": "",
      "parent_uuid": "tEWKfyMrmwIlxywJ",
      "doc_id": 135192127,
      "level": 2,
      "id": 135192127,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "路由守卫全系列",
      "uuid": "GpqJCC41Og6_Gcyi",
      "url": "lw9yfokviowgggeg",
      "prev_uuid": "tEWKfyMrmwIlxywJ",
      "sibling_uuid": "ZoNztM_5ewVzsy-v",
      "child_uuid": "",
      "parent_uuid": "IDS_ilmT1n5wxqvS",
      "doc_id": 137754173,
      "level": 1,
      "id": 137754173,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "react+echarts",
      "uuid": "ZoNztM_5ewVzsy-v",
      "url": "lhkxca986wzmi9s3",
      "prev_uuid": "GpqJCC41Og6_Gcyi",
      "sibling_uuid": "ZwMwOw_n4-PAYjql",
      "child_uuid": "",
      "parent_uuid": "IDS_ilmT1n5wxqvS",
      "doc_id": 137454519,
      "level": 1,
      "id": 137454519,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "封装路由守卫组件",
      "uuid": "ZwMwOw_n4-PAYjql",
      "url": "afmy86kvqwltgq5c",
      "prev_uuid": "ZoNztM_5ewVzsy-v",
      "sibling_uuid": "-u1YAH1RoOYMzK1C",
      "child_uuid": "",
      "parent_uuid": "IDS_ilmT1n5wxqvS",
      "doc_id": 135703430,
      "level": 1,
      "id": 135703430,
      "open_window": 0,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "RBAC权限管理",
      "uuid": "-u1YAH1RoOYMzK1C",
      "url": "mz8m056g258v9c9w",
      "prev_uuid": "ZwMwOw_n4-PAYjql",
      "sibling_uuid": "KxVXijwID-Ta6aJl",
      "child_uuid": "",
      "parent_uuid": "IDS_ilmT1n5wxqvS",
      "doc_id": 136833356,
      "level": 1,
      "id": 136833356,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "「token方案指南」前后端鉴权-超时未操作登出",
      "uuid": "KxVXijwID-Ta6aJl",
      "url": "ueopfvai6y6du4ac",
      "prev_uuid": "-u1YAH1RoOYMzK1C",
      "sibling_uuid": "JJgJnaFu797EeLAK",
      "child_uuid": "",
      "parent_uuid": "IDS_ilmT1n5wxqvS",
      "doc_id": 136759556,
      "level": 1,
      "id": 136759556,
      "open_window": 1,
      "visible": 1
    },
    {
      "type": "DOC",
      "title": "支付宝支付",
      "uuid": "JJgJnaFu797EeLAK",
      "url": "rai6wzr3c4mefzyg",
      "prev_uuid": "KxVXijwID-Ta6aJl",
      "sibling_uuid": "",
      "child_uuid": "",
      "parent_uuid": "IDS_ilmT1n5wxqvS",
      "doc_id": 134613718,
      "level": 1,
      "id": 134613718,
      "open_window": 0,
      "visible": 0
    }
  ]
}