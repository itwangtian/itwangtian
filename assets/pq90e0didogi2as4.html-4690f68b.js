import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as t,e as r}from"./app-125d34e2.js";const s={},d=r('<h1 id="场景" tabindex="-1"><a class="header-anchor" href="#场景" aria-hidden="true">#</a> 场景</h1><p>在 reducer 中使用 object.assign(state,{data:xxx}) 合并了状态，控制台打印 state 数据已更新，但是页面未重新渲染</p><h1 id="原因" tabindex="-1"><a class="header-anchor" href="#原因" aria-hidden="true">#</a> 原因</h1><p>redux 会通过引用来判断前后两次 state 有没有变化。return 原来的 state 的话 redux 会认为你的 state 没有变化。</p><p>咱们用 Object.assign(state,xx)是直接修改了 state 对象，然后返回的还是原来的 state 对象（被修改过的数据）但是引用未更改，还是同一引用源。</p><h1 id="解决" tabindex="-1"><a class="header-anchor" href="#解决" aria-hidden="true">#</a> 解决</h1><p>使用而扩展符则是创建了一个新的对象，相当于 Object.assign({},state,...)</p><p><strong>注意</strong>：不要在 reducer 里面做以下操作<br> 1、修改传入参数；<br> 2、执行有副作用的操作，如 API 请求和路由跳转；<br> 3、调用非纯函数，如 Date.now() 或 Math.random()。</p>',8),n=[d];function c(i,o){return a(),t("div",null,n)}const _=e(s,[["render",c],["__file","pq90e0didogi2as4.html.vue"]]);export{_ as default};
