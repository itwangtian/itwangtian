const e=JSON.parse('{"key":"v-50bd5012","path":"/docs/pt3e0i88hm0q8fox.html","title":"终于搞懂TS中的泛型啦!!","lang":"zh-CN","frontmatter":{"title":"终于搞懂TS中的泛型啦!!","urlname":"pt3e0i88hm0q8fox","date":"2023-07-21 10:24:33","updated":"2023-10-01 22:04:50","description":"1. 前言 我们可以把泛型比喻为一个类型占位符，它告诉编译器：“嘿，这里有一个类型参数，我现在不确定具体是什么类型，但稍后会告诉你。” 通过使用泛型，我们可以编写更灵活、更可复用的代码。它允许我们在定义函数、类或接口时使用类型占位符来表示类型，而不直接指定具体的类型。这样，在实际使用时，我们可以传入不同的类型参数，使得代码可以适用于多种情况。 例如，让我们看一个简单的例子，来解释泛型的使用。假设我们有一个名为 identity 的函数，它接受一个参数并返回该参数： function identity&lt;T&gt;(value: T): T { return value; }","head":[["meta",{"property":"og:url","content":"http://www.itwangtian.com/docs/pt3e0i88hm0q8fox.html"}],["meta",{"property":"og:site_name","content":"王天的web进阶之路"}],["meta",{"property":"og:title","content":"终于搞懂TS中的泛型啦!!"}],["meta",{"property":"og:description","content":"1. 前言 我们可以把泛型比喻为一个类型占位符，它告诉编译器：“嘿，这里有一个类型参数，我现在不确定具体是什么类型，但稍后会告诉你。” 通过使用泛型，我们可以编写更灵活、更可复用的代码。它允许我们在定义函数、类或接口时使用类型占位符来表示类型，而不直接指定具体的类型。这样，在实际使用时，我们可以传入不同的类型参数，使得代码可以适用于多种情况。 例如，让我们看一个简单的例子，来解释泛型的使用。假设我们有一个名为 identity 的函数，它接受一个参数并返回该参数： function identity&lt;T&gt;(value: T): T { return value; }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-15T02:54:53.000Z"}],["meta",{"property":"article:author","content":"程序员王天"}],["meta",{"property":"article:published_time","content":"2023-07-21T10:24:33.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-15T02:54:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"终于搞懂TS中的泛型啦!!\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-07-21T10:24:33.000Z\\",\\"dateModified\\":\\"2023-10-15T02:54:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"程序员王天\\",\\"url\\":\\"http://www.itwangtian.com\\"}]}"]]},"headers":[{"level":2,"title":"1. 前言","slug":"_1-前言","link":"#_1-前言","children":[{"level":3,"title":"基本使用","slug":"基本使用","link":"#基本使用","children":[]}]},{"level":2,"title":"2. 使用泛型变量：","slug":"_2-使用泛型变量","link":"#_2-使用泛型变量","children":[]},{"level":2,"title":"3. 泛型类型：","slug":"_3-泛型类型","link":"#_3-泛型类型","children":[]},{"level":2,"title":"4. 泛型类：","slug":"_4-泛型类","link":"#_4-泛型类","children":[]},{"level":2,"title":"5. 泛型约束：","slug":"_5-泛型约束","link":"#_5-泛型约束","children":[{"level":3,"title":"5.1. 确保属性存在","slug":"_5-1-确保属性存在","link":"#_5-1-确保属性存在","children":[]},{"level":3,"title":"5.2 检查对象的 key","slug":"_5-2-检查对象的-key","link":"#_5-2-检查对象的-key","children":[]}]},{"level":2,"title":"6 泛型接口：","slug":"_6-泛型接口","link":"#_6-泛型接口","children":[{"level":3,"title":"接口搭配泛型，应用在 calss 类上","slug":"接口搭配泛型-应用在-calss-类上","link":"#接口搭配泛型-应用在-calss-类上","children":[]}]}],"git":{"createdTime":1696082032000,"updatedTime":1697338493000,"contributors":[{"name":"1970652600@qq.com~","email":"1970652600@qq.com","commits":3},{"name":"小王在努力","email":"17638567073@163.com","commits":1}]},"readingTime":{"minutes":6.43,"words":1930},"filePathRelative":"docs/pt3e0i88hm0q8fox.md","localizedDate":"2023年7月21日","excerpt":"<h2> 1. 前言</h2>\\n<p>我们可以把泛型比喻为一个类型占位符，它告诉编译器：“嘿，这里有一个类型参数，我现在不确定具体是什么类型，但稍后会告诉你。”</p>\\n<p>通过使用泛型，我们可以编写更灵活、更可复用的代码。它允许我们在定义函数、类或接口时使用类型占位符来表示类型，而不直接指定具体的类型。这样，在实际使用时，我们可以传入不同的类型参数，使得代码可以适用于多种情况。</p>\\n<p>例如，让我们看一个简单的例子，来解释泛型的使用。假设我们有一个名为 <code>identity</code> 的函数，它接受一个参数并返回该参数：</p>\\n<div class=\\"language-typescript line-numbers-mode\\" data-ext=\\"ts\\"><pre class=\\"language-typescript\\"><code><span class=\\"token keyword\\">function</span> <span class=\\"token generic-function\\"><span class=\\"token function\\">identity</span><span class=\\"token generic class-name\\"><span class=\\"token operator\\">&lt;</span><span class=\\"token constant\\">T</span><span class=\\"token operator\\">&gt;</span></span></span><span class=\\"token punctuation\\">(</span>value<span class=\\"token operator\\">:</span> <span class=\\"token constant\\">T</span><span class=\\"token punctuation\\">)</span><span class=\\"token operator\\">:</span> <span class=\\"token constant\\">T</span> <span class=\\"token punctuation\\">{</span>\\n  <span class=\\"token keyword\\">return</span> value<span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{e as data};
